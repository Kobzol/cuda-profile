\todo[inline]{Zkratky jsou v seznamu zkratek - rozepisovat a vysvětlovat je i v textu, když je poprvé zmíním?}

Už desítky let platí, že frekvence počítačových procesorů je několikanásobně rychlejší než frekvence jejich operační paměti. Tato nerovnováha může způsobit výrazné zpomalení aplikace, pokud procesor neustále jen čeká, než k němu dorazí požadovaná data z paměti. Procesory z tohoto důvodu už dlouhou dobu obsahují malé a rychlé cache paměti. Ty ale samy o sobě nestačí. Aby byl jejich potenciál plně využit, musí být program navržen pro efektivní využití cache. Lze například ovlivnit zarovnání a velikost použitých datových struktur s ohledem na velikost řádek cache nebo používat speciální instrukce procesoru pro práci s cache pamětí (například přednačítání nebo netemporální zápisy). Obecně řečeno je nutno zajistit, aby přístupy do paměti měly dobrou časovou a prostorovou lokalitu - to je jednou z nejdůležitějších podmínek nutných pro maximální výkon výpočtu. Aby však mohl programátor s pamětí takto pracovat, potřebuje k tomu vhodné nástroje.

Pro efektivní využití paměti je nutno použít programovací jazyk, který s ní dovoluje manipulovat přímo, což často není možné v moderních jazycích vysoké úrovně. Umožňují to pouze jazyky, které mají blízko k hardwaru počítače, jako je například \emph{C} a \emph{C++}. Pomocí nich lze velmi detailně ovládat, jakým způsobem bude procesor využívat operační paměť, což je také jeden z důvodů, proč jsou často používány pro výkonnostní výpočty.

Kromě vhodného programovacího jazyka je pro optimalizaci paměťových přístupů nutná ještě jedna věc - zpětná vazba o tom, co se za běhu programu s pamětí děje. Existuje mnoho profilovacích nástrojů, které měří dobu výpočtu strávenou v jednotlivých funkcích~\cite{gprof}, analyzují alokovanou paměť procesu~\cite{massif} nebo dokonce simulují cache procesoru~\cite{nethercotephd}. Pokročilejší nástroje dokáží k jednotlivým řádkům kódu dodat informaci o tom, jestli byl přístup do paměti efektivní nebo ne (tj. jestli přistupoval do hlavní paměti nebo do některé z cache pamětí)~\cite{vtune}.

Tyto nástroje umožňují naměřit výkon aplikace a po provedené změně v kódu tak pomáhají určit, jestli změna ovlivnila výkon a jestli vedla ke zkrácení nebo prodloužení doby výpočtu. Naměřené informace o výkonu však neposkytují návod k tomu, jakou změnu v aplikaci udělat, aby běžela rychleji. Při komplexitě dnešních překladačů (popř. běhových prostředí) může být velmi složité poznat, jak změna v kódu ovlivní práci s pamětí a samotný výkon aplikace. To lze zjistit pouze zaznamenáním informací z reálného běhu programu - po odstranění abstrakcí kódu a aplikování optimalizací překladačem. Tyto údaje poté mohou sloužit k pochopení toho, jak aplikace s pamětí pracuje a kde jsou případná úzká hrdla.

Jednou z oblastí, kde je kladen velký důraz na efektivní práci s pamětí a maximální výkon, jsou výpočty prováděné na grafických kartách. Ty byly sice původně určené výhradně pro grafické aplikace, nicméně později vznikla programovatelná rozhraní, která na grafických akcelerátorech umožnila provádět libovolné výpočty. Díky tomu se začaly hojně používat pro výkonnostní výpočty, například pro fyzikální simulace nebo strojové učení. Grafické karty mají jinou architekturu než klasické procesory. Skládají se až z tisícovek jader, která jsou sice méně výkonná než jádra procesoru, ale díky svému počtu zvládnou paralelně zpracovat obrovské množství dat. O to více je u těchto karet důležitý efektivní přístup do paměti, o kterou soupeří spousta vláken zároveň. Jednotlivé generace architektur grafických karet také mohou vyžadovat specifické vzory přístupu do paměti pro dosažení maximální efektivity.

Tato práce si klade za cíl vytvořit nástroj, který umožní zaznamenat paměťové přístupy konkrétního běhu aplikace a zobrazit je v intuitivní podobě programátorovi. Tato vizualizace by měla umožnit pochopit kam, kdy a jak aplikace přistupuje do paměti a použít tato data k zefektivnění těchto přístupů. Nástroj je zaměřený na paralelní aplikace pro grafické karty, u kterých je efektivní práce s pamětí velmi důležitá. Zároveň pro ně ale existuje pouze zlomek profilovacích nástrojů ve srovnání s nástroji pro klasické procesory. Tento nástroj by tak byl užitečný pro poskytnutí přehledu o paměťových operacích na grafické kartě.

Implementace profilovacího nástroje je zaměřena na platformu Linux, jazyk C/C++ a architekturu grafických karet CUDA, popsané principy jsou však aplikovatelné univerzálně. V této práci jsou používány výrazy CPU (Central processing unit) a GPU (Graphics processing unit). Pokud není uvedeno jinak, tak CPU označuje procesor počítače, resp. kód, který na něm běží, obdobně GPU označuje grafický akcelerátor, resp. kód, který na ní běží.

Kapitola \ref{sec:technology} poskytuje přehled o metodách používaných k profilování aplikací a technologiích použitých v této práci. Dále v kapitole \ref{sec:stateoftheart} následuje popis existujících nástrojů pro profilování paralelních aplikací. Kapitola \ref{sec:profiler} popisuje návrh a implementaci profilovacího nástroje a následující kapitola \ref{sec:visualisation} poté vývoj vizualizační aplikace. Poté následuje zhodnocení dosažených výsledků a popis možných rozšíření nástroje. 
