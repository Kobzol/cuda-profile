Tato kapitola popisuje existující profilovací a~instrumentační nástroje pro platformu CUDA a~dále zmiňuje nástroje určené pro vizualizaci paměťových přístupů.

\subsection{Profilovací nástroje}
Pro grafické karty existuje pouze zlomek profilovacích nástrojů ve srovnání s~nástroji dostupnými pro profilování procesorů. U~obou platforem však platí, že nejpokročilejší nástroje jsou vyvíjeny samotným výrobcem daného hardwaru (Intel, Nvidia, AMD)~\cite{vtune}~\cite{nsight}~\cite{codexl}. Mikroarchitektury moderních procesorů jsou velmi složité a~často nejsou veřejně známy veškeré jejich detaily. Pouze jejich výrobce tak může vytvořit nástroj, který z~nich dokáže vyčíst maximum informací. V~této kapitole jsou popsány profilovací nástroje pro platformu CUDA.

\subsubsection{Nsight}
Nsight je vývojové prostředí integrované v~programech Eclipse a~Visual Studio, které usnadňuje vývoj, profilování a~ladění programů pro grafické karty od Nvidie. Je vyvíjené přímo společností Nvidia, takže dokáže zjistit velké množství údajů o~provádění CUDA kódu pomocí používání nezdokumentovaných funkcí. Nabízí pokročilé ladící nástroje, například krokování v~kernelech, zobrazení registrů jednotlivých vláken, rozložení vláken mezi warpy, kontrolu chybných přístupů do paměti aj. Umožňuje také velice detailně profilovat provádění GPU kódu díky vestavěnému nástroji s~názvem Visual Profiler.

Rozhraní tohoto nástroje si lze prohlédnout na obrázku \ref{fig:visual-profiler-screenshot}. Po spuštění CUDA programu se v~nástroji zobrazí časová osa, ze které lze vyčíst dobu trvání paměťových přenosů mezi procesorem a~grafickou kartou a~také dobu provádění jednotlivých kernelů. Díky této vizualizaci lze například určit, jestli by dávalo smysl překrýt přenos paměti s~výpočtem. Kromě ní však nástroj nabízí i~velmi detailní profilování kódu. Nástroj sám postupně vede programátora k~informacím o~programu, které ho zajímají. Nejprve se program spustí a~zobrazí se vytížení jednotlivých kernelů. Poté je programátor vyzván k~tomu, aby si vybral kernel, který ho zajímá, a~při příštím spuštění už se profilování zaměřuje na něj. Analýza kernelu pak nabízí zkoumání propustnosti a~odezvy paměti nebo aritmetických výpočtů. V~nástroji si lze také prohlédnout zdrojový kód kernelu s~vyznačenými řádky, které zabíraly nejvíce času výpočtu, např. kvůli tomu, že instrukce čekaly na data z~paměti.

Tento nástroj poskytuje detailní analýzu běhu programu, která je nepostradatelná pro získání maximálního výkonu z~grafických karet. Všechny údaje nabízené tímto nástrojem jsou však agregované. Jsou k~dispozici údaje o~počtu nebo poměru událostí v~programu, nelze z~něj ale získat informace o~konkrétních přístupech do paměti. Z~nástroje nelze přímo vyčíst, jaké přístupové vzory do paměti vlákna používala nebo kde přesně může docházet k~paměťovým konfliktům. 
Visual Profiler se snaží mít co nejmenší vliv na výkon programu, proto ani takto detailní údaje zaznamenávat efektivně nemůže.

\InsertFigureSource{visual-profiler-screenshot}{\textwidth}{Časová osa kernelů ve Visual Profileru}{fig:visual-profiler-screenshot}{\url{https://www.microway.com/hpc-tech-tips/accelerating-code}}

\subsubsection{nvprof}
Nvprof je nástroj bez grafického prostředí určený pro profilování CUDA programů. Pomocí vzorkování umožňuje rychle zjistit, které funkce v~CUDA programech zabírají nejdelší čas výpočtu. Kromě profilování GPU může zároveň vzorkovat i~CPU kód a~poskytnout tak ucelený pohled na výkon aplikace. Data naměřená tímto programem lze vizualizovat ve Visual Profileru, čehož lze využít například pro profilování aplikací v~prostředích bez grafického rozhraní. 

\subsubsection{CUPTI}
CUPTI je programovatelné rozhraní pro získávání profilovacích údajů a~čtení výkonnostních čítačů z~CUDA akcelerátorů. Jedná se o~základní profilovací rozhraní, které využívají profilovací nástroje a~knihovny (například PAPI, TAU nebo VampirTrace~\cite{tau, vampir}).
Celkem nabízí čtyři typy rozhraní - Activity, Callback, Event a~Metric. Activity rozhraní umožňuje získávat asynchronně záznamy o~konkrétních operacích provedených na GPU. Lze například zjistit, kolikrát byl proveden konkrétní zápis do paměti, jak probíhaly přenosy paměti nebo kolikrát a~s~jakými parametry byl spuštěn nějaký kernel. Rozhraní Callback umožňuje nadefinovat si funkci, která bude zavolána při spuštění zvolené funkce CUDA rozhraní. Lze tak například provést libovolný kód při každém kopírování nebo alokaci paměti na grafické kartě. Rozhraní Event umožňuje zaznamenat čítače vestavěné v~hardwaru grafických karet. Tyto čítače obsahují například informace o~počtu provedených instrukcí, poměru požadované a~skutečné paměťové odezvy pro jednotlivé typy paměti nebo počet úspěšných přístupů do cache paměti. Tyto údaje pak lze v~agregované podobě číst pomocí Metric rozhraní.

CUPTI sice umožňuje zaznamenat spoustu informací, které by byly užitečné pro nástroj vyvíjený v~této práci, tyto údaje jsou ale stále agregované. Pro detailní vizualizaci konkrétních paměťových přístupů je potřeba mít data o~každém přístupu zvlášť, a~tento způsob sběru dat CUPTI nepodporuje.

\subsection{Instrumentační nástroje}
Existuje několik robustních nástrojů, které umožňují instrumentovat klasické CPU programy~\cite{valgrind, pin, dynamorio}. Instrumentace aplikací pro grafické karty však není tak rozšířená. Pro platformu CUDA existují nástroje SASSI~\cite{sassi}, Lynx~\cite{lynx} a~Panoptes~\cite{panoptes}.

\subsubsection*{SASSI}
SASSI je nástroj pro instrumentaci CUDA kódu, který obsahuje vlastní verzi překladače PTX (zdrojový kód překladače není zveřejněn). Umožňuje spouštět uživatelem dodaný kód v~\CPP\hspace{1mm}při různých událostech v~CUDA programu (provedení instrukce, zavolání funkce). Události obsahují informaci o~prováděném kódu, např. pro paměťový přístup lze zjistit adresu čtení či zápisu, umístění instrukce ve zdrojovém kódu aj. Tato funkcionalita by byla dostatečná k~zaznamenání paměťových přístupů, nicméně SASSI už není aktivně vyvíjeno. Podporuje pouze CUDA 7 z~roku 2015 a~pro překlad vyžaduje velmi staré verze překladačů. Z~důvodu uzavřeného zdrojového kódu není možné kód jednoduše modifikovat pro novější verze.

\subsubsection*{Lynx}
Lynx je součástí frameworku Ocelot~\cite{ocelot}, který umožňuje překládat CUDA kód pro běh na platformách, které jinak nejsou kompatibilní s~platformou CUDA (CPU a~grafické karty AMD). Lynx používá komponenty Ocelotu pro zpracování a~překlad PTX kódu, který tak lze dyna\-micky instrumentovat. Stejně jako SASSI už Lynx ani Ocelot nejsou aktivně vyvíjeny (poslední verze, kterou podporovaly, je CUDA 5) a~nelze je použít pro instrumentování moderních CUDA programů.

\subsubsection*{Panoptes}
Panoptes za běhu aplikace zachytává CUDA volání a~dynamicky modifikuje chování programu. K~tomu využívá parser PTX. Při spuštění kernelu načte PTX kód, upraví ho a~upravený kód poté pošle dále CUDA driveru k~překladu. Autor tohoto nástroje jej využil k~implementaci kontroly korektnosti paměťových přístupů, inspirované nástrojem Memcheck. Podobná funkcionalita byla později přidána přímo do CUDA frameworku společností Nvidia. Tento nástroj již dlouho není aktivně vyvíjen a~nepodporuje veškeré instrukce PTX.

Z~příkladu uvedených nástrojů je zřejmé, že udržovat instrumentační nástroje pro grafické karty je velmi obtížný úkol. Architektura a~programovací rozhraní grafických karet se často mění a~Nvidia neposkytuje žádné otevřené zpětně kompatibilní rozhraní pro práci se svým překladačem. Jediným udržitelným řešením je tak v~současné době použití překladače LLVM, který překlad CUDA programů podporuje a~je aktivně vyvíjen širokou komunitou společností i~jednotlivců.

\subsection{Vizualizační nástroje}
Vizualizace přístupů do paměti nebývá běžnou součástí profilovacích nástrojů. Ty obvykle vizu\-alizují komunikaci mezi procesy~\cite{tau, vampir}, čas strávený v~jednotlivých funkcích~\cite{flamegraph} nebo dyna\-mické alokace paměti~\cite{gcspy, dynmem-visualisation}. Analýza přístupů do pamětí zatím našla své uplatnění v~reverzním inženýrství a~také u~NUMA architektur. Následuje popis několika nástrojů, které se věnují vizualizaci přístupů do paměti.

\subsubsection*{Tracectory}
Tracectory~\cite{tracectory} je nástroj, který analyzuje záznamy běhu Windows aplikací generované ladícím nástrojem OllyDbg. Z~těchto záznamů poté vytváří jednoduchý 2D graf, kde je na horizontální ose adresa v~paměti a~na vertikální ose čas. Ukázku tohoto grafu si lze prohlédnout na obrázku \ref{fig:tracectory}. Díky této vizualizaci lze jednoduše rozpoznat časté vzory přístupu do paměti. Například instrukce, které čtou či zapisují z~po sobě jdoucích adres na grafu vytvoří diagonálu. Naopak náhodné přístupy do paměti, které jsou často neefektivní, na grafu vytvoří mřížku bez zjevného řádu. Dále lze v~tomto nástroji zjistit, jaká hodnota byla uložena v~paměti v~danou chvíli. Motivací pro tvorbu tohoto nástroje byla reverzní analýza kódu. Díky vizualizaci paměťových přístupů lze totiž analyzovat například chování obfuskovaných programů.

\subsubsection*{Memview}
Memview~\cite{memview} vizualizuje mapu paměti běžícího procesu v~reálném čase. Zobrazuje jednotlivá čtení a~zápisy v~paměti a~umožňuje škálovat zobrazení od celého adresního prostoru až po jednotlivé byty. K~zaznamenání přístupů do paměti využívá instrumentační framework Valgrind. Na obrázku \ref{fig:memview} lze vidět mapu paměti běžícího procesu. Z~obrázku je patrný jeden z~problémů vizualizace paměti - k~dispozici je ohromné množství dat, ve kterém může být složité se vyznat.

\subsubsection*{Memory Trace Visualizer}
Memory Trace Visualizer~\cite{mtv} je nástroj, který vizualizuje zaznamenanou sekvenci paměťových operací běhu programu. Při vizualizaci probíhá simulace cache paměti, což umožňuje analyzovat přibližnou efektivitu jejího využití. Pro usnadnění orientace v~paměti lze zvolit oblast paměti, která bude zobrazena. Oblasti lze poté interpretovat různým způsobem, například jako klasické jednorozměrné pole nebo jako dvourozměrnou matici. Pro získání paměťových přístupů je použit nástroj CHUD\footnote{Computer Hardware Understanding Development} od společnosti Apple.

\subsubsection*{NUMA architektury}
Několik publikací~\cite{numa-visualisation, numa-tabarnac} se věnuje také analýze přístupů do paměti u~NUMA architektur. Ty mají operační paměť rozdělenou na několik modulů a~přístupy do jednotlivých modulů nejsou stejně efektivní ze všech jader či soketů. Je proto užitečné vizualizovat informace o~tom, do jaké části paměti jednotlivá vlákna přistupují. U~těchto architektur se analyzuje hlavně to, které vlákno poprvé přistoupilo k~dané paměťové stránce (first-touch). To poté totiž ovlivňuje, na kterém paměťovém modulu bude stránka fyzicky naalokována. Poté je také důležité zjistit, jestli některá vlákna často nesahají do vzdálených paměťových modulů, což zpomaluje odezvu dané paměťové operace.

V~průběhu psaní této práce se nepodařilo dohledat žádný nástroj, který by umožňoval instrumentaci CUDA programů za účelem zaznamenávání paměťových přístupů a~jejich následné vizualizace.
