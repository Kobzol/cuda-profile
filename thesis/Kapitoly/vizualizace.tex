Naměření dat o~běhu aplikace je prvním nutným krokem při profilování, tato data je však také potřeba zobrazit uživateli v~intuitivní podobě. Počet paměťových přístupů provedených programy může běžně dosahovat řádu milionů či miliard. Takto velké množství dat je potřeba zpracovat, umožnit v~něm vyhledávat a~filtrovat a~poskytnout na něj různé typy pohledů. Z~tohoto důvodu byla v~rámci této práce kromě profilovacího nástroje vytvořena také vizualizační aplikace.

\subsection{Specifikace požadavků}
Aplikace by měla umět načítat data ve všech formátech, které profilovací nástroj generuje. Aby se dalo v~naměřených datech snadněji orientovat, měla by umožňovat operace jako je vyhledávání, filtrování a~shlukování. Na data by mělo jít nahlížet více pohledy, hlavní je ale zobrazit adresní prostor aplikace a~umožnit spojit jednotlivé přístupy vláken s~adresou v~paměti. Pomocí této vizualizace by měly jít sledovat vzory přístupů vláken do paměti. Stejně jako u~profilovacího nástroje by měla být vizualizační aplikace jednoduše použitelná.

\subsection{Architektura}
Údaje získané instrumentací jsou vizualizovány pomocí webové aplikace. Tato forma prezentace byla zvolena, protože je nezávislá na operačním systému, nabízí jednoduché rozhraní pro vykreslování vektorové i~rasterové grafiky a~usnadňuje rychlé prototypování. Aplikace je zároveň pojata jako tzv. Single-page application, kde veškerá logika a~směrování probíhá na straně klienta v~prohlížeči. Díky tomu lze web sestavit do statických HTML souborů. Poté k~jeho lokálnímu spuštění ani není potřeba spouštět webový server, stačí aplikaci otevřít v~internetovém prohlížeči. Webové aplikace sice zatím nedosahují stejného výkonu jako nativní aplikace, nicméně pro potřeby vizualizace v~této práci je jejich výkon dostačující.

Aplikace je psána v~jazyce TypeScript~\cite{typescript}. Jedná se o~nádstavbu jazyka JavaScript, který je jediným běžně podporovaným jazykem, který lze provádět přímo v~prohlížeči na straně klienta. TypeScript přidává k~JavaScriptu statický typový systém, což snižuje riziko určitých chyb v~kódu a~zároveň slouží k~jeho dokumentaci. Podporuje také syntaxi nejnovějších ECMAScript standardů\footnote{ECMAScript je standard pro skriptovací jazyky, JavaScript je jednou z~jeho implementací}, které usnadňují vývoj. Překladač TypeScriptu generuje čistý JavaScriptový kód, který je kompatibilní i~se staršími verzemi prohlížečů, jeho použití tedy nijak nesnižuje univerzálnost výsledné aplikace. Nevýhodou TypeScriptu je problématická spolupráce s~knihovnami, které neobsahují typové definice. V~posledních letech však už většina nejčastěji používaných knihoven i~spousta dalších typové definice nabízí a~jejich použití v~TypeScriptu je tedy snadné.

Uživatelské rozhraní aplikace je vytvořeno pomocí knihovny React. Ta umožňuje deklarativně vytvářet komplexní hierarchii uživatelských komponent. Úlohou komponenty je přijmout vlastnosti ($props$) a~na základě nich vykreslit uživatelské rozhraní v~metodě $render$. Z~té lze vrátit deklarativní popis vzhledu ve formě minijazyka JSX\footnote{Pokud je JSX použit s~jazykem TypeScript, tak je označován názvem TSX}, který kombinuje JavaScript se syntaxí inspirovanou XML. To vede k~přehlednějšímu zápisu vzhledu komponenty než při použití textových šablon, které jsou běžné v~jiných knihovnách. Zároveň lze při vytváření vzhledu komponenty využívat veškerých konstrukcí programovacího jazyka, což v~šablonách nejde a~dle autorova názoru je to jedno z~velkých omezení textových šablon. Komponenty Reactu fungují na jednoduchém principu jednoho směru toku dat. Data se předávají z~rodičů potomkům a~události naopak proudí z~potomků rodičům. Pokud chce rodič reagovat na událost vyvolanou v~potomkovi, tak mu předá v~$props$ funkci, kterou potomek při dané události zavolá. Díky této filozofii je jednoduché pochopit, jak proudí data v~aplikaci. Každá komponenta má kromě vlastností i~vnitřní stav, ve kterém si může uchovávat data a~předávat je potomkům. Pokud komponenta nemá vnitřní stav a~její grafická reprezentace závisí čistě na vstupních vlastnostech, je nazývána čistou komponentou a~lze ji reprezentovat jednou funkcí (jinak se komponenty obvykle definují jako třídy).
React pro efektivní vykreslování komponent používá techniku nazvanou Virtual DOM. Ta je umožněna díky tomu, že vzhled komponent je definován deklarativně, metoda render při každém zavolání vrátí reprezentaci kompletního vzhledu komponenty. To se liší od principu často používaného v~jiných aplikacích, kde se běžně prvky uživatelského rozhraní vytvoří pouze jednou a~pak se v~závislosti na událostech mění jejich atributy a~vzhled. Při každé změně stavu komponenty Reactu nebo při vyvolání uživatelské události v~aplikaci dojde ke znovuvykreslení celého stromu komponent. Každá komponenta může překreslení vynechat (například pokud se nezměnily její vstupní vlastnosti). Pokud k~překreslení komponenty dojde, tak jsou JSX výrazy vytvořené její metodou render převedeny na strom JavaScriptových objektů. React porovná tento strom se stromem vytvořeným při minulém překreslení, a~vygeneruje minimální množinu změn, které je nutné provést na výstupním grafickém zařízení pro vykreslení nového stavu. Tímto zařízením může být například DOM\footnote{Strom objektů v~prohlžíeči} v~internetovém prohlížeči nebo strom komponent v~nativní mobilní aplikaci. Pokud jedna komponenta například změní jeden atribut v~HTML tagu své reprezentace, tak React sice provede překreslení celé komponenty, ale pro provedení změny pouze zavolá jednu funkci, která změní v~DOM prohlížeče daný atribut.  Díky této metodě je React velmi efektivní a~zvládne vykreslit tisícovky komponent na stránce. Nejnovější verze Reactu experimentují s~vlastní implementací uživatelských vláken využívajících kooperativního multitaskingu. Díky tomu lze překreslovat strom komponent asynchronně a~prioritizovat důležité události. Ukázku jednoduché React komponenty si lze prohlédnout ve výpisu \ref{code:reactcomponent}.

\begin{listing}
\begin{minted}{javascript}
class Counter extends Component {
    this.state = {
        counter: 0
    };

    render() {
        return (
            <Button
                onClick={this.increaseCounter}>
                text={this.state.counter} />
        );
    }
    increaseCounter = () => {
        this.setState(state => ({
            counter: state.counter + 1
        });
    }
}
\end{minted}
\caption{Ukázka React komponenty}
\label{code:reactcomponent}
\end{listing}

Pro správu stavu aplikace byla zvolena architektura Flux (konkrétně její implementace pomocí knihovny Redux). Flux byl navrhnut firmou Facebook jako řešení pro neustále narůstající komplexitu webových aplikací. Jeho základní myšlenkou je reprezentovat veškerý stav aplikace v~jednom objektu, který se nazývá $store$. Veškeré změny tohoto stavu musí proběhnout pouze vyvoláním předem definovaných akcí. Stav se nesmí měnit přímo, lze ho upravit pouze tak, že se nahradí novým objektem, který může mít některé atributy upravené. Díky tomu lze rychle poznat, které atributy se změnily, protože stačí porovnat adresu objektů a~ne jejich obsah (tzv. shallow compare). Tento princip pochází z~funkcionálního programování, kde obvykle nelze měnit datové struktory přímo, ale lze je pouze nahradit novou verzí (jsou tzv. immutable). Tato architektura je velmi odlišná od objektově orientovaného paradigma, kde je stav aplikace obvykle distribuován mezi velké mnosžtví objektů, jejichž stav se může kdykoliv změnit. To někdy způsobuje velmi obtížně nalezitelné chyby a~může způsobit nekonzistentní stav aplikace. Redux nabízí kompromis. Při jeho použití je nutné striktně dodržovat pravidla neměnného stavu aplikace, což může vyžadovat více kódu než při vytvoření stejné funkcionality pomocí OOP. Pokud ale jsou jeho pravidla dodržena, tak lze pro každou změnu stavu aplikace vysledovat, která akce ji vyvolala. To usnadňuje ladění programu, umožňuje cestování historií stavů programu (tzv. time-travel debugging) a~také usnadňuje reprodukci uživatelských chyb. Pokud se zaznamená sekvence akcí uživatele, tak přehráním této sekvence vývojář může replikovat stav, do kterého se daný uživatel dostal. 
Vytváření nového stavu v~reakci na akci je v~Reduxu prováděno pomocí funkce nazvané $reducer$. Stav aplikace je uložen ve slovníku, kde každý klíč odpovídá jednomu reduceru (lze je i~vnořovat). Když se v~aplikaci vyvolá akce, tak každý reducer v~závislosti na ni buď vrátí původní stav odpovídající jeho klíči, nebo vytvoří stav nový.
Kdyby aplikace uměla pouze vyvolávat akce a~měnit svůj stav, tak by v~mnoha případech nebyla moc užitečná. V~aplikacích je obvykle žádoucí provádět funkce, které mají tzv. vedlejší efekt. Ty se projeví tak, že nemění stav aplikace, ale typicky komunikují s~externím rozhraním. Může jít například o~zápis do souboru nebo o~vyslání síťového požadavku. Pro vytváření vedlejších efektů lze v~Reduxu použít několik přístupů. Ten asi nejjednodušší je vytvořit funkci, která provede vedlejší efekty a~v~závislosti na nich vyvolá požadované akce. Například při provedení síťového požadavku by se nejprve vygenerovala akce značící, že požadavek byl vyslán. Do stavu aplikace by se tak uložila informace o~tom, že požadavek byl vytvořen a~při překreslení by se například mohla objevit informace, že probíhá načítaní dat. Jakmile se požadavek dokončí, tak se opět vyvolá akce značící buď úspěšné nebo neúspěšné dokončení požadavku. Aby se toto obstarávání akcí nemuselo provádět manuálně, tak byla pro vývoj aplikace použita knihovna $redux-observable$, která umožňuje reagovat na proud akcí v~aplikaci a~jednoduše na ně reagovat a~případně vytvářet nové akce. Tato knihovna je založena na reaktivním programovacím paradigmatu (implementovaném knihovnou $RxJs$). To umožňuje snadnou práci s~asynchronními událostmi a~proudy dat, což se hodí právě pro vytváření vedlejších efektů.

Redux je samostatná knihovna, ale velmi často je používána jako datové úložiště pro knihovnu React. Při použití Reduxu je důležitý stav aplikace uložen v~něm, a~při každé změně tohoto stavu dojde k~překreslení stromu React komponent. Ve vnitřním stavu jednotlivých komponent by v~tomto případě neměly být uloženy doménové informace o~stavu aplikace, ale pouze přechodné informace, například vizuální stav komponenty. Toto pravidlo je nicméně někdy nutné porušit z~důvodu optimalizace vykreslování.

JavaScript obsahuje pouze jeden datový typ pro čísla. Vnitřně je reprezentovaný buď jako 32-bitové celé číslo anebo jako 64-bitové číslo s~plovoucí řadovou čárkou ve formátu IEEE 754. Kvůli toho nelze v~JavaScriptu přesně reprezentovat celá čísla mimo rozsah $-(2^{53} - 1)$ až $2^{53} - 1$. To je problémové pro vizualizaci paměťových přístupů, jejichž adresy jsou dnes již obvykle tvořené 64-bitovými čísly. Z~tohoto důvodu jsou pro reprezentaci adres v~aplikaci použita čísla s~neomezenou přesností (pomocí knihovny \texttt{big-integer}).

\subsection{Rozhraní aplikace}
Prvním krokem, který je potřeba v~aplikaci udělat, je načíst soubory vygenerované profilovacím nástrojem. Ty se vytvářejí při každém spuštění profilované aplikace do nové složky, stačí tak obvykle tuto složku otevřít a~načíst všechny soubory v~ní. Pokud ale profilovaný program není spuštěn ze stejné složky, ve které byl přeložen, tak ve vygenerované složce mohou chybět metadata s~ladícími údaji kernelů. V~tom případě je nutné je dohledat a~načíst do aplikace, jinak nebude možné naměřená data vizualizovat. Soubory s~paměťovými přístupy mohou být velké, proto jejich načítání v~aplikaci probíhá pomocí tzv. Web workerů. Jedná se o~rozhraní v~prohlížečích, které dovoluje spouštět JavaScriptový kód izolovaně od hlavního okna aplikace, tento výpočet se poté spouští v~jiném vlákně. Díky tomu lze načíst i~velké soubory do aplikace bez toho, aby se zablokovalo uživatelské rozhraní. Do aplikace lze nahrávat soubory vygenerované ve formátu JSON i~Protobuf, a~to i~ve zkomprimované verzi. Při načtení souborů se provede základní validování jejich obsahu a~k~základnímu zpracování. Jednotlivé paměťové přístupy jsou shluknuty do warpů, protože každý přístup je vždy proveden celým warpem, nemá tak smysl přístupy uchovávat jednotlivě. Shlukování je provedeno na základě klíče, který je tvořen pozicí bloku warpu ve výpočetní mřížce, identifikační číslo warpu a~časového razítka zaznamenaného přístupu. Idenfitikační číslo warpu je vypočteno linearizací jeho pozice ve výpočetní mřízce, tj. namapováním do intervalu od 0 do počtu všech warpů. Po shluknutí jsou warpy seřazeny dle časového razítka. 

Jakmile jsou soubory nahrány, tak se zobrazí časová osa obsahující jednotlivá spuštění kernelů. Z~těch je nutné si zvolit kernel, jehož přístupy budou vizualizovány. V~rámci kernelu jsou zobrazeny jednotlivé paměťové přístupy warpů. Těch může být velmi velké množství, proto je nutné z~nich vyfiltrovat pouze ty warpy, které uživatele zajímají. Filtrovat lze buď podle pozice bloku warpu, podle pozice warpu ve zdrojovém kódu nebo podle typu přístupu. Ukázku zvolených warpů si lze prohlédnout na obrázku \ref{fig:warps}.
Na obrázku jsou dva warpy, každý s~32 vlákny. První warp má pozici ve výpočetní mřížce $0.0.24$ a~provádí zápis 4 bytů do globální paměti. Jednotlivá vlákna warpu jsou reprezentována obdélníky v~mřížce. Zápis provádějí ta vlákna, která jsou obarvená, v~tomto případě všechna. Druhý warp je na pozici $0.0.4$ a~čte 8 bytů ze sdílené paměti. U~tohoto warpu byla aktivní (a~tedy prováděla čtení) pouze polovina vláken. Pro každý warp se dá pomocí tlačítka vybrat všechny přístupy stejného warpu, které v~daném kernelu proběhly.

\InsertFigure{warps}{0.7\textwidth}{Přístupy vláken ve warpu}{fig:warps}

Jakmile si uživatel zvolí požadované warpy, tak si pro ně může vybrat jeden ze tří různých pohledů. Prvním pohledem je tabulka paměťových konfliktů. Pokud zvolené warpy přistoupily ke stejnému úseku paměti, tak se tyto přístupy vypíšou do tabulky. Pro každý přístup je zobrazena rozsah adres, ve kterých ke konfliktu došlo, a~souřadnice vláken, které na danou adresu přistupovaly. Údaje o~kolizích v~paměti jsou vypočteny tak, že se vytvoří mapa paměti na úrovni bytů. Pro každou paměťovou operaci zvolených warpů se do mapy zapíše, ke kterým bytům paměti přistupovala. Na konci jsou pak všechny ovlivněné byty zkontrolovány a~pokud k~nějakému bytu přistoupil více než jeden warp, tak je tato skutečnost nahlášena jako konflikt. Vzhledem k~tomu, že nelze získat přesné informace o~časování přístupu, tak je na uživatelovi, aby tato data správně interpretoval a~vyhodnotil, zda konflikt mohl opravdu nastat.

Další poskytovanou vizualizací je tabulka konfliktů pro moduly sdílené paměti. Tento pohled má smysl pouze pokud je vybraný právě jeden warp, protože konflikty při přístupu do sdílené paměti mohou nastat pouze v~kontextu určitého warpu. Pro každý modul je v~tabulce zobrazen jeden sloupec (modulů je 32, jeden pro každé vlákno ve warpu). V~daném sloupci se zobrazují všechny přístupy do daného modulu v~rámci zvoleného warpu. Pokud tak je v~nějakém sloupci více než jeden řádek, tak to označuje konflikt při přístupu k~modulu sdílené paměti. Paměťový modul použitý pro přístup je dán adresou, ke které se přistupuje. Přiřazení přístupu k~modulu je tak dáno jednoduchým výpočtem. Moduly mají velikost 4 byty, takže se adresa paměti nejprve vydělí hodnotou 4, aby se získal virtuální index modulu. Tento index se poté vydělí hodnotou 32 a~zbytek po tomto dělení udává modul použitý pro daný přístup do sdílené paměti. Velikost modulu může být u~novějších CUDA architektur i~8 bytů. Skutečná velikost modulu je před každým spuštěním kernelu zaznamenána a~vizualizační aplikace při zjišťování konfliktů sdílené paměti tuto hodnotu respektuje. Ukázka konfliktu v~modulech sdílené paměti je na obrázku \ref{fig:bank-conflict}. První čtyři sloupce jsou označeny červeně, protože u~těchto modulů došlo ke konfliktu. Do nultého modulu přistoupila vlákna na pozici $0.0.0$ a~$0.0.16$, do prvního vlákna na pozici $0.0.1$ a~$0.0.17$ atd.

\InsertFigure{bank-conflict}{\textwidth}{Konflikt při přístupu do sdílené paměti}{fig:bank-conflict}

Posledním pohledem na naměřená data je zobrazení mapy paměťového prostoru aplikace. Pro zvolené warpy se zobrazí všechny alokace na grafické karty, které byly v~době vykonávání daného warpu aktivní. U~alokací je zobrazena deklarace proměnn v~jazyce C, do které byla alokace uložena, adresa a~adresní prostor a~umístění ve zdrojovém kódu. Po najetí myši na vlákno warpu se zobrazí blok paměti, ke kterému vlákno přistupovalo. Stejně tak po najetí myši na blok paměti se zvýrazní vlákno, které k~němu přistupovalo. Na vlákno lze kliknout a~trvale zvýraznit jeho paměťový přístup. Zvýrazněné přístupy jsou pojmenované písmenem abecedy. Takto lze procházet jednotlivá vlákna a~sledovat, jak přistupují k~paměti, jestli vlákna blízko u~sebe přistupují k~paměti sekvenčně nebo jestli jsou mezi jejich přístupy mezery. Ukázku paměťové alokace a~zvýrazněných přístupů si lze prohlédnout na obrázku \ref{fig:memory-map}. 

\InsertFigure{memory-map}{\textwidth}{Zobrazení paměťových přístupů v~adresním prostoru}{fig:memory-map}
