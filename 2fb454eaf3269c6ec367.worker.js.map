{"version":3,"sources":["../2fb454eaf3269c6ec367.worker.js","../webpack/bootstrap 2fb454eaf3269c6ec367","../node_modules/debug/src/browser.js","../node_modules/capnp-ts/lib/serialization/pointers/pointer.js","../node_modules/tslib/tslib.es6.js","../node_modules/capnp-ts/lib/serialization/list-element-size.js","../node_modules/capnp-ts/lib/serialization/pointers/list.js","../node_modules/capnp-ts/lib/errors.js","../node_modules/capnp-ts/lib/util.js","../node_modules/capnp-ts/lib/constants.js","../node_modules/capnp-ts/lib/serialization/object-size.js","../node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js","../node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js","../node_modules/capnp-ts/lib/serialization/arena/arena-kind.js","../node_modules/capnp-ts/lib/index.js","../node_modules/capnp-ts/lib/serialization/pointers/index.js","../node_modules/capnp-ts/lib/serialization/pointers/data.js","../node_modules/capnp-ts/lib/serialization/pointers/struct.js","../node_modules/capnp-ts/lib/types/index.js","../node_modules/capnp-ts/lib/serialization/pointers/text.js","../node_modules/capnp-ts/lib/serialization/arena/multi-segment-arena.js","../node_modules/capnp-ts/lib/serialization/arena/arena-allocation-result.js","../node_modules/capnp-ts/lib/serialization/arena/single-segment-arena.js","../node_modules/capnp-ts/lib/serialization/pointers/orphan.js","../node_modules/capnp-ts/lib/serialization/pointers/interface.js","../node_modules/capnp-ts/lib/types/uint64.js","../node_modules/capnp-ts/lib/serialization/pointers/void.js","worker/capnp.worker.ts","capnp/cupr.capnp.ts","../node_modules/capnp-ts/lib/serialization/index.js","../node_modules/capnp-ts/lib/serialization/mask.js","../node_modules/capnp-ts/lib/serialization/message.js","../node_modules/process/browser.js","../node_modules/debug/src/debug.js","../node_modules/ms/index.js","../node_modules/capnp-ts/lib/serialization/arena/index.js","../node_modules/capnp-ts/lib/serialization/arena/arena.js","../node_modules/capnp-ts/lib/serialization/packing.js","../node_modules/capnp-ts/lib/serialization/pointers/any-pointer-list.js","../node_modules/capnp-ts/lib/serialization/pointers/pointer-allocation-result.js","../node_modules/capnp-ts/lib/serialization/pointers/bool-list.js","../node_modules/capnp-ts/lib/serialization/pointers/composite-list.js","../node_modules/capnp-ts/lib/serialization/pointers/data-list.js","../node_modules/capnp-ts/lib/serialization/pointers/float32-list.js","../node_modules/capnp-ts/lib/serialization/pointers/float64-list.js","../node_modules/capnp-ts/lib/serialization/pointers/int8-list.js","../node_modules/capnp-ts/lib/serialization/pointers/int16-list.js","../node_modules/capnp-ts/lib/serialization/pointers/int32-list.js","../node_modules/capnp-ts/lib/serialization/pointers/int64-list.js","../node_modules/capnp-ts/lib/serialization/pointers/interface-list.js","../node_modules/capnp-ts/lib/types/int64.js","../node_modules/capnp-ts/lib/serialization/pointers/text-list.js","../node_modules/capnp-ts/lib/serialization/pointers/uint8-list.js","../node_modules/capnp-ts/lib/serialization/pointers/uint16-list.js","../node_modules/capnp-ts/lib/serialization/pointers/uint32-list.js","../node_modules/capnp-ts/lib/serialization/pointers/uint64-list.js","../node_modules/capnp-ts/lib/serialization/pointers/void-list.js","../node_modules/capnp-ts/lib/serialization/segment.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","process","useColors","window","type","document","documentElement","style","WebkitAppearance","console","firebug","exception","table","navigator","userAgent","toLowerCase","match","parseInt","RegExp","$1","formatArgs","args","this","namespace","humanize","diff","color","splice","index","lastC","replace","log","Function","apply","arguments","save","namespaces","storage","removeItem","debug","e","load","r","NODE_ENV","PUBLIC_URL","DEBUG","chrome","local","localStorage","colors","formatters","j","v","JSON","stringify","err","message","enable","adopt","src","_moveTo","disown","orphan_1","Orphan","dump","util_1","bufferToHex","segment","buffer","slice","byteOffset","getListByteLength","elementSize","length","compositeSize","list_element_size_1","ListElementSize","BIT","padToWord","BYTE","BYTE_2","BYTE_4","BYTE_8","POINTER","VOID","getListElementByteLength","COMPOSITE","undefined","Error","format","errors_1","PTR_INVALID_LIST_SIZE","NaN","object_size_1","getByteLength","add","offset","Pointer","_capnp","depthLimit","copyFrom","trace","erase","isNull","getTargetPointerType","pointer_type_1","PointerType","STRUCT","copyFromStruct","LIST","copyFromList","PTR_INVALID_POINTER_TYPE","size","getTargetStructSize","getContent","fillZeroWords","dataByteLength","pointerLength","getTargetListElementSize","getTargetListLength","contentWords","tag","getStructSize","compositeByteLength","getOffsetWords","setWordZero","OTHER","erasePointer","getPointerType","FAR","landingPad","followFar","isDoubleFar","targetSegment","getSegment","getUint32","targetWordOffset","followFars","getCapabilityId","isCompositeList","ignoreCompositeIndex","getFarSegmentId","target","compositeIndex","getListElementSize","constants_1","LIST_SIZE_MASK","getListLength","getInt32","POINTER_TYPE_MASK","getStructDataWords","getUint16","getStructPointerLength","ObjectSize","getTargetCompositeListTag","getTargetCompositeListSize","t","PTR_INVALID_FAR_TARGET","initPointer","contentSegment","contentOffset","hasCapacity","landingPad_1","allocate","setFarPointer","id","pointer_allocation_result_1","PointerAllocationResult","INVARIANT_UNREACHABLE_CODE","POINTER_DOUBLE_FAR_MASK","isWordZero","relocateTo","dst","lo","getUint8","hi","res","pointer","setUint32","offsetWords","doubleFar","segmentId","A","B","C","D","setInterfacePointer","capId","setListPointer","TypeError","TYPE_COMPOSITE_SIZE_UNDEFINED","getWordLength","setStructPointer","getDataWordLength","setUint16","validate","pointerType","PTR_WRONG_POINTER_TYPE","PTR_WRONG_LIST_TYPE","PTR_DEPTH_LIMIT_EXCEEDED","srcCompositeSize","srcStructByteLength","dstContent","srcContent","srcElementSize","srcLength","srcPtr","dstPtr","copyWord","wordLength","copyWords","byteLength","srcSize","srcDataWordLength","compositeList","trackPointerAllocation","traversalLimit","PTR_TRAVERSAL_LIMIT_EXCEEDED","value","debug_1","default","MAX_DEPTH","PTR_OFFSET_OUT_OF_BOUNDS","toString","displayName","__webpack_exports__","__extends","b","__","constructor","extendStatics","create","__rest","indexOf","getOwnPropertySymbols","__decorate","decorators","key","desc","getOwnPropertyDescriptor","Reflect","decorate","__param","paramIndex","decorator","__metadata","metadataKey","metadataValue","metadata","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","throw","result","done","then","__generator","body","verb","op","f","_","y","label","ops","pop","trys","push","g","sent","return","Symbol","iterator","__exportStar","__values","__read","ar","error","__spread","concat","__await","__asyncGenerator","a","q","resume","settle","fulfill","shift","asyncIterator","__asyncDelegator","__asyncValues","__assign","setPrototypeOf","__proto__","Array","assign","ListElementOffset","initList","Math","ceil","pointer_1","PTR_COMPOSITE_SIZE_UNDEFINED","tslib_1","List","_super","all","callbackfn","getLength","any","ap","callbackfns","_this","map","other","otherLength","drop","dropWhile","empty","every","filter","find","forEach","_index","groupBy","intersperse","sep","reduce","initialValue","set","_value","start","end","min","some","take","takeWhile","toArray","identity","assertNever","MSG_INVALID_FRAME_HEADER","MSG_NO_SEGMENTS_IN_ARENA","MSG_PACK_NOT_WORD_ALIGNED","MSG_SEGMENT_OUT_OF_BOUNDS","MSG_SEGMENT_TOO_SMALL","NOT_IMPLEMENTED","PTR_ADOPT_COMPOSITE_STRUCT","PTR_ADOPT_WRONG_MESSAGE","PTR_ALREADY_ADOPTED","PTR_DISOWN_COMPOSITE_STRUCT","PTR_INIT_COMPOSITE_STRUCT","PTR_INIT_NON_GROUP","PTR_INVALID_UNION_ACCESS","PTR_STRUCT_DATA_OUT_OF_BOUNDS","PTR_STRUCT_POINTER_OUT_OF_BOUNDS","PTR_WRONG_COMPOSITE_DATA_SIZE","PTR_WRONG_COMPOSITE_PTR_SIZE","PTR_WRONG_STRUCT_DATA_SIZE","PTR_WRONG_STRUCT_PTR_SIZE","RANGE_INT32_OVERFLOW","RANGE_INT64_UNDERFLOW","RANGE_INVALID_UTF8","RANGE_SIZE_OVERFLOW","MAX_SEGMENT_LENGTH","RANGE_UINT32_OVERFLOW","SEG_BUFFER_NOT_ALLOCATED","SEG_GET_NON_ZERO_SINGLE","SEG_ID_OUT_OF_BOUNDS","SEG_NOT_WORD_ALIGNED","SEG_REPLACEMENT_BUFFER_TOO_SMALL","SEG_SIZE_OVERFLOW","TYPE_GET_GENERIC_LIST","TYPE_SET_GENERIC_LIST","Uint8Array","h","pad","join","checkInt32","MAX_INT32","RangeError","checkUint32","MAX_UINT32","decodeUtf8","cp","String","fromCharCode","dumpBuffer","ArrayBuffer","MAX_BUFFER_DUMP_BYTES","k","repeat","encodeUtf8","charCodeAt","subarray","nextArg","argIndex","_i","arg","precision","escaped","leadingZero","digits","test","tmp","parseFloat","toFixed","toUpperCase","x","width","times","str","out","Number","MAX_VALUE","floor","tmpWord","DataView","Uint16Array","DEFAULT_BUFFER_SIZE","DEFAULT_DECODE_LIMIT","DEFAULT_DEPTH_LIMIT","DEFAULT_TRAVERSE_LIMIT","GROWTH_FACTOR","MAX_SAFE_INTEGER","MAX_STREAM_SEGMENTS","MIN_SAFE_INTEGER","MIN_SINGLE_SEGMENT_GROWTH","NATIVE_LITTLE_ENDIAN","PACK_SPAN_THRESHOLD","POINTER_COPY_LIMIT","VAL32","pointerCount","PointerList","PointerClass","_a","class_1","list_1","ArenaKind","serialization_1","Message","AnyPointerList","BoolList","CompositeList","Data","DataList","Float32List","Float64List","Int16List","Int32List","Int64List","Int8List","Interface","InterfaceList","Struct","Text","TextList","Uint16List","Uint32List","Uint64List","Uint8List","VoidList","Void","getBitMask","getFloat32Mask","getFloat64Mask","getInt16Mask","getInt32Mask","getInt64Mask","getInt8Mask","getUint16Mask","getUint32Mask","getUint64Mask","getUint8Mask","types_1","Int64","Uint64","any_pointer_list_1","bool_list_1","composite_list_1","data_1","data_list_1","float32_list_1","float64_list_1","int8_list_1","int16_list_1","int32_list_1","int64_list_1","interface_1","interface_list_1","pointer_list_1","struct_1","text_1","text_list_1","uint8_list_1","uint16_list_1","uint32_list_1","uint64_list_1","void_1","void_list_1","fromPointer","_fromPointerUnchecked","copyBuffer","dstLength","fill","setUint8","toArrayBuffer","toDataView","toUint8Array","initStruct","initStructAt","StructClass","getPointerAs","resize","dstSize","getSize","srcPtrTarget","srcPtrContent","getAs","getBit","bitOffset","defaultMask","bitMask","checkDataBounds","ds","getDataSection","getData","checkPointerBounds","ps","getPointerSection","getFloat32","TMP_WORD","getFloat64","getInt16","getInt64","getInt8","getList","ListClass","srcElementOffset","dstElementOffset","getPointer","getStruct","ts","getText","getUint64","initData","setBit","setFloat32","setFloat64","setInt16","setInt32","setInt64","setInt8","setPointer","setText","setUint64","testWhich","found","wanted","int64_1","uint64_1","textFromPointerUnchecked","original","originalLength","minSize","max","buffers","arena_allocation_result_1","ArenaAllocationResult","getBuffer","getNumSegments","arena_kind_1","MultiSegmentArena","kind","MULTI_SEGMENT","segments","srcBuffer","Float64Array","SingleSegmentArena","SINGLE_SEGMENT","dispose","fromArrayBuffer","source","noCopy","fromDataView","fromHexString","substr","fromNumber","bytes","buf","ret","setValue","fromUint8Array","equals","inspect","toHexString","isZero","loWord","hiWord","abs","toNumber","allowImprecise","Infinity","valueOf","hex","radix","parseDim3","dim","getX","getY","z","getZ","__WEBPACK_IMPORTED_MODULE_0__capnp_cupr_capnp__","__WEBPACK_IMPORTED_MODULE_1_capnp_ts__","ctx","self","onmessage","payload","data","getRoot","parsed","getType","kernel","getKernel","getStart","getEnd","warps","getWarps","warp","accesses","getAccesses","access","threadIdx","getThreadIdx","address","getAddress","getValue","blockIdx","getBlockIdx","warpId","getWarpId","debugId","getDebugId","getKind","space","getSpace","typeIndex","getTypeIndex","timestamp","getTimestamp","allocations","getAllocations","alloc","getElementSize","typeString","getTypeString","active","getActive","nameIndex","getNameIndex","nameString","getNameString","location","getLocation","gridDim","getGridDim","blockDim","getBlockDim","warpSize","getWarpSize","bankSize","getBankSize","postMessage","Trace","__WEBPACK_IMPORTED_MODULE_0_capnp_ts__","Dim3","setX","setY","setZ","MemoryAccess","adoptThreadIdx","disownThreadIdx","hasThreadIdx","initThreadIdx","setThreadIdx","setAddress","Warp","adoptAccesses","disownAccesses","_Accesses","hasAccesses","initAccesses","setAccesses","adoptBlockIdx","disownBlockIdx","hasBlockIdx","initBlockIdx","setBlockIdx","setWarpId","setDebugId","setSize","setKind","setSpace","setTypeIndex","setTimestamp","AllocRecord","setElementSize","setTypeString","setNameIndex","setNameString","setLocation","setActive","adoptWarps","disownWarps","_Warps","hasWarps","initWarps","setWarps","adoptAllocations","disownAllocations","_Allocations","hasAllocations","initAllocations","setAllocations","setKernel","setStart","setEnd","setType","adoptGridDim","disownGridDim","hasGridDim","initGridDim","setGridDim","adoptBlockDim","disownBlockDim","hasBlockDim","initBlockDim","setBlockDim","setWarpSize","setBankSize","message_1","_makePrimitiveMaskFn","setter","dv","initMessage","packed","singleSegment","arena","arena_1","isAnyArena","isArrayBufferView","packing_1","unpack","getFramedSegments","segmentCount","preallocateSegments","numSegments","Arena","segment_1","Segment","allocateSegment","replaceBuffer","RootStruct","root","pointers_1","segmentLength","initRoot","streamFrame","getStreamFrame","totalLength","toPackedArrayBuffer","pack","frameLength","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","array","noop","nextTick","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","selectColor","hash","createDebug","enabled","curr","Date","ms","prevTime","prev","coerce","unshift","formatter","val","bind","init","names","skips","split","disable","stack","parse","exec","fmtShort","round","fmtLong","plural","options","isNaN","long","multi_segment_arena_1","single_segment_arena_1","getHammingWeight","w","getTagByte","getUnpackedByteLength","lastTag","getZeroByteCount","unpacked","spanTagOffset","spanWordLength","spanThreshold","srcByteOffset","skipWriteWord","dstByteOffset","spanByteLength","CompositeClass","neg","negate","carry","toStringTag","_dv","srcSegment","getCapacity"],"mappings":"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","file":"2fb454eaf3269c6ec367.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/cuda-profile/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 25);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(31);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = Object({\"NODE_ENV\":\"production\",\"PUBLIC_URL\":\"/cuda-profile\"}).DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar util_1 = __webpack_require__(6);\nvar list_element_size_1 = __webpack_require__(3);\nvar object_size_1 = __webpack_require__(8);\nvar orphan_1 = __webpack_require__(21);\nvar pointer_allocation_result_1 = __webpack_require__(37);\nvar pointer_type_1 = __webpack_require__(9);\nvar errors_1 = __webpack_require__(5);\nvar trace = debug_1.default('capnp:pointer');\ntrace('load');\n/**\n * A pointer referencing a single byte location in a segment. This is typically used for Cap'n Proto pointers, but is\n * also sometimes used to reference an offset to a pointer's content or tag words.\n *\n * @export\n * @class Pointer\n */\nvar Pointer = /** @class */ (function () {\n    function Pointer(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        if (depthLimit === 0)\n            throw new Error(util_1.format(errors_1.PTR_DEPTH_LIMIT_EXCEEDED, this));\n        // Make sure we keep track of all pointer allocations; there's a limit per message (prevent DoS).\n        trackPointerAllocation(segment.message, this);\n        // NOTE: It's okay to have a pointer to the end of the segment; you'll see this when creating pointers to the\n        // beginning of the content of a newly-allocated composite list with zero elements. Unlike other language\n        // implementations buffer over/underflows are not a big issue since all buffer access is bounds checked in native\n        // code anyway.\n        if (byteOffset < 0 || byteOffset > segment.byteLength) {\n            throw new Error(util_1.format(errors_1.PTR_OFFSET_OUT_OF_BOUNDS, byteOffset));\n        }\n        this._capnp = { compositeList: false, depthLimit: depthLimit };\n        this.segment = segment;\n        this.byteOffset = byteOffset;\n        trace('new %s', this);\n    }\n    Pointer.prototype.toString = function () {\n        return util_1.format('Pointer_%d@%a,%s,limit:%x', this.segment.id, this.byteOffset, dump(this), this._capnp.depthLimit);\n    };\n    Pointer.adopt = adopt;\n    Pointer.copyFrom = copyFrom;\n    Pointer.disown = disown;\n    Pointer.dump = dump;\n    Pointer.isNull = isNull;\n    Pointer._capnp = {\n        displayName: 'Pointer',\n    };\n    return Pointer;\n}());\nexports.Pointer = Pointer;\n/**\n * Adopt an orphaned pointer, making the pointer point to the orphaned content without copying it.\n *\n * @param {Orphan<Pointer>} src The orphan to adopt.\n * @param {Pointer} p The the pointer to adopt into.\n * @returns {void}\n */\nfunction adopt(src, p) {\n    src._moveTo(p);\n}\nexports.adopt = adopt;\n/**\n * Convert a pointer to an Orphan, zeroing out the pointer and leaving its content untouched. If the content is no\n * longer needed, call `disown()` on the orphaned pointer to erase the contents as well.\n *\n * Call `adopt()` on the orphan with the new target pointer location to move it back into the message; the orphan\n * object is then invalidated after adoption (can only adopt once!).\n *\n * @param {T} p The pointer to turn into an Orphan.\n * @returns {Orphan<T>} An orphaned pointer.\n */\nfunction disown(p) {\n    return new orphan_1.Orphan(p);\n}\nexports.disown = disown;\nfunction dump(p) {\n    return util_1.bufferToHex(p.segment.buffer.slice(p.byteOffset, p.byteOffset + 8));\n}\nexports.dump = dump;\n/**\n * Get the total number of bytes required to hold a list of the provided size with the given length, rounded up to the\n * nearest word.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @param {number} length The length of the list.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list; required if\n * `elementSize === ListElementSize.COMPOSITE`.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListByteLength(elementSize, length, compositeSize) {\n    switch (elementSize) {\n        case list_element_size_1.ListElementSize.BIT:\n            return util_1.padToWord(length + 7 >>> 3);\n        case list_element_size_1.ListElementSize.BYTE:\n        case list_element_size_1.ListElementSize.BYTE_2:\n        case list_element_size_1.ListElementSize.BYTE_4:\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n        case list_element_size_1.ListElementSize.VOID:\n            return util_1.padToWord(getListElementByteLength(elementSize) * length);\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            if (compositeSize === undefined)\n                throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, NaN));\n            return length * util_1.padToWord(object_size_1.getByteLength(compositeSize));\n        /* istanbul ignore next */\n        default:\n            throw new Error(errors_1.PTR_INVALID_LIST_SIZE);\n    }\n}\nexports.getListByteLength = getListByteLength;\n/**\n * Get the number of bytes required to hold a list element of the provided size. `COMPOSITE` elements do not have a\n * fixed size, and `BIT` elements are packed into exactly a single bit, so these both return `NaN`.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListElementByteLength(elementSize) {\n    switch (elementSize) {\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.BIT:\n            return NaN;\n        case list_element_size_1.ListElementSize.BYTE:\n            return 1;\n        case list_element_size_1.ListElementSize.BYTE_2:\n            return 2;\n        case list_element_size_1.ListElementSize.BYTE_4:\n            return 4;\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n            return 8;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            // Caller has to figure it out based on the tag word.\n            return NaN;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.VOID:\n            return 0;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n    }\n}\nexports.getListElementByteLength = getListElementByteLength;\n/**\n * Add an offset to the pointer's offset and return a new Pointer for that address.\n *\n * @param {number} offset The number of bytes to add to the offset.\n * @param {Pointer} p The pointer to add from.\n * @returns {Pointer} A new pointer to the address.\n */\nfunction add(offset, p) {\n    return new Pointer(p.segment, p.byteOffset + offset, p._capnp.depthLimit);\n}\nexports.add = add;\n/**\n * Replace a pointer with a deep copy of the pointer at `src` and all of its contents.\n *\n * @param {Pointer} src The pointer to copy.\n * @param {Pointer} p The pointer to copy into.\n * @returns {void}\n */\nfunction copyFrom(src, p) {\n    // If the pointer is the same then this is a noop.\n    if (p.segment === src.segment && p.byteOffset === src.byteOffset) {\n        trace('ignoring copy operation from identical pointer %s', src);\n        return;\n    }\n    // Make sure we erase this pointer's contents before moving on. If src is null, that's all we do.\n    erase(p); // noop if null\n    if (isNull(src))\n        return;\n    switch (getTargetPointerType(src)) {\n        case pointer_type_1.PointerType.STRUCT:\n            copyFromStruct(src, p);\n            break;\n        case pointer_type_1.PointerType.LIST:\n            copyFromList(src, p);\n            break;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n}\nexports.copyFrom = copyFrom;\n/**\n * Recursively erase a pointer, any far pointers/landing pads/tag words, and the content it points to.\n *\n * Note that this will leave \"holes\" of zeroes in the message, since the space cannot be reclaimed. With packing this\n * will have a negligible effect on the final message size.\n *\n * FIXME: This may need protection against infinite recursion...\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erase(p) {\n    if (isNull(p))\n        return;\n    // First deal with the contents.\n    var c;\n    switch (getTargetPointerType(p)) {\n        case pointer_type_1.PointerType.STRUCT:\n            var size = getTargetStructSize(p);\n            c = getContent(p);\n            // Wipe the data section.\n            c.segment.fillZeroWords(c.byteOffset, size.dataByteLength / 8);\n            // Iterate over all the pointers and nuke them.\n            for (var i = 0; i < size.pointerLength; i++) {\n                erase(add(i * 8, c));\n            }\n            break;\n        case pointer_type_1.PointerType.LIST:\n            var elementSize = getTargetListElementSize(p);\n            var length = getTargetListLength(p);\n            var contentWords = util_1.padToWord(length * getListElementByteLength(elementSize));\n            c = getContent(p);\n            if (elementSize === list_element_size_1.ListElementSize.POINTER) {\n                for (var i = 0; i < length; i++) {\n                    erase(new Pointer(c.segment, c.byteOffset + i * 8, p._capnp.depthLimit - 1));\n                }\n                // Calling erase on each pointer takes care of the content, nothing left to do here.\n                break;\n            }\n            else if (elementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n                // Read some stuff from the tag word.\n                var tag = add(-8, c);\n                var compositeSize = getStructSize(tag);\n                var compositeByteLength = object_size_1.getByteLength(compositeSize);\n                contentWords = getOffsetWords(tag);\n                // Kill the tag word.\n                c.segment.setWordZero(c.byteOffset - 8);\n                // Recursively erase each pointer.\n                for (var i = 0; i < length; i++) {\n                    for (var j = 0; j < compositeSize.pointerLength; j++) {\n                        erase(new Pointer(c.segment, c.byteOffset + i * compositeByteLength + j * 8, p._capnp.depthLimit - 1));\n                    }\n                }\n            }\n            c.segment.fillZeroWords(c.byteOffset, contentWords);\n            break;\n        case pointer_type_1.PointerType.OTHER:\n            // No content.\n            break;\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n    erasePointer(p);\n}\nexports.erase = erase;\n/**\n * Set the pointer (and far pointer landing pads, if applicable) to zero. Does not touch the pointer's content.\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erasePointer(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p)) {\n            // Kill the double-far tag word.\n            landingPad.segment.setWordZero(landingPad.byteOffset + 8);\n        }\n        // Kill the landing pad.\n        landingPad.segment.setWordZero(landingPad.byteOffset);\n    }\n    // Finally! Kill the pointer itself...\n    p.segment.setWordZero(p.byteOffset);\n}\nexports.erasePointer = erasePointer;\n/**\n * Interpret the pointer as a far pointer, returning its target segment and offset.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the far target.\n */\nfunction followFar(p) {\n    var targetSegment = p.segment.message.getSegment(p.segment.getUint32(p.byteOffset + 4));\n    var targetWordOffset = p.segment.getUint32(p.byteOffset) >>> 3;\n    return new Pointer(targetSegment, targetWordOffset * 8, p._capnp.depthLimit - 1);\n}\nexports.followFar = followFar;\n/**\n * If the pointer address references a far pointer, follow it to the location where the actual pointer data is written.\n * Otherwise, returns the pointer unmodified.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A new pointer representing the target location, or `p` if it is not a far pointer.\n */\nfunction followFars(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p))\n            landingPad.byteOffset += 8;\n        return landingPad;\n    }\n    return p;\n}\nexports.followFars = followFars;\nfunction getCapabilityId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getCapabilityId = getCapabilityId;\nfunction isCompositeList(p) {\n    return getTargetPointerType(p) === pointer_type_1.PointerType.LIST && getTargetListElementSize(p) === list_element_size_1.ListElementSize.COMPOSITE;\n}\n/**\n * Obtain the location of the pointer's content, following far pointers as needed.\n * If the pointer is a struct pointer and `compositeIndex` is set, it will be offset by a multiple of the struct's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @param {boolean} [ignoreCompositeIndex] If true, will not follow the composite struct pointer's composite index and\n * instead return a pointer to the parent list's contents (also the beginning of the first struct).\n * @returns {Pointer} A pointer to the beginning of the pointer's content.\n */\nfunction getContent(p, ignoreCompositeIndex) {\n    var c;\n    if (isDoubleFar(p)) {\n        var landingPad = followFar(p);\n        c = new Pointer(p.segment.message.getSegment(getFarSegmentId(landingPad)), getOffsetWords(landingPad) * 8);\n    }\n    else {\n        var target = followFars(p);\n        c = new Pointer(target.segment, target.byteOffset + 8 + getOffsetWords(target) * 8);\n    }\n    if (isCompositeList(p))\n        c.byteOffset += 8;\n    if (!ignoreCompositeIndex && p._capnp.compositeIndex !== undefined) {\n        // Seek backwards by one word so we can read the struct size off the tag word.\n        c.byteOffset -= 8;\n        // Seek ahead by `compositeIndex` multiples of the struct's total size.\n        c.byteOffset += 8 + p._capnp.compositeIndex * object_size_1.getByteLength(object_size_1.padToWord(getStructSize(c)));\n    }\n    return c;\n}\nexports.getContent = getContent;\n/**\n * Read the target segment ID from a far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The target segment ID.\n */\nfunction getFarSegmentId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getFarSegmentId = getFarSegmentId;\n/**\n * Get a number indicating the size of the list's elements.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the list's elements.\n */\nfunction getListElementSize(p) {\n    return p.segment.getUint32(p.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n}\nexports.getListElementSize = getListElementSize;\n/**\n * Get the number of elements in a list pointer. For composite lists, it instead represents the total number of words in\n * the list (not counting the tag word).\n *\n * This method does **not** attempt to distinguish between composite and non-composite lists. To get the correct\n * length for composite lists use `getTargetListLength()` instead.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The length of the list, or total number of words for composite lists.\n */\nfunction getListLength(p) {\n    return p.segment.getUint32(p.byteOffset + 4) >>> 3;\n}\nexports.getListLength = getListLength;\n/**\n * Get the offset (in words) from the end of a pointer to the start of its content. For struct pointers, this is the\n * beginning of the data section, and for list pointers it is the location of the first element. The value should\n * always be zero for interface pointers.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The offset, in words, from the end of the pointer to the start of the data section.\n */\nfunction getOffsetWords(p) {\n    var o = p.segment.getInt32(p.byteOffset);\n    // Far pointers only have 29 offset bits.\n    return o & 2 ? o >> 3 : o >> 2;\n}\nexports.getOffsetWords = getOffsetWords;\n/**\n * Look up the pointer's type.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer.\n */\nfunction getPointerType(p) {\n    return p.segment.getUint32(p.byteOffset) & constants_1.POINTER_TYPE_MASK;\n}\nexports.getPointerType = getPointerType;\n/**\n * Read the number of data words from this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of data words in the struct.\n */\nfunction getStructDataWords(p) {\n    return p.segment.getUint16(p.byteOffset + 4);\n}\nexports.getStructDataWords = getStructDataWords;\n/**\n * Read the number of pointers contained in this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of pointers in this struct.\n */\nfunction getStructPointerLength(p) {\n    return p.segment.getUint16(p.byteOffset + 6);\n}\nexports.getStructPointerLength = getStructPointerLength;\n/**\n * Get an object describing this struct pointer's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} The size of the struct.\n */\nfunction getStructSize(p) {\n    return new object_size_1.ObjectSize(getStructDataWords(p) * 8, getStructPointerLength(p));\n}\nexports.getStructSize = getStructSize;\n/**\n * Get a pointer to this pointer's composite list tag word, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the list's composite tag word.\n */\nfunction getTargetCompositeListTag(p) {\n    var c = getContent(p);\n    // The composite list tag is always one word before the content.\n    c.byteOffset -= 8;\n    return c;\n}\nexports.getTargetCompositeListTag = getTargetCompositeListTag;\n/**\n * Get the object size for the target composite list, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} An object describing the size of each struct in the list.\n */\nfunction getTargetCompositeListSize(p) {\n    return getStructSize(getTargetCompositeListTag(p));\n}\nexports.getTargetCompositeListSize = getTargetCompositeListSize;\n/**\n * Get the size of the list elements referenced by this pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the elements in the list.\n */\nfunction getTargetListElementSize(p) {\n    return getListElementSize(followFars(p));\n}\nexports.getTargetListElementSize = getTargetListElementSize;\n/**\n * Get the length of the list referenced by this pointer, following far pointers if necessary. If the list is a\n * composite list, it will look up the tag word and read the length from there.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of elements in the list.\n */\nfunction getTargetListLength(p) {\n    var t = followFars(p);\n    if (getListElementSize(t) === list_element_size_1.ListElementSize.COMPOSITE) {\n        // The content is prefixed by a tag word; it's a struct pointer whose offset contains the list's length.\n        return getOffsetWords(getTargetCompositeListTag(p));\n    }\n    return getListLength(t);\n}\nexports.getTargetListLength = getTargetListLength;\n/**\n * Get the type of a pointer, following far pointers if necessary. For non-far pointers this is equivalent to calling\n * `getPointerType()`.\n *\n * The target of a far pointer can never be another far pointer, and this method will throw if such a situation is\n * encountered.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer referenced by this pointer.\n */\nfunction getTargetPointerType(p) {\n    var t = getPointerType(followFars(p));\n    if (t === pointer_type_1.PointerType.FAR)\n        throw new Error(util_1.format(errors_1.PTR_INVALID_FAR_TARGET, p));\n    return t;\n}\nexports.getTargetPointerType = getTargetPointerType;\n/**\n * Get the size of the struct referenced by a pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The poiner to read from.\n * @returns {ObjectSize} The size of the struct referenced by this pointer.\n */\nfunction getTargetStructSize(p) {\n    return getStructSize(followFars(p));\n}\nexports.getTargetStructSize = getTargetStructSize;\n/**\n * Initialize a pointer to point at the data in the content segment. If the content segment is not the same as the\n * pointer's segment, this will allocate and write far pointers as needed. Nothing is written otherwise.\n *\n * The return value includes a pointer to write the pointer's actual data to (the eventual far target), and the offset\n * value (in words) to use for that pointer. In the case of double-far pointers this offset will always be zero.\n *\n * @param {Segment} contentSegment The segment containing this pointer's content.\n * @param {number} contentOffset The offset within the content segment for the beginning of this pointer's content.\n * @param {Pointer} p The pointer to initialize.\n * @returns {PointerAllocationResult} An object containing a pointer (where the pointer data should be written), and\n * the value to use as the offset for that pointer.\n */\nfunction initPointer(contentSegment, contentOffset, p) {\n    if (p.segment !== contentSegment) {\n        // Need a far pointer.\n        trace('Initializing far pointer %s -> %s.', p, contentSegment);\n        if (!contentSegment.hasCapacity(8)) {\n            // GAH! Not enough space in the content segment for a landing pad so we need a double far pointer.\n            var landingPad_1 = p.segment.allocate(16);\n            trace('GAH! Initializing double-far pointer in %s from %s -> %s.', p, contentSegment, landingPad_1);\n            setFarPointer(true, landingPad_1.byteOffset / 8, landingPad_1.segment.id, p);\n            setFarPointer(false, contentOffset / 8, contentSegment.id, landingPad_1);\n            landingPad_1.byteOffset += 8;\n            return new pointer_allocation_result_1.PointerAllocationResult(landingPad_1, 0);\n        }\n        // Allocate a far pointer landing pad in the target segment.\n        var landingPad = contentSegment.allocate(8);\n        if (landingPad.segment.id !== contentSegment.id) {\n            throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n        }\n        setFarPointer(false, landingPad.byteOffset / 8, landingPad.segment.id, p);\n        return new pointer_allocation_result_1.PointerAllocationResult(landingPad, (contentOffset - landingPad.byteOffset - 8) / 8);\n    }\n    trace('Initializing intra-segment pointer %s -> %a.', p, contentOffset);\n    return new pointer_allocation_result_1.PointerAllocationResult(p, (contentOffset - p.byteOffset - 8) / 8);\n}\nexports.initPointer = initPointer;\n/**\n * Check if the pointer is a double-far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if it is a double-far pointer, `false` otherwise.\n */\nfunction isDoubleFar(p) {\n    return getPointerType(p) === pointer_type_1.PointerType.FAR && (p.segment.getUint32(p.byteOffset) & constants_1.POINTER_DOUBLE_FAR_MASK) !== 0;\n}\nexports.isDoubleFar = isDoubleFar;\n/**\n * Quickly check to see if the pointer is \"null\". A \"null\" pointer is a zero word, equivalent to an empty struct\n * pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if the pointer is \"null\".\n */\nfunction isNull(p) {\n    return p.segment.isWordZero(p.byteOffset);\n}\nexports.isNull = isNull;\n/**\n * Relocate a pointer to the given destination, ensuring that it points to the same content. This will create far\n * pointers as needed if the content is in a different segment than the destination. After the relocation the source\n * pointer will be erased and is no longer valid.\n *\n * @param {Pointer} dst The desired location for the `src` pointer. Any existing contents will be erased before\n * relocating!\n * @param {Pointer} src The pointer to relocate.\n * @returns {void}\n */\nfunction relocateTo(dst, src) {\n    var t = followFars(src);\n    var lo = t.segment.getUint8(t.byteOffset) & 0x03; // discard the offset\n    var hi = t.segment.getUint32(t.byteOffset + 4);\n    // Make sure anything dst was pointing to is wiped out.\n    erase(dst);\n    var res = initPointer(t.segment, t.byteOffset + 8 + getOffsetWords(t) * 8, dst);\n    // Keep the low 2 bits and write the new offset.\n    res.pointer.segment.setUint32(res.pointer.byteOffset, lo | (res.offsetWords << 2));\n    // Keep the high 32 bits intact.\n    res.pointer.segment.setUint32(res.pointer.byteOffset + 4, hi);\n    erasePointer(src);\n}\nexports.relocateTo = relocateTo;\n/**\n * Write a far pointer.\n *\n * @param {boolean} doubleFar Set to `true` if this is a double far pointer.\n * @param {number} offsetWords The offset, in words, to the target pointer.\n * @param {number} segmentId The segment the target pointer is located in.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setFarPointer(doubleFar, offsetWords, segmentId, p) {\n    var A = pointer_type_1.PointerType.FAR;\n    var B = doubleFar ? 1 : 0;\n    var C = offsetWords;\n    var D = segmentId;\n    p.segment.setUint32(p.byteOffset, A | B << 2 | C << 3);\n    p.segment.setUint32(p.byteOffset + 4, D);\n}\nexports.setFarPointer = setFarPointer;\n/**\n * Write a raw interface pointer.\n *\n * @param {number} capId The capability ID.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setInterfacePointer(capId, p) {\n    p.segment.setUint32(p.byteOffset, pointer_type_1.PointerType.OTHER);\n    p.segment.setUint32(p.byteOffset + 4, capId);\n}\nexports.setInterfacePointer = setInterfacePointer;\n/**\n * Write a raw list pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the list content.\n * @param {ListElementSize} size The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {Pointer} p The pointer to write to.\n * @param {ObjectSize} [compositeSize] For composite lists this describes the size of each element in this list. This\n * is required for composite lists.\n * @returns {void}\n */\nfunction setListPointer(offsetWords, size, length, p, compositeSize) {\n    if (p === undefined)\n        throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n    var A = pointer_type_1.PointerType.LIST;\n    var B = offsetWords;\n    var C = size;\n    var D = length;\n    if (size === list_element_size_1.ListElementSize.COMPOSITE) {\n        if (compositeSize === undefined)\n            throw new TypeError(errors_1.TYPE_COMPOSITE_SIZE_UNDEFINED);\n        D *= object_size_1.getWordLength(compositeSize);\n    }\n    p.segment.setUint32(p.byteOffset, A | B << 2);\n    p.segment.setUint32(p.byteOffset + 4, C | D << 3);\n}\nexports.setListPointer = setListPointer;\n/**\n * Write a raw struct pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the struct's data\n * section.\n * @param {ObjectSize} size An object describing the size of the struct.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setStructPointer(offsetWords, size, p) {\n    var A = pointer_type_1.PointerType.STRUCT;\n    var B = offsetWords;\n    var C = object_size_1.getDataWordLength(size);\n    var D = size.pointerLength;\n    p.segment.setUint32(p.byteOffset, A | B << 2);\n    p.segment.setUint16(p.byteOffset + 4, C);\n    p.segment.setUint16(p.byteOffset + 6, D);\n}\nexports.setStructPointer = setStructPointer;\n/**\n * Read some bits off a pointer to make sure it has the right pointer data.\n *\n * @param {PointerType} pointerType The expected pointer type.\n * @param {Pointer} p The pointer to validate.\n * @param {ListElementSize} [elementSize] For list pointers, the expected element size. Leave this\n * undefined for struct pointers.\n * @returns {void}\n */\nfunction validate(pointerType, p, elementSize) {\n    if (isNull(p))\n        return;\n    var t = followFars(p);\n    // Check the pointer type.\n    var A = t.segment.getUint32(t.byteOffset) & constants_1.POINTER_TYPE_MASK;\n    if (A !== pointerType)\n        throw new Error(util_1.format(errors_1.PTR_WRONG_POINTER_TYPE, p, pointerType));\n    // Check the list element size, if provided.\n    if (elementSize !== undefined) {\n        var C = t.segment.getUint32(t.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n        if (C !== elementSize)\n            throw new Error(util_1.format(errors_1.PTR_WRONG_LIST_TYPE, p, list_element_size_1.ListElementSize[elementSize]));\n    }\n}\nexports.validate = validate;\nfunction copyFromList(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcElementSize = getTargetListElementSize(src);\n    var srcLength = getTargetListLength(src);\n    var srcCompositeSize;\n    var srcStructByteLength;\n    var dstContent;\n    if (srcElementSize === list_element_size_1.ListElementSize.POINTER) {\n        dstContent = dst.segment.allocate(object_size_1.getByteLength(getTargetCompositeListSize(src)) * srcLength);\n        // Recursively copy each pointer in the list.\n        for (var i = 0; i < srcLength; i++) {\n            var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + (i << 3), src._capnp.depthLimit - 1);\n            var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + (i << 3), dst._capnp.depthLimit - 1);\n            copyFrom(srcPtr, dstPtr);\n        }\n    }\n    else if (srcElementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n        srcCompositeSize = object_size_1.padToWord(getTargetCompositeListSize(src));\n        srcStructByteLength = object_size_1.getByteLength(srcCompositeSize);\n        dstContent = dst.segment.allocate(object_size_1.getByteLength(srcCompositeSize) * srcLength + 8);\n        // Copy the tag word.\n        dstContent.segment.copyWord(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset - 8);\n        // Copy the entire contents, including all pointers. This should be more efficient than making `srcLength`\n        // copies to skip the pointer sections, and we're about to rewrite all those pointers anyway.\n        // PERF: Skip this step if the composite struct only contains pointers.\n        if (srcCompositeSize.dataByteLength > 0) {\n            var wordLength = object_size_1.getWordLength(srcCompositeSize) * srcLength;\n            dstContent.segment.copyWords(dstContent.byteOffset + 8, srcContent.segment, srcContent.byteOffset, wordLength);\n        }\n        // Recursively copy all the pointers in each struct.\n        for (var i = 0; i < srcLength; i++) {\n            for (var j = 0; j < srcCompositeSize.pointerLength; j++) {\n                var offset = i * srcStructByteLength + srcCompositeSize.dataByteLength + (j << 3);\n                var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n                var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset + 8, dst._capnp.depthLimit - 1);\n                copyFrom(srcPtr, dstPtr);\n            }\n        }\n    }\n    else {\n        var byteLength = util_1.padToWord(srcElementSize === list_element_size_1.ListElementSize.BIT\n            ? srcLength + 7 >>> 3\n            : getListElementByteLength(srcElementSize) * srcLength);\n        var wordLength = byteLength >>> 3;\n        dstContent = dst.segment.allocate(byteLength);\n        // Copy all of the list contents word-by-word.\n        dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, wordLength);\n    }\n    // Initialize the list pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setListPointer(res.offsetWords, srcElementSize, srcLength, res.pointer, srcCompositeSize);\n}\nexports.copyFromList = copyFromList;\nfunction copyFromStruct(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcSize = getTargetStructSize(src);\n    var srcDataWordLength = object_size_1.getDataWordLength(srcSize);\n    // Allocate space for the destination content.\n    var dstContent = dst.segment.allocate(object_size_1.getByteLength(srcSize));\n    // Copy the data section.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, srcDataWordLength);\n    // Copy the pointer section.\n    for (var i = 0; i < srcSize.pointerLength; i++) {\n        var offset = srcSize.dataByteLength + i * 8;\n        var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n        var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset, dst._capnp.depthLimit - 1);\n        copyFrom(srcPtr, dstPtr);\n    }\n    // Don't touch dst if it's already initialized as a composite list pointer. With composite struct pointers there's\n    // no pointer to copy here and we've already copied the contents.\n    if (dst._capnp.compositeList)\n        return;\n    // Initialize the struct pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setStructPointer(res.offsetWords, srcSize, res.pointer);\n}\nexports.copyFromStruct = copyFromStruct;\n/**\n * Track the allocation of a new Pointer object.\n *\n * This will decrement an internal counter tracking how many bytes have been traversed in the message so far. After\n * a certain limit, this method will throw an error in order to prevent a certain class of DoS attacks.\n *\n * @param {Message} message The message the pointer belongs to.\n * @param {Pointer} p The pointer being allocated.\n * @returns {void}\n */\nfunction trackPointerAllocation(message, p) {\n    message._capnp.traversalLimit -= 8;\n    if (message._capnp.traversalLimit <= 0) {\n        throw new Error(util_1.format(errors_1.PTR_TRAVERSAL_LIMIT_EXCEEDED, p));\n    }\n}\nexports.trackPointerAllocation = trackPointerAllocation;\n\n//# sourceMappingURL=pointer.js.map\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"__extends\"] = __extends;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__assign\", function() { return __assign; });\n/* harmony export (immutable) */ __webpack_exports__[\"__rest\"] = __rest;\n/* harmony export (immutable) */ __webpack_exports__[\"__decorate\"] = __decorate;\n/* harmony export (immutable) */ __webpack_exports__[\"__param\"] = __param;\n/* harmony export (immutable) */ __webpack_exports__[\"__metadata\"] = __metadata;\n/* harmony export (immutable) */ __webpack_exports__[\"__awaiter\"] = __awaiter;\n/* harmony export (immutable) */ __webpack_exports__[\"__generator\"] = __generator;\n/* harmony export (immutable) */ __webpack_exports__[\"__exportStar\"] = __exportStar;\n/* harmony export (immutable) */ __webpack_exports__[\"__values\"] = __values;\n/* harmony export (immutable) */ __webpack_exports__[\"__read\"] = __read;\n/* harmony export (immutable) */ __webpack_exports__[\"__spread\"] = __spread;\n/* harmony export (immutable) */ __webpack_exports__[\"__await\"] = __await;\n/* harmony export (immutable) */ __webpack_exports__[\"__asyncGenerator\"] = __asyncGenerator;\n/* harmony export (immutable) */ __webpack_exports__[\"__asyncDelegator\"] = __asyncDelegator;\n/* harmony export (immutable) */ __webpack_exports__[\"__asyncValues\"] = __asyncValues;\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ListElementSize;\n(function (ListElementSize) {\n    ListElementSize[ListElementSize[\"VOID\"] = 0] = \"VOID\";\n    ListElementSize[ListElementSize[\"BIT\"] = 1] = \"BIT\";\n    ListElementSize[ListElementSize[\"BYTE\"] = 2] = \"BYTE\";\n    ListElementSize[ListElementSize[\"BYTE_2\"] = 3] = \"BYTE_2\";\n    ListElementSize[ListElementSize[\"BYTE_4\"] = 4] = \"BYTE_4\";\n    ListElementSize[ListElementSize[\"BYTE_8\"] = 5] = \"BYTE_8\";\n    ListElementSize[ListElementSize[\"POINTER\"] = 6] = \"POINTER\";\n    ListElementSize[ListElementSize[\"COMPOSITE\"] = 7] = \"COMPOSITE\";\n})(ListElementSize = exports.ListElementSize || (exports.ListElementSize = {}));\nexports.ListElementOffset = [\n    0,\n    0.125,\n    1,\n    2,\n    4,\n    8,\n    8,\n    NaN,\n];\n\n//# sourceMappingURL=list-element-size.js.map\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar errors_1 = __webpack_require__(5);\nvar util_1 = __webpack_require__(6);\nvar list_element_size_1 = __webpack_require__(3);\nvar object_size_1 = __webpack_require__(8);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list');\ntrace('load');\n/**\n * A generic list class. Implements Filterable,\n */\nvar List = /** @class */ (function (_super) {\n    tslib_1.__extends(List, _super);\n    function List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    List.toString = function () {\n        return this._capnp.displayName;\n    };\n    List.prototype.all = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            if (!callbackfn(this.get(i), i))\n                return false;\n        }\n        return true;\n    };\n    List.prototype.any = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++)\n            if (callbackfn(this.get(i), i))\n                return true;\n        return false;\n    };\n    List.prototype.ap = function (callbackfns) {\n        var _this = this;\n        var length = this.getLength();\n        var res = [];\n        var _loop_1 = function (i) {\n            res.push.apply(res, callbackfns.map(function (f) { return f(_this.get(i), i); }));\n        };\n        for (var i = 0; i < length; i++) {\n            _loop_1(i);\n        }\n        return res;\n    };\n    List.prototype.concat = function (other) {\n        var length = this.getLength();\n        var otherLength = other.getLength();\n        var res = new Array(length + otherLength);\n        for (var i = 0; i < length; i++)\n            res[i] = this.get(i);\n        for (var i = 0; i < otherLength; i++)\n            res[i + length] = other.get(i);\n        return res;\n    };\n    List.prototype.drop = function (n) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = n; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.dropWhile = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        var drop = true;\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            if (drop)\n                drop = callbackfn(v, i);\n            if (!drop)\n                res.push(v);\n        }\n        return res;\n    };\n    List.prototype.empty = function () { return []; };\n    List.prototype.every = function (callbackfn) { return this.all(callbackfn); };\n    List.prototype.filter = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        for (var i = 0; i < length; i++) {\n            var value = this.get(i);\n            if (callbackfn(value, i))\n                res.push(value);\n        }\n        return res;\n    };\n    List.prototype.find = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            var value = this.get(i);\n            if (callbackfn(value, i))\n                return value;\n        }\n        return undefined;\n    };\n    List.prototype.forEach = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++)\n            callbackfn(this.get(i), i);\n    };\n    List.prototype.get = function (_index) {\n        throw new TypeError();\n    };\n    /**\n     * Get the length of this list.\n     *\n     * @returns {number} The number of elements in this list.\n     */\n    List.prototype.getLength = function () {\n        return pointer_1.getTargetListLength(this);\n    };\n    List.prototype.groupBy = function (callbackfn) {\n        var length = this.getLength();\n        var res = {};\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            res[callbackfn(v, i)] = v;\n        }\n        return res;\n    };\n    List.prototype.intersperse = function (sep) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = 0; i < length; i++) {\n            if (i > 0)\n                res.push(sep);\n            res.push(this.get(i));\n        }\n        return res;\n    };\n    List.prototype.map = function (callbackfn) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = 0; i < length; i++)\n            res[i] = callbackfn(this.get(i), i);\n        return res;\n    };\n    List.prototype.reduce = function (callbackfn, initialValue) {\n        var i = 0;\n        var res;\n        if (initialValue === undefined) {\n            // LINT: It's okay, I know what I'm doing here.\n            /* tslint:disable-next-line:no-any */\n            res = this.get(0);\n            i++;\n        }\n        else {\n            res = initialValue;\n        }\n        for (; i < this.getLength(); i++)\n            res = callbackfn(res, this.get(i), i);\n        return res;\n    };\n    List.prototype.set = function (_index, _value) {\n        throw new TypeError();\n    };\n    List.prototype.slice = function (start, end) {\n        if (start === void 0) { start = 0; }\n        var length = end ? Math.min(this.getLength(), end) : this.getLength();\n        var res = new Array(length - start);\n        for (var i = start; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.some = function (callbackfn) { return this.any(callbackfn); };\n    List.prototype.take = function (n) {\n        var length = Math.min(this.getLength(), n);\n        var res = new Array(length);\n        for (var i = 0; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.takeWhile = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        var take;\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            take = callbackfn(v, i);\n            if (!take)\n                return res;\n            res.push(v);\n        }\n        return res;\n    };\n    List.prototype.toArray = function () {\n        return this.map(util_1.identity);\n    };\n    List.prototype.toString = function () {\n        return \"List_\" + _super.prototype.toString.call(this);\n    };\n    List._capnp = {\n        displayName: 'List<Generic>',\n        size: list_element_size_1.ListElementSize.VOID,\n    };\n    List.initList = initList;\n    return List;\n}(pointer_1.Pointer));\nexports.List = List;\n/**\n * Initialize the list with the given element size and length. This will allocate new space for the list, ideally in\n * the same segment as this pointer.\n *\n * @param {ListElementSize} elementSize The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {List<T>} l The list to initialize.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list. This value is required for\n * composite lists.\n * @returns {void}\n */\nfunction initList(elementSize, length, l, compositeSize) {\n    var c;\n    switch (elementSize) {\n        case list_element_size_1.ListElementSize.BIT:\n            c = l.segment.allocate(Math.ceil(length / 8));\n            break;\n        case list_element_size_1.ListElementSize.BYTE:\n        case list_element_size_1.ListElementSize.BYTE_2:\n        case list_element_size_1.ListElementSize.BYTE_4:\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n            c = l.segment.allocate(length * pointer_1.getListElementByteLength(elementSize));\n            break;\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            if (compositeSize === undefined)\n                throw new Error(util_1.format(errors_1.PTR_COMPOSITE_SIZE_UNDEFINED));\n            compositeSize = object_size_1.padToWord(compositeSize);\n            var byteLength = object_size_1.getByteLength(compositeSize) * length;\n            // We need to allocate an extra 8 bytes for the tag word, then make sure we write the length to it. We advance\n            // the content pointer by 8 bytes so that it then points to the first list element as intended. Everything\n            // starts off zeroed out so these nested structs don't need to be initialized in any way.\n            c = l.segment.allocate(byteLength + 8);\n            pointer_1.setStructPointer(length, compositeSize, c);\n            trace('Wrote composite tag word %s for %s.', c, l);\n            break;\n        case list_element_size_1.ListElementSize.VOID:\n            // No need to allocate anything, we can write the list pointer right here.\n            pointer_1.setListPointer(0, elementSize, length, l);\n            return;\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n    }\n    var res = pointer_1.initPointer(c.segment, c.byteOffset, l);\n    pointer_1.setListPointer(res.offsetWords, elementSize, length, res.pointer, compositeSize);\n}\nexports.initList = initList;\n\n//# sourceMappingURL=list.js.map\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * This file contains all the error strings used in the library. Also contains silliness.\n *\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar trace = debug_1.default('capnp:errors');\ntrace('load');\nfunction assertNever(n) {\n    throw new Error(exports.INVARIANT_UNREACHABLE_CODE + (\" (never block hit with: \" + n + \")\"));\n}\nexports.assertNever = assertNever;\n// Invariant violations (sometimes known as \"precondition failed\").\n//\n// All right, hold up the brakes. This is a serious 1 === 0 WHAT THE FAILURE moment here. Tell the SO's you won't be\n// home for dinner.\nexports.INVARIANT_UNREACHABLE_CODE = 'CAPNP-TS000 Unreachable code detected.';\n// Message errors.\n//\n// Now who told you it would be a good idea to fuzz the inputs? You just made the program sad.\nexports.MSG_INVALID_FRAME_HEADER = 'CAPNP-TS001 Attempted to parse an invalid message frame header; are you sure this is a Cap\\'n Proto message?';\nexports.MSG_NO_SEGMENTS_IN_ARENA = 'CAPNP-TS002 Attempted to preallocate a message with no segments in the arena.';\nexports.MSG_PACK_NOT_WORD_ALIGNED = 'CAPNP-TS003 Attempted to pack a message that was not word-aligned.';\nexports.MSG_SEGMENT_OUT_OF_BOUNDS = 'CAPNP-TS004 Segment ID %X is out of bounds for message %s.';\nexports.MSG_SEGMENT_TOO_SMALL = 'CAPNP-TS005 First segment must have at least enough room to hold the root pointer (8 bytes).';\n// Used for methods that are not yet implemented.\n//\n// My bad. I'll get to it. Eventually.\nexports.NOT_IMPLEMENTED = 'CAPNP-TS006 %s is not implemented.';\n// Pointer-related errors.\n//\n// Look, this is probably the hardest part of the code. Cut some slack here! You probably found a bug.\nexports.PTR_ADOPT_COMPOSITE_STRUCT = 'CAPNP-TS007 Attempted to adopt a struct into a composite list (%s).';\nexports.PTR_ADOPT_WRONG_MESSAGE = 'CAPNP-TS008 Attempted to adopt %s into a pointer in a different message %s.';\nexports.PTR_ALREADY_ADOPTED = 'CAPNP-TS009 Attempted to adopt %s more than once.';\nexports.PTR_COMPOSITE_SIZE_UNDEFINED = 'CAPNP-TS010 Attempted to set a composite list without providing a composite element size.';\nexports.PTR_DEPTH_LIMIT_EXCEEDED = 'CAPNP-TS011 Nesting depth limit exceeded for %s.';\nexports.PTR_DISOWN_COMPOSITE_STRUCT = 'CAPNP-TS012 Attempted to disown a struct member from a composite list (%s).';\nexports.PTR_INIT_COMPOSITE_STRUCT = 'CAPNP-TS013 Attempted to initialize a struct member from a composite list (%s).';\nexports.PTR_INIT_NON_GROUP = 'CAPNP-TS014 Attempted to initialize a group field with a non-group struct class.';\nexports.PTR_INVALID_FAR_TARGET = 'CAPNP-TS015 Target of a far pointer (%s) is another far pointer.';\nexports.PTR_INVALID_LIST_SIZE = 'CAPNP-TS016 Invalid list element size: %x.';\nexports.PTR_INVALID_POINTER_TYPE = 'CAPNP-TS017 Invalid pointer type: %x.';\nexports.PTR_INVALID_UNION_ACCESS = 'CAPNP-TS018 Attempted to access getter on %s for union field %s that is not currently set (wanted: %d, found: %d).';\nexports.PTR_OFFSET_OUT_OF_BOUNDS = 'CAPNP-TS019 Pointer offset %a is out of bounds for underlying buffer.';\nexports.PTR_STRUCT_DATA_OUT_OF_BOUNDS = 'CAPNP-TS020 Attempted to access out-of-bounds struct data (struct: %s, %d bytes at %a, data words: %d).';\nexports.PTR_STRUCT_POINTER_OUT_OF_BOUNDS = 'CAPNP-TS021 Attempted to access out-of-bounds struct pointer (%s, index: %d, length: %d).';\nexports.PTR_TRAVERSAL_LIMIT_EXCEEDED = 'CAPNP-TS022 Traversal limit exceeded! Slow down! %s';\nexports.PTR_WRONG_LIST_TYPE = 'CAPNP-TS023 Cannot convert %s to a %s list.';\nexports.PTR_WRONG_POINTER_TYPE = 'CAPNP-TS024 Attempted to convert pointer %s to a %s type.';\nexports.PTR_WRONG_COMPOSITE_DATA_SIZE = 'CAPNP-TS025 Attempted to convert %s to a composite list with the wrong data size (found: %d).';\nexports.PTR_WRONG_COMPOSITE_PTR_SIZE = 'CAPNP-TS026 Attempted to convert %s to a composite list with the wrong pointer size (found: %d).';\nexports.PTR_WRONG_STRUCT_DATA_SIZE = 'CAPNP-TS027 Attempted to convert %s to a struct with the wrong data size (found: %d).';\nexports.PTR_WRONG_STRUCT_PTR_SIZE = 'CAPNP-TS028 Attempted to convert %s to a struct with the wrong pointer size (found: %d).';\n// Custom error messages for the built-in `RangeError` class.\n//\n// You don't get a witty comment with these.\nexports.RANGE_INT32_OVERFLOW = 'CAPNP-TS029 32-bit signed integer overflow detected.';\nexports.RANGE_INT64_UNDERFLOW = 'CAPNP-TS030 Buffer is not large enough to hold a word.';\nexports.RANGE_INVALID_UTF8 = 'CAPNP-TS031 Invalid UTF-8 code sequence detected.';\nexports.RANGE_SIZE_OVERFLOW = \"CAPNP-TS032 Size %x exceeds maximum \" + constants_1.MAX_SEGMENT_LENGTH.toString(16) + \".\";\nexports.RANGE_UINT32_OVERFLOW = 'CAPNP-TS033 32-bit unsigned integer overflow detected.';\n// Segment-related errors.\n//\n// These suck. Deal with it.\nexports.SEG_BUFFER_NOT_ALLOCATED = 'CAPNP-TS034 allocate() needs to be called at least once before getting a buffer.';\nexports.SEG_GET_NON_ZERO_SINGLE = 'CAPNP-TS035 Attempted to get a segment other than 0 (%d) from a single segment arena.';\nexports.SEG_ID_OUT_OF_BOUNDS = 'CAPNP-TS036 Attempted to get an out-of-bounds segment (%d).';\nexports.SEG_NOT_WORD_ALIGNED = 'CAPNP-TS037 Segment buffer length %d is not a multiple of 8.';\nexports.SEG_REPLACEMENT_BUFFER_TOO_SMALL = 'CAPNP-TS038 Attempted to replace a segment buffer with one that is smaller than the allocated space.';\nexports.SEG_SIZE_OVERFLOW = \"CAPNP-TS039 Requested size %x exceeds maximum value (\" + constants_1.MAX_SEGMENT_LENGTH + \").\";\n// Custom error messages for the built-in `TypeError` class.\n//\n// If it looks like a duck, quacks like an elephant, and has hooves for feet, it's probably JavaScript.\nexports.TYPE_COMPOSITE_SIZE_UNDEFINED = 'CAPNP-TS040 Must provide a composite element size for composite list pointers.';\nexports.TYPE_GET_GENERIC_LIST = 'CAPNP-TS041 Attempted to call get() on a generic list.';\nexports.TYPE_SET_GENERIC_LIST = 'CAPNP-TS042 Attempted to call set() on a generic list.';\n\n//# sourceMappingURL=errors.js.map\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// LINT: a lot of the util functions need the any type.\n/* tslint:disable:no-any no-unsafe-any */\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar errors_1 = __webpack_require__(5);\nvar trace = debug_1.default('capnp:util');\ntrace('load');\n/**\n * Dump a hex string from the given buffer.\n *\n * @export\n * @param {ArrayBuffer} buffer The buffer to convert.\n * @returns {string} A hexadecimal string representing the buffer.\n */\nfunction bufferToHex(buffer) {\n    var a = new Uint8Array(buffer);\n    var h = [];\n    for (var i = 0; i < a.byteLength; i++)\n        h.push(pad(a[i].toString(16), 2));\n    return \"[\" + h.join(' ') + \"]\";\n}\nexports.bufferToHex = bufferToHex;\n/**\n * Throw an error if the provided value cannot be represented as a 32-bit integer.\n *\n * @export\n * @param {number} value The number to check.\n * @returns {number} The same number if it is valid.\n */\nfunction checkInt32(value) {\n    if (value > constants_1.MAX_INT32 || value < -constants_1.MAX_INT32)\n        throw new RangeError(errors_1.RANGE_INT32_OVERFLOW);\n    return value;\n}\nexports.checkInt32 = checkInt32;\nfunction checkUint32(value) {\n    if (value < 0 || value > constants_1.MAX_UINT32)\n        throw new RangeError(errors_1.RANGE_UINT32_OVERFLOW);\n    return value;\n}\nexports.checkUint32 = checkUint32;\n/**\n * Decode a UTF-8 encoded byte array into a JavaScript string (UCS-2).\n *\n * @export\n * @param {Uint8Array} src A utf-8 encoded byte array.\n * @returns {string} A string representation of the byte array.\n */\nfunction decodeUtf8(src) {\n    // This ain't for the faint of heart, kids. If you suffer from seizures, heart palpitations, or have had a history of\n    // stroke you may want to look away now.\n    var l = src.byteLength;\n    var dst = '';\n    var i = 0;\n    var cp = 0;\n    var a = 0;\n    var b = 0;\n    var c = 0;\n    var d = 0;\n    while (i < l) {\n        a = src[i++];\n        if ((a & 128) === 0) {\n            cp = a;\n        }\n        else if ((a & 224) === 192) {\n            if (i >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            cp = ((a & 31) << 6) | (b & 63);\n        }\n        else if ((a & 240) === 224) {\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            cp = ((a & 15) << 12) | ((b & 63) << 6) | (c & 63);\n        }\n        else if ((a & 248) === 240) {\n            if (i + 2 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            d = src[i++];\n            cp = ((a & 7) << 18) | ((b & 63) << 12) | ((c & 63) << 6) | (d & 63);\n        }\n        else {\n            throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n        }\n        if (cp <= 0xd7ff || (cp >= 0xe000 && cp <= 0xffff)) {\n            dst += String.fromCharCode(cp);\n        }\n        else {\n            // We must reach into the astral plane and construct the surrogate pair!\n            cp -= 0x00010000;\n            var hi = (cp >>> 10) + 0xd800;\n            var lo = (cp & 0x03ff) + 0xdc00;\n            if (hi < 0xd800 || hi > 0xdbff)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            dst += String.fromCharCode(hi, lo);\n        }\n    }\n    return dst;\n}\nexports.decodeUtf8 = decodeUtf8;\nfunction dumpBuffer(buffer) {\n    var b = buffer instanceof ArrayBuffer\n        ? new Uint8Array(buffer)\n        : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    var byteLength = Math.min(b.byteLength, constants_1.MAX_BUFFER_DUMP_BYTES);\n    var r = format('\\n=== buffer[%d] ===', byteLength);\n    for (var j = 0; j < byteLength; j += 16) {\n        r += \"\\n\" + pad(j.toString(16), 8) + \": \";\n        var s = '';\n        var k = void 0;\n        for (k = 0; k < 16 && j + k < b.byteLength; k++) {\n            var v = b[j + k];\n            r += pad(v.toString(16), 2) + \" \";\n            // Printable ASCII range.\n            s += v > 31 && v < 255 ? String.fromCharCode(v) : '·';\n            if (k === 7)\n                r += ' ';\n        }\n        r += \"\" + repeat((17 - k) * 3, ' ') + s;\n    }\n    r += '\\n';\n    if (byteLength !== b.byteLength) {\n        r += format('=== (truncated %d bytes) ===\\n', b.byteLength - byteLength);\n    }\n    return r;\n}\nexports.dumpBuffer = dumpBuffer;\n/**\n * Encode a JavaScript string (UCS-2) to a UTF-8 encoded string inside a Uint8Array.\n *\n * Note that the underlying buffer for the array will likely be larger than the actual contents; ignore the extra bytes.\n *\n * @export\n * @param {string} src The input string.\n * @returns {Uint8Array} A UTF-8 encoded buffer with the string's contents.\n */\nfunction encodeUtf8(src) {\n    var l = src.length;\n    var dst = new Uint8Array(new ArrayBuffer(l * 4));\n    var j = 0;\n    for (var i = 0; i < l; i++) {\n        var c = src.charCodeAt(i);\n        if (c <= 0x7f) {\n            dst[j++] = c;\n        }\n        else if (c <= 0x07ff) {\n            dst[j++] = 192 | (c >>> 6);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else if (c <= 0xd7ff || c >= 0xe000) {\n            dst[j++] = 224 | (c >>> 12);\n            dst[j++] = 128 | ((c >>> 6) & 63);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else {\n            // Make sure the surrogate pair is complete.\n            /* istanbul ignore next */\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            // I cast thee back into the astral plane.\n            var hi = c - 0xd800;\n            var lo = src.charCodeAt(++i) - 0xdc00;\n            var cp = ((hi << 10) | lo) + 0x00010000;\n            dst[j++] = 240 | (cp >>> 18);\n            dst[j++] = 128 | ((cp >>> 12) & 63);\n            dst[j++] = 128 | ((cp >>> 6) & 63);\n            dst[j++] = 128 | ((cp >>> 0) & 63);\n        }\n    }\n    return dst.subarray(0, j);\n}\nexports.encodeUtf8 = encodeUtf8;\n/**\n * Produce a `printf`-style string. Nice for providing arguments to `assert` without paying the cost for string\n * concatenation up front. Precision is supported for floating point numbers.\n *\n * @param {string} s The format string. Supported format specifiers: b, c, d, f, j, o, s, x, and X.\n * @param {...any} args Values to be formatted in the string. Arguments beyond what are consumed by the format string\n * are ignored.\n * @returns {string} The formatted string.\n */\nfunction format(s) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var n = s.length;\n    var arg;\n    var argIndex = 0;\n    var c;\n    var escaped = false;\n    var i = 0;\n    var leadingZero = false;\n    var precision;\n    var result = '';\n    function nextArg() {\n        return args[argIndex++];\n    }\n    function slurpNumber() {\n        var digits = '';\n        while (/\\d/.test(s[i])) {\n            digits += s[i++];\n            c = s[i];\n        }\n        return digits.length > 0 ? parseInt(digits, 10) : null;\n    }\n    for (; i < n; ++i) {\n        c = s[i];\n        if (escaped) {\n            escaped = false;\n            if (c === '.') {\n                leadingZero = false;\n                c = s[++i];\n            }\n            else if (c === '0' && s[i + 1] === '.') {\n                leadingZero = true;\n                i += 2;\n                c = s[i];\n            }\n            else {\n                leadingZero = true;\n            }\n            precision = slurpNumber();\n            switch (c) {\n                case 'a':// number in hex with padding\n                    result += '0x' + pad(parseInt(nextArg(), 10).toString(16), 8);\n                    break;\n                case 'b':// number in binary\n                    result += parseInt(nextArg(), 10).toString(2);\n                    break;\n                case 'c':// character\n                    arg = nextArg();\n                    if (typeof arg === 'string' || arg instanceof String) {\n                        result += arg;\n                    }\n                    else {\n                        result += String.fromCharCode(parseInt(arg, 10));\n                    }\n                    break;\n                case 'd':// number in decimal\n                    result += parseInt(nextArg(), 10);\n                    break;\n                case 'f':// floating point number\n                    var tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n                    result += leadingZero ? tmp : tmp.replace(/^0/, '');\n                    break;\n                case 'j':// JSON\n                    result += JSON.stringify(nextArg());\n                    break;\n                case 'o':// number in octal\n                    result += '0' + parseInt(nextArg(), 10).toString(8);\n                    break;\n                case 's':// string\n                    result += nextArg();\n                    break;\n                case 'x':// lowercase hexadecimal\n                    result += '0x' + parseInt(nextArg(), 10).toString(16);\n                    break;\n                case 'X':// uppercase hexadecimal\n                    result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();\n                    break;\n                default:\n                    result += c;\n                    break;\n            }\n        }\n        else if (c === '%') {\n            escaped = true;\n        }\n        else {\n            result += c;\n        }\n    }\n    return result;\n}\nexports.format = format;\n/**\n * Return the thing that was passed in. Yaaaaawn.\n *\n * @export\n * @template T\n * @param {T} x A thing.\n * @returns {T} The same thing.\n */\nfunction identity(x) {\n    return x;\n}\nexports.identity = identity;\nfunction pad(v, width, pad) {\n    if (pad === void 0) { pad = '0'; }\n    return v.length >= width ? v : new Array(width - v.length + 1).join(pad) + v;\n}\nexports.pad = pad;\n/**\n * Add padding to a number to make it divisible by 8. Typically used to pad byte sizes so they align to a word boundary.\n *\n * @export\n * @param {number} size The number to pad.\n * @returns {number} The padded number.\n */\nfunction padToWord(size) {\n    return (size + 7) & ~7;\n}\nexports.padToWord = padToWord;\n/**\n * Repeat a string n times. Shamelessly copied from lodash.repeat.\n *\n * @param {number} times Number of times to repeat.\n * @param {string} str The string to repeat.\n * @returns {string} The repeated string.\n */\nfunction repeat(times, str) {\n    var out = '';\n    var n = times;\n    var s = str;\n    if (n < 1 || n > Number.MAX_VALUE)\n        return out;\n    // https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    do {\n        if (n % 2)\n            out += s;\n        n = Math.floor(n / 2);\n        if (n)\n            s += s;\n    } while (n);\n    return out;\n}\nexports.repeat = repeat;\n// Set up custom debug formatters.\n/* tslint:disable:no-string-literal */\n/* istanbul ignore next */\ndebug_1.default.formatters['h'] = function (v) { return v.toString('hex'); };\n/* istanbul ignore next */\ndebug_1.default.formatters['x'] = function (v) { return \"0x\" + v.toString(16); };\n/* istanbul ignore next */\ndebug_1.default.formatters['a'] = function (v) { return \"0x\" + pad(v.toString(16), 8); };\n/* istanbul ignore next */\ndebug_1.default.formatters['X'] = function (v) { return \"0x\" + v.toString(16).toUpperCase(); };\n/* tslint:enable:no-string-literal */\n\n//# sourceMappingURL=util.js.map\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Perform some bit gymnastics to determine the native endian format.\nvar tmpWord = new DataView(new ArrayBuffer(8));\n(new Uint16Array(tmpWord.buffer))[0] = 0x0102;\n/** Default size (in bytes) for newly allocated segments. */\nexports.DEFAULT_BUFFER_SIZE = 4096;\nexports.DEFAULT_DECODE_LIMIT = 64 << 20; // 64 MiB\n/**\n * Limit to how deeply nested pointers are allowed to be. The root struct of a message will start at this value, and it\n * is decremented as pointers are dereferenced.\n */\nexports.DEFAULT_DEPTH_LIMIT = 64;\n/**\n * Limit to the number of **bytes** that can be traversed in a single message. This is necessary to prevent certain\n * classes of DoS attacks where maliciously crafted data can be self-referencing in a way that wouldn't trigger the\n * depth limit.\n *\n * For this reason, it is advised to cache pointers into variables and not constantly dereference them since the\n * message's traversal limit gets decremented each time.\n */\nexports.DEFAULT_TRAVERSE_LIMIT = 64 << 20; // 64 MiB\n/**\n * When allocating array buffers dynamically (while packing or in certain Arena implementations) the previous buffer's\n * size is multiplied by this number to determine the next buffer's size. This is chosen to keep both time spent\n * reallocating and wasted memory to a minimum.\n *\n * Smaller numbers would save memory at the expense of CPU time.\n */\nexports.GROWTH_FACTOR = 1.5;\n/** A bitmask applied to obtain the size of a list pointer. */\nexports.LIST_SIZE_MASK = 0x00000007;\n/** Maximum number of bytes to dump at once when dumping array buffers to string. */\nexports.MAX_BUFFER_DUMP_BYTES = 8192;\n/** The maximum value for a 32-bit integer. */\nexports.MAX_INT32 = 0x7fffffff;\n/** The maximum value for a 32-bit unsigned integer. */\nexports.MAX_UINT32 = 0xffffffff;\n/** The largest integer that can be precisely represented in JavaScript. */\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n/** Maximum limit on the number of segments in a message stream. */\nexports.MAX_STREAM_SEGMENTS = 512;\n/** The smallest integer that can be precisely represented in JavaScript. */\nexports.MIN_SAFE_INTEGER = -9007199254740991;\n/** Minimum growth increment for a SingleSegmentArena. */\nexports.MIN_SINGLE_SEGMENT_GROWTH = 4096;\n/**\n * This will be `true` if the machine running this code stores numbers natively in little-endian format. This is useful\n * for some numeric type conversions when the endianness does not affect the output. Using the native endianness for\n * these operations is _slightly_ faster.\n */\nexports.NATIVE_LITTLE_ENDIAN = tmpWord.getUint8(0) === 0x02;\n/**\n * When packing a message, this is the number of zero bytes required after a SPAN (0xff) tag is written to the packed\n * message before the span is terminated.\n *\n * This little detail is left up to the implementation because it can be tuned for performance. Setting this to a higher\n * value may help with messages that contain a ton of text/data.\n *\n * It is imperative to never set this below 1 or else BAD THINGS. You have been warned.\n */\nexports.PACK_SPAN_THRESHOLD = 2;\n/**\n * How far to travel into a nested pointer structure during a deep copy; when this limit is exhausted the copy\n * operation will throw an error.\n */\nexports.POINTER_COPY_LIMIT = 32;\n/** A bitmask for looking up the double-far flag on a far pointer. */\nexports.POINTER_DOUBLE_FAR_MASK = 0x00000004;\n/** A bitmask for looking up the pointer type. */\nexports.POINTER_TYPE_MASK = 0x00000003;\n/** Used for some 64-bit conversions, equal to Math.pow(2, 32). */\nexports.VAL32 = 0x100000000;\n/** The maximum value allowed for depth traversal limits. */\nexports.MAX_DEPTH = exports.MAX_INT32;\n/** The maximum byte length for a single segment. */\nexports.MAX_SEGMENT_LENGTH = exports.MAX_UINT32;\n\n//# sourceMappingURL=constants.js.map\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar _ = __webpack_require__(6);\nvar trace = debug_1.default('capnp:object-size');\ntrace('load');\n/**\n * A simple object that describes the size of a struct.\n *\n * @export\n * @class ObjectSize\n */\nvar ObjectSize = /** @class */ (function () {\n    function ObjectSize(dataByteLength, pointerCount) {\n        this.dataByteLength = dataByteLength;\n        this.pointerLength = pointerCount;\n    }\n    ObjectSize.prototype.toString = function () {\n        return _.format('ObjectSize_dw:%d,pc:%d', getDataWordLength(this), this.pointerLength);\n    };\n    return ObjectSize;\n}());\nexports.ObjectSize = ObjectSize;\nfunction getByteLength(o) {\n    return o.dataByteLength + o.pointerLength * 8;\n}\nexports.getByteLength = getByteLength;\nfunction getDataWordLength(o) {\n    return o.dataByteLength / 8;\n}\nexports.getDataWordLength = getDataWordLength;\nfunction getWordLength(o) {\n    return o.dataByteLength / 8 + o.pointerLength;\n}\nexports.getWordLength = getWordLength;\nfunction padToWord(o) {\n    return new ObjectSize(_.padToWord(o.dataByteLength), o.pointerLength);\n}\nexports.padToWord = padToWord;\n\n//# sourceMappingURL=object-size.js.map\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PointerType;\n(function (PointerType) {\n    PointerType[PointerType[\"STRUCT\"] = 0] = \"STRUCT\";\n    PointerType[PointerType[\"LIST\"] = 1] = \"LIST\";\n    PointerType[PointerType[\"FAR\"] = 2] = \"FAR\";\n    PointerType[PointerType[\"OTHER\"] = 3] = \"OTHER\";\n})(PointerType = exports.PointerType || (exports.PointerType = {}));\n\n//# sourceMappingURL=pointer-type.js.map\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nfunction PointerList(PointerClass) {\n    return _a = /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.get = function (index) {\n                var c = pointer_1.getContent(this);\n                return new PointerClass(c.segment, c.byteOffset + index * 8, this._capnp.depthLimit - 1);\n            };\n            class_1.prototype.set = function (index, value) {\n                pointer_1.copyFrom(value, this.get(index));\n            };\n            class_1.prototype.toString = function () {\n                return \"Pointer_\" + _super.prototype.toString.call(this) + \",cls:\" + PointerClass.toString();\n            };\n            return class_1;\n        }(list_1.List)),\n        _a._capnp = {\n            displayName: \"List<\" + PointerClass._capnp.displayName + \">\",\n            size: list_element_size_1.ListElementSize.POINTER,\n        },\n        _a;\n    var _a;\n}\nexports.PointerList = PointerList;\n\n//# sourceMappingURL=pointer-list.js.map\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ArenaKind;\n(function (ArenaKind) {\n    ArenaKind[ArenaKind[\"SINGLE_SEGMENT\"] = 0] = \"SINGLE_SEGMENT\";\n    ArenaKind[ArenaKind[\"MULTI_SEGMENT\"] = 1] = \"MULTI_SEGMENT\";\n})(ArenaKind = exports.ArenaKind || (exports.ArenaKind = {}));\n\n//# sourceMappingURL=arena-kind.js.map\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar serialization_1 = __webpack_require__(27);\nexports.ListElementSize = serialization_1.ListElementSize;\nexports.Message = serialization_1.Message;\nexports.ObjectSize = serialization_1.ObjectSize;\nexports.AnyPointerList = serialization_1.AnyPointerList;\nexports.BoolList = serialization_1.BoolList;\nexports.CompositeList = serialization_1.CompositeList;\nexports.Data = serialization_1.Data;\nexports.DataList = serialization_1.DataList;\nexports.Float32List = serialization_1.Float32List;\nexports.Float64List = serialization_1.Float64List;\nexports.Int16List = serialization_1.Int16List;\nexports.Int32List = serialization_1.Int32List;\nexports.Int64List = serialization_1.Int64List;\nexports.Int8List = serialization_1.Int8List;\nexports.Interface = serialization_1.Interface;\nexports.InterfaceList = serialization_1.InterfaceList;\nexports.List = serialization_1.List;\nexports.Orphan = serialization_1.Orphan;\nexports.PointerList = serialization_1.PointerList;\nexports.PointerType = serialization_1.PointerType;\nexports.Pointer = serialization_1.Pointer;\nexports.Struct = serialization_1.Struct;\nexports.Text = serialization_1.Text;\nexports.TextList = serialization_1.TextList;\nexports.Uint16List = serialization_1.Uint16List;\nexports.Uint32List = serialization_1.Uint32List;\nexports.Uint64List = serialization_1.Uint64List;\nexports.Uint8List = serialization_1.Uint8List;\nexports.VoidList = serialization_1.VoidList;\nexports.Void = serialization_1.Void;\nexports.getBitMask = serialization_1.getBitMask;\nexports.getFloat32Mask = serialization_1.getFloat32Mask;\nexports.getFloat64Mask = serialization_1.getFloat64Mask;\nexports.getInt16Mask = serialization_1.getInt16Mask;\nexports.getInt32Mask = serialization_1.getInt32Mask;\nexports.getInt64Mask = serialization_1.getInt64Mask;\nexports.getInt8Mask = serialization_1.getInt8Mask;\nexports.getUint16Mask = serialization_1.getUint16Mask;\nexports.getUint32Mask = serialization_1.getUint32Mask;\nexports.getUint64Mask = serialization_1.getUint64Mask;\nexports.getUint8Mask = serialization_1.getUint8Mask;\nvar types_1 = __webpack_require__(16);\nexports.Int64 = types_1.Int64;\nexports.Uint64 = types_1.Uint64;\n\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar any_pointer_list_1 = __webpack_require__(36);\nexports.AnyPointerList = any_pointer_list_1.AnyPointerList;\nvar bool_list_1 = __webpack_require__(38);\nexports.BoolList = bool_list_1.BoolList;\nvar composite_list_1 = __webpack_require__(39);\nexports.CompositeList = composite_list_1.CompositeList;\nvar data_1 = __webpack_require__(14);\nexports.Data = data_1.Data;\nvar data_list_1 = __webpack_require__(40);\nexports.DataList = data_list_1.DataList;\nvar float32_list_1 = __webpack_require__(41);\nexports.Float32List = float32_list_1.Float32List;\nvar float64_list_1 = __webpack_require__(42);\nexports.Float64List = float64_list_1.Float64List;\nvar int8_list_1 = __webpack_require__(43);\nexports.Int8List = int8_list_1.Int8List;\nvar int16_list_1 = __webpack_require__(44);\nexports.Int16List = int16_list_1.Int16List;\nvar int32_list_1 = __webpack_require__(45);\nexports.Int32List = int32_list_1.Int32List;\nvar int64_list_1 = __webpack_require__(46);\nexports.Int64List = int64_list_1.Int64List;\nvar interface_1 = __webpack_require__(22);\nexports.Interface = interface_1.Interface;\nvar interface_list_1 = __webpack_require__(47);\nexports.InterfaceList = interface_list_1.InterfaceList;\nvar list_1 = __webpack_require__(4);\nexports.List = list_1.List;\nvar orphan_1 = __webpack_require__(21);\nexports.Orphan = orphan_1.Orphan;\nvar pointer_list_1 = __webpack_require__(10);\nexports.PointerList = pointer_list_1.PointerList;\nvar pointer_type_1 = __webpack_require__(9);\nexports.PointerType = pointer_type_1.PointerType;\nvar pointer_1 = __webpack_require__(1);\nexports.Pointer = pointer_1.Pointer;\nvar struct_1 = __webpack_require__(15);\nexports.Struct = struct_1.Struct;\nvar text_1 = __webpack_require__(17);\nexports.Text = text_1.Text;\nvar text_list_1 = __webpack_require__(49);\nexports.TextList = text_list_1.TextList;\nvar uint8_list_1 = __webpack_require__(50);\nexports.Uint8List = uint8_list_1.Uint8List;\nvar uint16_list_1 = __webpack_require__(51);\nexports.Uint16List = uint16_list_1.Uint16List;\nvar uint32_list_1 = __webpack_require__(52);\nexports.Uint32List = uint32_list_1.Uint32List;\nvar uint64_list_1 = __webpack_require__(53);\nexports.Uint64List = uint64_list_1.Uint64List;\nvar void_1 = __webpack_require__(24);\nexports.Void = void_1.Void;\nexports.VOID = void_1.VOID;\nvar void_list_1 = __webpack_require__(54);\nexports.VoidList = void_list_1.VoidList;\n\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar pointer_type_1 = __webpack_require__(9);\nvar trace = debug_1.default('capnp:data');\ntrace('load');\n/**\n * A generic blob of bytes. Can be converted to a DataView or Uint8Array to access its contents using `toDataView()` and\n * `toUint8Array()`. Use `copyBuffer()` to copy an entire buffer at once.\n *\n * @export\n * @class Data\n * @extends {List<number>}\n */\nvar Data = /** @class */ (function (_super) {\n    tslib_1.__extends(Data, _super);\n    function Data() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Data.fromPointer = function (pointer) {\n        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n        return this._fromPointerUnchecked(pointer);\n    };\n    Data._fromPointerUnchecked = function (pointer) {\n        return new this(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n    };\n    /**\n     * Copy the contents of `src` into this Data pointer. If `src` is smaller than the length of this pointer then the\n     * remaining bytes will be zeroed out. Extra bytes in `src` are ignored.\n     *\n     * @param {(ArrayBuffer | ArrayBufferView)} src The source buffer.\n     * @returns {void}\n     */\n    // TODO: Would be nice to have a way to zero-copy a buffer by allocating a new segment into the message with that\n    // buffer data.\n    Data.prototype.copyBuffer = function (src) {\n        var c = pointer_1.getContent(this);\n        var dstLength = this.getLength();\n        var srcLength = src.byteLength;\n        var i = src instanceof ArrayBuffer\n            ? new Uint8Array(src)\n            : new Uint8Array(src.buffer, src.byteOffset, Math.min(dstLength, srcLength));\n        var o = new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n        o.set(i);\n        if (dstLength > srcLength) {\n            trace('Zeroing out remaining %d bytes after copy into %s.', dstLength - srcLength, this);\n            o.fill(0, srcLength, dstLength);\n        }\n        else if (dstLength < srcLength) {\n            trace('Truncated %d bytes from source buffer while copying to %s.', srcLength - dstLength, this);\n        }\n    };\n    /**\n     * Read a byte from the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to read.\n     * @returns {number} The byte value.\n     */\n    Data.prototype.get = function (byteOffset) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint8(c.byteOffset + byteOffset);\n    };\n    /**\n     * Write a byte at the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to set.\n     * @param {number} value The byte value to set.\n     * @returns {void}\n     */\n    Data.prototype.set = function (byteOffset, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint8(c.byteOffset + byteOffset, value);\n    };\n    /**\n     * Creates a **copy** of the underlying buffer data and returns it as an ArrayBuffer.\n     *\n     * To obtain a reference to the underlying buffer instead, use `toUint8Array()` or `toDataView()`.\n     *\n     * @returns {ArrayBuffer} A copy of this data buffer.\n     */\n    Data.prototype.toArrayBuffer = function () {\n        var c = pointer_1.getContent(this);\n        return c.segment.buffer.slice(c.byteOffset, c.byteOffset + this.getLength());\n    };\n    /**\n     * Convert this Data pointer to a DataView representing the pointer's contents.\n     *\n     * WARNING: The DataView references memory from a message segment, so do not venture outside the bounds of the\n     * DataView or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toDataView = function () {\n        var c = pointer_1.getContent(this);\n        return new DataView(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    Data.prototype.toString = function () {\n        return \"Data_\" + _super.prototype.toString.call(this);\n    };\n    /**\n     * Convert this Data pointer to a Uint8Array representing the pointer's contents.\n     *\n     * WARNING: The Uint8Array references memory from a message segment, so do not venture outside the bounds of the\n     * Uint8Array or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toUint8Array = function () {\n        var c = pointer_1.getContent(this);\n        return new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    return Data;\n}(list_1.List));\nexports.Data = Data;\n\n//# sourceMappingURL=data.js.map\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar types_1 = __webpack_require__(16);\nvar util_1 = __webpack_require__(6);\nvar list_element_size_1 = __webpack_require__(3);\nvar object_size_1 = __webpack_require__(8);\nvar data_1 = __webpack_require__(14);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar pointer_type_1 = __webpack_require__(9);\nvar text_1 = __webpack_require__(17);\nvar errors_1 = __webpack_require__(5);\nvar trace = debug_1.default('capnp:struct');\ntrace('load');\n// Used to apply bit masks (default values).\nvar TMP_WORD = new DataView(new ArrayBuffer(8));\nvar Struct = /** @class */ (function (_super) {\n    tslib_1.__extends(Struct, _super);\n    /**\n     * Create a new pointer to a struct.\n     *\n     * @constructor {Struct}\n     * @param {Segment} segment The segment the pointer resides in.\n     * @param {number} byteOffset The offset from the beginning of the segment to the beginning of the pointer data.\n     * @param {any} [depthLimit=MAX_DEPTH] The nesting depth limit for this object.\n     * @param {number} [compositeIndex] If set, then this pointer is actually a reference to a composite list\n     * (`this._getPointerTargetType() === PointerType.LIST`), and this number is used as the index of the struct within\n     * the list. It is not valid to call `initStruct()` on a composite struct – the struct contents are initialized when\n     * the list pointer is initialized.\n     */\n    function Struct(segment, byteOffset, depthLimit, compositeIndex) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        _this._capnp.compositeIndex = compositeIndex;\n        _this._capnp.compositeList = compositeIndex !== undefined;\n        return _this;\n    }\n    Struct.toString = function () {\n        return this._capnp.displayName;\n    };\n    Struct.prototype.toString = function () {\n        return \"Struct_\" + _super.prototype.toString.call(this) +\n            (\"\" + (this._capnp.compositeIndex === undefined ? '' : \",ci:\" + this._capnp.compositeIndex));\n    };\n    Struct._capnp = {\n        displayName: 'Struct',\n    };\n    Struct.getAs = getAs;\n    Struct.getBit = getBit;\n    Struct.getData = getData;\n    Struct.getFloat32 = getFloat32;\n    Struct.getFloat64 = getFloat64;\n    Struct.getUint8 = getUint8;\n    Struct.getUint16 = getUint16;\n    Struct.getUint32 = getUint32;\n    Struct.getUint64 = getUint64;\n    Struct.getInt8 = getInt8;\n    Struct.getInt16 = getInt16;\n    Struct.getInt32 = getInt32;\n    Struct.getInt64 = getInt64;\n    Struct.getList = getList;\n    Struct.getPointer = getPointer;\n    Struct.getPointerAs = getPointerAs;\n    Struct.getStruct = getStruct;\n    Struct.getText = getText;\n    Struct.initData = initData;\n    Struct.initList = initList;\n    Struct.initStruct = initStruct;\n    Struct.initStructAt = initStructAt;\n    Struct.setBit = setBit;\n    Struct.setFloat32 = setFloat32;\n    Struct.setFloat64 = setFloat64;\n    Struct.setUint8 = setUint8;\n    Struct.setUint16 = setUint16;\n    Struct.setUint32 = setUint32;\n    Struct.setUint64 = setUint64;\n    Struct.setInt8 = setInt8;\n    Struct.setInt16 = setInt16;\n    Struct.setInt32 = setInt32;\n    Struct.setInt64 = setInt64;\n    Struct.setText = setText;\n    Struct.testWhich = testWhich;\n    return Struct;\n}(pointer_1.Pointer));\nexports.Struct = Struct;\n/**\n * Initialize a struct with the provided object size. This will allocate new space for the struct contents, ideally in\n * the same segment as this pointer.\n *\n * @param {ObjectSize} size An object describing the size of the struct's data and pointer sections.\n * @param {Struct} s The struct to initialize.\n * @returns {void}\n */\nfunction initStruct(size, s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_INIT_COMPOSITE_STRUCT, s));\n    // Make sure to clear existing contents before overwriting the pointer data (erase is a noop if already empty).\n    pointer_1.erase(s);\n    var c = s.segment.allocate(object_size_1.getByteLength(size));\n    var res = pointer_1.initPointer(c.segment, c.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, size, res.pointer);\n}\nexports.initStruct = initStruct;\nfunction initStructAt(index, StructClass, p) {\n    var s = getPointerAs(index, StructClass, p);\n    initStruct(StructClass._capnp.size, s);\n    return s;\n}\nexports.initStructAt = initStructAt;\n/**\n * Make a shallow copy of a struct's contents and update the pointer to point to the new content. The data and pointer\n * sections will be resized to the provided size.\n *\n * WARNING: This method can cause data loss if `dstSize` is smaller than the original size!\n *\n * @param {ObjectSize} dstSize The desired size for the struct contents.\n * @param {Struct} s The struct to resize.\n * @returns {void}\n */\nfunction resize(dstSize, s) {\n    var srcSize = getSize(s);\n    var srcContent = pointer_1.getContent(s);\n    var dstContent = s.segment.allocate(object_size_1.getByteLength(dstSize));\n    // Only copy the data section for now. The pointer section will need to be rewritten.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, Math.min(object_size_1.getDataWordLength(srcSize), object_size_1.getDataWordLength(dstSize)));\n    var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, dstSize, res.pointer);\n    // Iterate through the new pointer section and update the offsets so they point to the right place. This is a bit\n    // more complicated than it appears due to the fact that the original pointers could have been far pointers, and\n    // the new pointers might need to be allocated as far pointers if the segment is full.\n    for (var i = 0; i < Math.min(srcSize.pointerLength, dstSize.pointerLength); i++) {\n        var srcPtr = new pointer_1.Pointer(srcContent.segment, srcContent.byteOffset + srcSize.dataByteLength + i * 8);\n        var srcPtrTarget = pointer_1.followFars(srcPtr);\n        var srcPtrContent = pointer_1.getContent(srcPtr);\n        var dstPtr = new pointer_1.Pointer(dstContent.segment, dstContent.byteOffset + dstSize.dataByteLength + i * 8);\n        // For composite lists the offset needs to point to the tag word, not the first element which is what getContent\n        // returns.\n        if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n            pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n            srcPtrContent.byteOffset -= 8;\n        }\n        var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n        // Read the old pointer data, but discard the original offset.\n        var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n        var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n        r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n        r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n    }\n    // Zero out the old data and pointer sections.\n    srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize));\n}\nexports.resize = resize;\nfunction adopt(src, s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_ADOPT_COMPOSITE_STRUCT, s));\n    pointer_1.Pointer.adopt(src, s);\n}\nexports.adopt = adopt;\nfunction disown(s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_DISOWN_COMPOSITE_STRUCT, s));\n    return pointer_1.Pointer.disown(s);\n}\nexports.disown = disown;\n/**\n * Convert a struct to a struct of the provided class. Particularly useful when casting to nested group types.\n *\n * @protected\n * @template T\n * @param {StructCtor<T>} StructClass The struct class to convert to. Not particularly useful if `Struct`.\n * @param {Struct} s The struct to convert.\n * @returns {T} A new instance of the desired struct class pointing to the same location.\n */\nfunction getAs(StructClass, s) {\n    return new StructClass(s.segment, s.byteOffset, s._capnp.depthLimit, s._capnp.compositeIndex);\n}\nexports.getAs = getAs;\n/**\n * Read a boolean (bit) value out of a struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {boolean} The value.\n */\nfunction getBit(bitOffset, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    if (defaultMask === undefined)\n        return (v & bitMask) !== 0;\n    var defaultValue = defaultMask.getUint8(0);\n    return ((v ^ defaultValue) & bitMask) !== 0;\n}\nexports.getBit = getBit;\nfunction getData(index, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        list_1.List.initList(list_element_size_1.ListElementSize.BYTE, 0, l);\n    }\n    return l;\n}\nexports.getData = getData;\nfunction getDataSection(s) {\n    return pointer_1.getContent(s);\n}\nexports.getDataSection = getDataSection;\n/**\n * Read a float32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getFloat32(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getFloat32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getFloat32 = getFloat32;\n/**\n * Read a float64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n        var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n        TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n        TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n        return TMP_WORD.getFloat64(0, constants_1.NATIVE_LITTLE_ENDIAN);\n    }\n    return ds.segment.getFloat64(ds.byteOffset + byteOffset);\n}\nexports.getFloat64 = getFloat64;\n/**\n * Read an int16 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt16(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n    TMP_WORD.setUint16(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt16(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt16 = getInt16;\n/**\n * Read an int32 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt32(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt32 = getInt32;\n/**\n * Read an int64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt64(ds.byteOffset + byteOffset);\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Int64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getInt64 = getInt64;\n/**\n * Read an int8 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt8(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n    TMP_WORD.setUint8(0, v);\n    return TMP_WORD.getInt8(0);\n}\nexports.getInt8 = getInt8;\nfunction getList(index, ListClass, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        list_1.List.initList(ListClass._capnp.size, 0, l, ListClass._capnp.compositeSize);\n    }\n    else if (ListClass._capnp.compositeSize !== undefined) {\n        // If this is a composite list we need to be sure the composite elements are big enough to hold everything as\n        // specified in the schema. If the new schema has added fields we'll need to \"resize\" (shallow-copy) the list so\n        // it has room for the new fields.\n        var srcSize = pointer_1.getTargetCompositeListSize(l);\n        var dstSize = ListClass._capnp.compositeSize;\n        if (dstSize.dataByteLength > srcSize.dataByteLength || dstSize.pointerLength > srcSize.pointerLength) {\n            var srcContent = pointer_1.getContent(l);\n            var srcLength = pointer_1.getTargetListLength(l);\n            trace('resizing composite list %s due to protocol upgrade, new size: %d', l, object_size_1.getByteLength(dstSize) * srcLength);\n            // Allocate an extra 8 bytes for the tag.\n            var dstContent = l.segment.allocate(object_size_1.getByteLength(dstSize) * srcLength + 8);\n            var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, l);\n            pointer_1.setListPointer(res.offsetWords, ListClass._capnp.size, srcLength, res.pointer, dstSize);\n            // Write the new tag word.\n            pointer_1.setStructPointer(srcLength, dstSize, dstContent);\n            // Seek ahead past the tag word before copying the content.\n            dstContent.byteOffset += 8;\n            for (var i = 0; i < srcLength; i++) {\n                var srcElementOffset = srcContent.byteOffset + i * object_size_1.getByteLength(srcSize);\n                var dstElementOffset = dstContent.byteOffset + i * object_size_1.getByteLength(dstSize);\n                // Copy the data section.\n                dstContent.segment.copyWords(dstElementOffset, srcContent.segment, srcElementOffset, object_size_1.getWordLength(srcSize));\n                // Iterate through the pointers and update the offsets so they point to the right place.\n                for (var j = 0; j < srcSize.pointerLength; j++) {\n                    var srcPtr = new pointer_1.Pointer(srcContent.segment, srcElementOffset + srcSize.dataByteLength + j * 8);\n                    var dstPtr = new pointer_1.Pointer(dstContent.segment, dstElementOffset + dstSize.dataByteLength + j * 8);\n                    var srcPtrTarget = pointer_1.followFars(srcPtr);\n                    var srcPtrContent = pointer_1.getContent(srcPtr);\n                    if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n                        pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n                        srcPtrContent.byteOffset -= 8;\n                    }\n                    var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n                    // Read the old pointer data, but discard the original offset.\n                    var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n                    var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n                    r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n                    r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n                }\n            }\n            // Zero out the old content.\n            srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize) * srcLength);\n        }\n    }\n    return l;\n}\nexports.getList = getList;\nfunction getPointer(index, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new pointer_1.Pointer(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointer = getPointer;\nfunction getPointerAs(index, PointerClass, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new PointerClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointerAs = getPointerAs;\nfunction getPointerSection(s) {\n    var ps = pointer_1.getContent(s);\n    ps.byteOffset += util_1.padToWord(getSize(s).dataByteLength);\n    return ps;\n}\nexports.getPointerSection = getPointerSection;\nfunction getSize(s) {\n    if (s._capnp.compositeIndex !== undefined) {\n        // For composite lists the object size is stored in a tag word right before the content.\n        var c = pointer_1.getContent(s, true);\n        c.byteOffset -= 8;\n        return pointer_1.getStructSize(c);\n    }\n    return pointer_1.getTargetStructSize(s);\n}\nexports.getSize = getSize;\nfunction getStruct(index, StructClass, s) {\n    var t = getPointerAs(index, StructClass, s);\n    if (pointer_1.isNull(t)) {\n        initStruct(StructClass._capnp.size, t);\n    }\n    else {\n        pointer_1.validate(pointer_type_1.PointerType.STRUCT, t);\n        var ts = pointer_1.getTargetStructSize(t);\n        // This can happen when reading a struct that was constructed with an older version of the same schema, and new\n        // fields were added to the struct. A shallow copy of the struct will be made so that there's enough room for the\n        // data and pointer sections. This will unfortunately leave a \"hole\" of zeroes in the message, but that hole will\n        // at least compress well.\n        if (ts.dataByteLength < StructClass._capnp.size.dataByteLength\n            || ts.pointerLength < StructClass._capnp.size.pointerLength) {\n            trace('need to resize child struct %s', t);\n            resize(StructClass._capnp.size, t);\n        }\n    }\n    return t;\n}\nexports.getStruct = getStruct;\nfunction getText(index, s) {\n    return text_1.Text.fromPointer(getPointer(index, s)).get(0);\n}\nexports.getText = getText;\n/**\n * Read an uint16 value out of a struct..\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint16(ds.byteOffset + byteOffset);\n    return ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n}\nexports.getUint16 = getUint16;\n/**\n * Read an uint32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint32(ds.byteOffset + byteOffset);\n    return ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n}\nexports.getUint32 = getUint32;\n/**\n * Read an uint64 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint64(ds.byteOffset + byteOffset);\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Uint64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getUint64 = getUint64;\n/**\n * Read an uint8 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint8(ds.byteOffset + byteOffset);\n    return ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n}\nexports.getUint8 = getUint8;\nfunction initData(index, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(list_element_size_1.ListElementSize.BYTE, length, l);\n    return l;\n}\nexports.initData = initData;\nfunction initList(index, ListClass, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(ListClass._capnp.size, length, l, ListClass._capnp.compositeSize);\n    return l;\n}\nexports.initList = initList;\n/**\n * Write a boolean (bit) value to the struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {boolean} value The value to write (writes a 0 for `false`, 1 for `true`).\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setBit(bitOffset, value, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var b = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    // If the default mask bit is set, that means `true` values are actually written as `0`.\n    if (defaultMask !== undefined)\n        value = (defaultMask.getUint8(0) & bitMask) !== 0 ? !value : value;\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value ? b | bitMask : b & ~bitMask);\n}\nexports.setBit = setBit;\n/**\n * Write a primitive float32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setFloat32(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat32 = setFloat32;\n/**\n * Write a primitive float64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat64(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var lo = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        var hi = TMP_WORD.getUint32(4, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(4, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, lo);\n        ds.segment.setUint32(ds.byteOffset + byteOffset + 4, hi);\n        return;\n    }\n    ds.segment.setFloat64(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat64 = setFloat64;\n/**\n * Write a primitive int16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt16(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint16(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint16(0, true);\n        ds.segment.setUint16(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt16(ds.byteOffset + byteOffset, value);\n}\nexports.setInt16 = setInt16;\n/**\n * Write a primitive int32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt32(ds.byteOffset + byteOffset, value);\n}\nexports.setInt32 = setInt32;\n/**\n * Write a primitive int64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Int64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Int64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setInt64(ds.byteOffset + byteOffset, value);\n}\nexports.setInt64 = setInt64;\n/**\n * Write a primitive int8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt8(0, value);\n        var v = TMP_WORD.getUint8(0) ^ defaultMask.getUint8(0);\n        ds.segment.setUint8(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt8(ds.byteOffset + byteOffset, value);\n}\nexports.setInt8 = setInt8;\nfunction setPointer(index, value, s) {\n    pointer_1.copyFrom(value, getPointer(index, s));\n}\nexports.setPointer = setPointer;\nfunction setText(index, value, s) {\n    text_1.Text.fromPointer(getPointer(index, s)).set(0, value);\n}\nexports.setText = setText;\n/**\n * Write a primitive uint16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint16(0, true);\n    ds.segment.setUint16(ds.byteOffset + byteOffset, value);\n}\nexports.setUint16 = setUint16;\n/**\n * Write a primitive uint32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint32(0, true);\n    ds.segment.setUint32(ds.byteOffset + byteOffset, value);\n}\nexports.setUint32 = setUint32;\n/**\n * Write a primitive uint64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Uint64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Uint64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setUint64(ds.byteOffset + byteOffset, value);\n}\nexports.setUint64 = setUint64;\n/**\n * Write a primitive uint8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint8(0);\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value);\n}\nexports.setUint8 = setUint8;\nfunction testWhich(name, found, wanted, s) {\n    if (found !== wanted)\n        throw new Error(util_1.format(errors_1.PTR_INVALID_UNION_ACCESS, s, name, found, wanted));\n}\nexports.testWhich = testWhich;\nfunction checkDataBounds(byteOffset, byteLength, s) {\n    var dataByteLength = getSize(s).dataByteLength;\n    if (byteOffset < 0 || byteLength < 0 || byteOffset + byteLength > dataByteLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_DATA_OUT_OF_BOUNDS, s, byteLength, byteOffset, dataByteLength));\n    }\n}\nexports.checkDataBounds = checkDataBounds;\nfunction checkPointerBounds(index, s) {\n    var pointerLength = getSize(s).pointerLength;\n    if (index < 0 || index >= pointerLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_POINTER_OUT_OF_BOUNDS, s, index, pointerLength));\n    }\n}\nexports.checkPointerBounds = checkPointerBounds;\n\n//# sourceMappingURL=struct.js.map\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar int64_1 = __webpack_require__(48);\nexports.Int64 = int64_1.Int64;\nvar uint64_1 = __webpack_require__(23);\nexports.Uint64 = uint64_1.Uint64;\n\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar util_1 = __webpack_require__(6);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar pointer_type_1 = __webpack_require__(9);\nvar trace = debug_1.default('capnp:text');\ntrace('load');\nvar Text = /** @class */ (function (_super) {\n    tslib_1.__extends(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Text.fromPointer = function (pointer) {\n        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n        return textFromPointerUnchecked(pointer);\n    };\n    /**\n     * Read a utf-8 encoded string value from this pointer.\n     *\n     * @param {number} [index] The index at which to start reading; defaults to zero.\n     * @returns {string} The string value.\n     */\n    Text.prototype.get = function (index) {\n        if (index === void 0) { index = 0; }\n        if (index !== 0)\n            trace('Called get() on %s with a strange index (%d).', this, index);\n        if (pointer_1.isNull(this))\n            return '';\n        var c = pointer_1.getContent(this);\n        // Remember to exclude the NUL byte.\n        return util_1.decodeUtf8(new Uint8Array(c.segment.buffer, c.byteOffset + index, this.getLength() - index));\n    };\n    /**\n     * Get the number of utf-8 encoded bytes in this text. This does **not** include the NUL byte.\n     *\n     * @returns {number} The number of bytes allocated for the text.\n     */\n    Text.prototype.getLength = function () {\n        return _super.prototype.getLength.call(this) - 1;\n    };\n    /**\n     * Write a utf-8 encoded string value starting at the specified index.\n     *\n     * @param {number} index The index at which to start copying the string. Note that if this is not zero the bytes\n     * before `index` will be left as-is. All bytes after `index` will be overwritten.\n     * @param {string} value The string value to set.\n     * @returns {void}\n     */\n    Text.prototype.set = function (index, value) {\n        if (index !== 0)\n            trace('Called set() on %s with a strange index (%d).', this, index);\n        var src = util_1.encodeUtf8(value);\n        var dstLength = src.byteLength + index;\n        var c;\n        var original;\n        // TODO: Consider reusing existing space if list is already initialized and there's enough room for the value.\n        if (!pointer_1.isNull(this)) {\n            c = pointer_1.getContent(this);\n            // Only copy bytes that will remain after copying. Everything after `index` should end up truncated.\n            var originalLength = this.getLength();\n            if (originalLength >= index) {\n                originalLength = index;\n            }\n            else {\n                trace('%d byte gap exists between original text and new text in %s.', index - originalLength, this);\n            }\n            original = new Uint8Array(c.segment.buffer.slice(c.byteOffset, c.byteOffset + Math.min(originalLength, index)));\n            pointer_1.erase(this);\n        }\n        // Always allocate an extra byte for the NUL byte.\n        list_1.initList(list_element_size_1.ListElementSize.BYTE, dstLength + 1, this);\n        c = pointer_1.getContent(this);\n        var dst = new Uint8Array(c.segment.buffer, c.byteOffset, dstLength);\n        if (original)\n            dst.set(original);\n        dst.set(src, index);\n    };\n    Text.prototype.toString = function () {\n        return \"Text_\" + _super.prototype.toString.call(this);\n    };\n    return Text;\n}(list_1.List));\nexports.Text = Text;\nfunction textFromPointerUnchecked(pointer) {\n    return new Text(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n}\n\n//# sourceMappingURL=text.js.map\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar errors_1 = __webpack_require__(5);\nvar util_1 = __webpack_require__(6);\nvar arena_allocation_result_1 = __webpack_require__(19);\nvar arena_kind_1 = __webpack_require__(11);\nvar trace = debug_1.default('capnp:arena:multi');\ntrace('load');\nvar MultiSegmentArena = /** @class */ (function () {\n    function MultiSegmentArena(buffers) {\n        if (buffers === void 0) { buffers = []; }\n        this.kind = arena_kind_1.ArenaKind.MULTI_SEGMENT;\n        this.buffers = buffers;\n        trace('new %s', this);\n    }\n    MultiSegmentArena.prototype.toString = function () { return util_1.format('MultiSegmentArena_segments:%d', getNumSegments(this)); };\n    MultiSegmentArena.allocate = allocate;\n    MultiSegmentArena.getBuffer = getBuffer;\n    MultiSegmentArena.getNumSegments = getNumSegments;\n    return MultiSegmentArena;\n}());\nexports.MultiSegmentArena = MultiSegmentArena;\nfunction allocate(minSize, m) {\n    var b = new ArrayBuffer(util_1.padToWord(Math.max(minSize, constants_1.DEFAULT_BUFFER_SIZE)));\n    m.buffers.push(b);\n    return new arena_allocation_result_1.ArenaAllocationResult(m.buffers.length - 1, b);\n}\nexports.allocate = allocate;\nfunction getBuffer(id, m) {\n    if (id < 0 || id >= m.buffers.length)\n        throw new Error(util_1.format(errors_1.SEG_ID_OUT_OF_BOUNDS, id));\n    return m.buffers[id];\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments(m) {\n    return m.buffers.length;\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=multi-segment-arena.js.map\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar trace = debug_1.default('capnp:serialization:arena:arena-allocation-result');\ntrace('load');\nvar ArenaAllocationResult = /** @class */ (function () {\n    function ArenaAllocationResult(id, buffer) {\n        this.id = id;\n        this.buffer = buffer;\n        trace('new', this);\n    }\n    return ArenaAllocationResult;\n}());\nexports.ArenaAllocationResult = ArenaAllocationResult;\n\n//# sourceMappingURL=arena-allocation-result.js.map\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar errors_1 = __webpack_require__(5);\nvar util_1 = __webpack_require__(6);\nvar arena_allocation_result_1 = __webpack_require__(19);\nvar arena_kind_1 = __webpack_require__(11);\nvar trace = debug_1.default('capnp:arena:single');\ntrace('load');\nvar SingleSegmentArena = /** @class */ (function () {\n    function SingleSegmentArena(buffer) {\n        if (buffer === void 0) { buffer = new ArrayBuffer(constants_1.DEFAULT_BUFFER_SIZE); }\n        this.kind = arena_kind_1.ArenaKind.SINGLE_SEGMENT;\n        if ((buffer.byteLength & 7) !== 0)\n            throw new Error(util_1.format(errors_1.SEG_NOT_WORD_ALIGNED, buffer.byteLength));\n        this.buffer = buffer;\n        trace('new %s', this);\n    }\n    SingleSegmentArena.prototype.toString = function () { return util_1.format('SingleSegmentArena_len:%x', this.buffer.byteLength); };\n    SingleSegmentArena.allocate = allocate;\n    SingleSegmentArena.getBuffer = getBuffer;\n    SingleSegmentArena.getNumSegments = getNumSegments;\n    return SingleSegmentArena;\n}());\nexports.SingleSegmentArena = SingleSegmentArena;\nfunction allocate(minSize, segments, s) {\n    trace('Allocating %x bytes for segment 0 in %s.', minSize, s);\n    var srcBuffer = segments.length > 0 ? segments[0].buffer : s.buffer;\n    if (minSize < constants_1.MIN_SINGLE_SEGMENT_GROWTH) {\n        minSize = constants_1.MIN_SINGLE_SEGMENT_GROWTH;\n    }\n    else {\n        minSize = util_1.padToWord(minSize);\n    }\n    s.buffer = new ArrayBuffer(srcBuffer.byteLength + minSize);\n    // PERF: Assume that the source and destination buffers are word-aligned and use Float64Array to copy them one word\n    // at a time.\n    new Float64Array(s.buffer).set(new Float64Array(srcBuffer));\n    return new arena_allocation_result_1.ArenaAllocationResult(0, s.buffer);\n}\nexports.allocate = allocate;\nfunction getBuffer(id, s) {\n    if (id !== 0)\n        throw new Error(util_1.format(errors_1.SEG_GET_NON_ZERO_SINGLE, id));\n    return s.buffer;\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments() {\n    return 1;\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=single-segment-arena.js.map\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar errors_1 = __webpack_require__(5);\nvar util_1 = __webpack_require__(6);\nvar list_element_size_1 = __webpack_require__(3);\nvar object_size_1 = __webpack_require__(8);\nvar pointer_1 = __webpack_require__(1);\nvar pointer_type_1 = __webpack_require__(9);\nvar trace = debug_1.default('capnp:orphan');\ntrace('load');\n// Technically speaking this class doesn't need to be generic, but the extra type checking enforced by this helps to\n// make sure you don't accidentally adopt a pointer of the wrong type.\n/**\n * An orphaned pointer. This object itself is technically a pointer to the original pointer's content, which was left\n * untouched in its original message. The original pointer data is encoded as attributes on the Orphan object, ready to\n * be reconstructed once another pointer is ready to adopt it.\n *\n * @export\n * @class Orphan\n * @extends {Pointer}\n * @template T\n */\nvar Orphan = /** @class */ (function () {\n    function Orphan(src) {\n        var c = pointer_1.getContent(src);\n        this.segment = c.segment;\n        this.byteOffset = c.byteOffset;\n        this._capnp = {};\n        // Read vital info from the src pointer so we can reconstruct it during adoption.\n        this._capnp.type = pointer_1.getTargetPointerType(src);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this._capnp.size = pointer_1.getTargetStructSize(src);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                this._capnp.length = pointer_1.getTargetListLength(src);\n                this._capnp.elementSize = pointer_1.getTargetListElementSize(src);\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE)\n                    this._capnp.size = pointer_1.getTargetCompositeListSize(src);\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                this._capnp.capId = pointer_1.getCapabilityId(src);\n                break;\n            default:\n                // COVERAGE: Unreachable code.\n                /* istanbul ignore next */\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        // Zero out the source pointer (but not the contents!).\n        pointer_1.erasePointer(src);\n    }\n    /**\n     * Adopt (move) this orphan into the target pointer location. This will allocate far pointers in `dst` as needed.\n     *\n     * @param {T} dst The destination pointer.\n     * @returns {void}\n     */\n    Orphan.prototype._moveTo = function (dst) {\n        if (this._capnp === undefined)\n            throw new Error(util_1.format(errors_1.PTR_ALREADY_ADOPTED, this));\n        // TODO: Implement copy semantics when this happens.\n        if (this.segment.message !== dst.segment.message)\n            throw new Error(util_1.format(errors_1.PTR_ADOPT_WRONG_MESSAGE, this, dst));\n        // Recursively wipe out the destination pointer first.\n        pointer_1.erase(dst);\n        var res = pointer_1.initPointer(this.segment, this.byteOffset, dst);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                pointer_1.setStructPointer(res.offsetWords, this._capnp.size, res.pointer);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var offsetWords = res.offsetWords;\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE)\n                    offsetWords--; // The tag word gets skipped.\n                pointer_1.setListPointer(offsetWords, this._capnp.elementSize, this._capnp.length, res.pointer, this._capnp.size);\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                pointer_1.setInterfacePointer(this._capnp.capId, res.pointer);\n                break;\n            /* istanbul ignore next */\n            default:\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.dispose = function () {\n        // FIXME: Should this throw?\n        if (this._capnp === undefined) {\n            trace('not disposing an already disposed orphan', this);\n            return;\n        }\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this.segment.fillZeroWords(this.byteOffset, object_size_1.getWordLength(this._capnp.size));\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var byteLength = pointer_1.getListByteLength(this._capnp.elementSize, this._capnp.length, this._capnp.size);\n                this.segment.fillZeroWords(this.byteOffset, byteLength);\n                break;\n            default:\n                // Other pointer types don't actually have any content.\n                break;\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.toString = function () {\n        return util_1.format('Orphan_%d@%a,type:%s', this.segment.id, this.byteOffset, this._capnp && this._capnp.type);\n    };\n    return Orphan;\n}());\nexports.Orphan = Orphan;\n\n//# sourceMappingURL=orphan.js.map\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar constants_1 = __webpack_require__(7);\nvar errors_1 = __webpack_require__(5);\nvar util_1 = __webpack_require__(6);\nvar pointer_1 = __webpack_require__(1);\nvar Interface = /** @class */ (function (_super) {\n    tslib_1.__extends(Interface, _super);\n    function Interface(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, 'new Interface'));\n        return _this;\n    }\n    return Interface;\n}(pointer_1.Pointer));\nexports.Interface = Interface;\n\n//# sourceMappingURL=interface.js.map\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar errors_1 = __webpack_require__(5);\nvar util_1 = __webpack_require__(6);\nvar trace = debug_1.default('capnp:uint64');\ntrace('load');\n/**\n * Represents an unsigned 64-bit integer stored using a Uint8Array in little-endian format. It's a little bit faster\n * than int64 because we don't need to keep track of the sign bit or perform two's compliment operations on set.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * Note that overflow is not implemented, so negative numbers passed into `setValue()` will be negated first.\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Uint64 = /** @class */ (function () {\n    /**\n     * Creates a new instance; this is a no-frills constructor for speed. Use the factory methods if you need to convert\n     * from other types or use a different offset into the buffer.\n     *\n     * Will throw if the buffer is not at least 8 bytes long.\n     *\n     * @constructor\n     * @param {Uint8Array} buffer The buffer to use for this 64-bit word; the bytes must be in little-endian order.\n     */\n    function Uint64(buffer) {\n        if (buffer.byteLength < 8)\n            throw new RangeError(errors_1.RANGE_INT64_UNDERFLOW);\n        this.buffer = buffer;\n    }\n    Uint64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Uint64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as a Uint64 value.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Uint64} The string parsed as a 64-bit unsigned integer.\n     */\n    Uint64.fromHexString = function (source) {\n        if (source.substr(0, 2) === '0x')\n            source = source.substr(2);\n        if (source.length < 1)\n            return Uint64.fromNumber(0);\n        if (source[0] === '-')\n            throw new RangeError('Source must not be negative.');\n        source = util_1.pad(source, 16);\n        if (source.length !== 16)\n            throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++)\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        return new Uint64(buf);\n    };\n    Uint64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    Uint64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Uint64.prototype.equals = function (other) {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== other.buffer[i])\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.inspect = function () {\n        return \"[Uint64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    /**\n     * Faster way to check for zero values without converting to a number first.\n     *\n     * @returns {boolean} `true` if the contained value is zero.\n     * @memberOf Uint64\n     */\n    Uint64.prototype.isZero = function () {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== 0)\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.setValue = function (loWord, hiWord) {\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Uint64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Uint64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var x = 0;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace('Coercing out of range value %d to Infinity.', x);\n            return Infinity;\n        }\n        return x;\n    };\n    Uint64.prototype.valueOf = function () {\n        return this.toNumber(false);\n    };\n    Uint64.prototype.toArrayBuffer = function () {\n        return this.buffer.buffer;\n    };\n    Uint64.prototype.toDataView = function () {\n        return new DataView(this.buffer.buffer);\n    };\n    Uint64.prototype.toHexString = function () {\n        var hex = '';\n        for (var i = 7; i >= 0; i--) {\n            var v = this.buffer[i].toString(16);\n            if (v.length === 1)\n                v = '0' + v;\n            hex += v;\n        }\n        return hex;\n    };\n    Uint64.prototype.toString = function (radix) {\n        return this.toNumber(true).toString(radix);\n    };\n    Uint64.prototype.toUint8Array = function () {\n        return this.buffer;\n    };\n    return Uint64;\n}());\nexports.Uint64 = Uint64;\n\n//# sourceMappingURL=uint64.js.map\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar object_size_1 = __webpack_require__(8);\nvar struct_1 = __webpack_require__(15);\nvar Void = /** @class */ (function (_super) {\n    tslib_1.__extends(Void, _super);\n    function Void() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Void._capnp = {\n        displayName: 'Void',\n        id: '0',\n        size: new object_size_1.ObjectSize(0, 0),\n    };\n    return Void;\n}(struct_1.Struct));\nexports.Void = Void;\n// This following line makes a mysterious \"whooshing\" sound when it runs.\nexports.VOID = undefined;\n\n//# sourceMappingURL=void.js.map\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__capnp_cupr_capnp__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_capnp_ts__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_capnp_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_capnp_ts__);\n\n\nvar ctx = self;\nfunction parseDim3(dim) {\n    return {\n        x: dim.getX(),\n        y: dim.getY(),\n        z: dim.getZ()\n    };\n}\nctx.onmessage = function (message) {\n    var payload = new __WEBPACK_IMPORTED_MODULE_1_capnp_ts__[\"Message\"](message.data, true);\n    var trace = payload.getRoot(__WEBPACK_IMPORTED_MODULE_0__capnp_cupr_capnp__[\"a\" /* Trace */]);\n    var parsed = {\n        type: trace.getType(),\n        kernel: trace.getKernel(),\n        start: trace.getStart(),\n        end: trace.getEnd(),\n        warps: trace.getWarps().map(function (warp) { return ({\n            accesses: warp.getAccesses().map(function (access) { return ({\n                threadIdx: parseDim3(access.getThreadIdx()),\n                address: access.getAddress(),\n                value: access.getValue()\n            }); }),\n            blockIdx: parseDim3(warp.getBlockIdx()),\n            warpId: warp.getWarpId(),\n            debugId: warp.getDebugId(),\n            size: warp.getSize(),\n            kind: warp.getKind(),\n            space: warp.getSpace(),\n            typeIndex: warp.getTypeIndex(),\n            timestamp: warp.getTimestamp()\n        }); }),\n        allocations: trace.getAllocations().map(function (alloc) { return ({\n            address: alloc.getAddress(),\n            size: alloc.getSize().toNumber(),\n            elementSize: alloc.getElementSize(),\n            space: alloc.getSpace(),\n            typeIndex: alloc.getTypeIndex(),\n            typeString: alloc.getTypeString(),\n            active: alloc.getActive(),\n            nameIndex: alloc.getNameIndex(),\n            nameString: alloc.getNameString(),\n            location: alloc.getLocation()\n        }); }),\n        gridDim: parseDim3(trace.getGridDim()),\n        blockDim: parseDim3(trace.getBlockDim()),\n        warpSize: trace.getWarpSize(),\n        bankSize: trace.getBankSize()\n    };\n    ctx.postMessage(parsed);\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = ({});\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export _capnpFileId */\n/* unused harmony export Dim3 */\n/* unused harmony export MemoryAccess */\n/* unused harmony export Warp */\n/* unused harmony export AllocRecord */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Trace; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_capnp_ts__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_capnp_ts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__);\n/**\n * This file has been automatically generated by the [capnpc-ts utility](https://github.com/jdiaz5513/capnp-ts).\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/* tslint:disable */\n\n\nvar _capnpFileId = \"db50473b24db4f29\";\nvar Dim3 = /** @class */ (function (_super) {\n    __extends(Dim3, _super);\n    function Dim3() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Dim3.prototype.getX = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getInt32(0, this); };\n    Dim3.prototype.setX = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setInt32(0, value, this); };\n    Dim3.prototype.getY = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getInt32(4, this); };\n    Dim3.prototype.setY = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setInt32(4, value, this); };\n    Dim3.prototype.getZ = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getInt32(8, this); };\n    Dim3.prototype.setZ = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setInt32(8, value, this); };\n    Dim3.prototype.toString = function () { return \"Dim3_\" + _super.prototype.toString.call(this); };\n    Dim3._capnp = { displayName: \"Dim3\", id: \"87bddb55c89457c5\", size: new __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"ObjectSize\"](16, 0) };\n    return Dim3;\n}(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"]));\n\nvar MemoryAccess = /** @class */ (function (_super) {\n    __extends(MemoryAccess, _super);\n    function MemoryAccess() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MemoryAccess.prototype.adoptThreadIdx = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].adopt(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(0, this)); };\n    MemoryAccess.prototype.disownThreadIdx = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].disown(this.getThreadIdx()); };\n    MemoryAccess.prototype.getThreadIdx = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getStruct(0, Dim3, this); };\n    MemoryAccess.prototype.hasThreadIdx = function () { return !__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].isNull(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(0, this)); };\n    MemoryAccess.prototype.initThreadIdx = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].initStructAt(0, Dim3, this); };\n    MemoryAccess.prototype.setThreadIdx = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].copyFrom(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(0, this)); };\n    MemoryAccess.prototype.getAddress = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getText(1, this); };\n    MemoryAccess.prototype.setAddress = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setText(1, value, this); };\n    MemoryAccess.prototype.getValue = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getText(2, this); };\n    MemoryAccess.prototype.setValue = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setText(2, value, this); };\n    MemoryAccess.prototype.toString = function () { return \"MemoryAccess_\" + _super.prototype.toString.call(this); };\n    MemoryAccess._capnp = { displayName: \"MemoryAccess\", id: \"d678722a813fdd16\", size: new __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"ObjectSize\"](0, 3) };\n    return MemoryAccess;\n}(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"]));\n\nvar Warp = /** @class */ (function (_super) {\n    __extends(Warp, _super);\n    function Warp() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Warp.prototype.adoptAccesses = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].adopt(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(0, this)); };\n    Warp.prototype.disownAccesses = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].disown(this.getAccesses()); };\n    Warp.prototype.getAccesses = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getList(0, Warp._Accesses, this); };\n    Warp.prototype.hasAccesses = function () { return !__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].isNull(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(0, this)); };\n    Warp.prototype.initAccesses = function (length) { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].initList(0, Warp._Accesses, length, this); };\n    Warp.prototype.setAccesses = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].copyFrom(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(0, this)); };\n    Warp.prototype.adoptBlockIdx = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].adopt(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(1, this)); };\n    Warp.prototype.disownBlockIdx = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].disown(this.getBlockIdx()); };\n    Warp.prototype.getBlockIdx = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getStruct(1, Dim3, this); };\n    Warp.prototype.hasBlockIdx = function () { return !__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].isNull(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(1, this)); };\n    Warp.prototype.initBlockIdx = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].initStructAt(1, Dim3, this); };\n    Warp.prototype.setBlockIdx = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].copyFrom(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(1, this)); };\n    Warp.prototype.getWarpId = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getInt32(0, this); };\n    Warp.prototype.setWarpId = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setInt32(0, value, this); };\n    Warp.prototype.getDebugId = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getInt32(4, this); };\n    Warp.prototype.setDebugId = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setInt32(4, value, this); };\n    Warp.prototype.getSize = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getUint8(8, this); };\n    Warp.prototype.setSize = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setUint8(8, value, this); };\n    Warp.prototype.getKind = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getUint8(9, this); };\n    Warp.prototype.setKind = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setUint8(9, value, this); };\n    Warp.prototype.getSpace = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getUint8(10, this); };\n    Warp.prototype.setSpace = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setUint8(10, value, this); };\n    Warp.prototype.getTypeIndex = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getInt32(12, this); };\n    Warp.prototype.setTypeIndex = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setInt32(12, value, this); };\n    Warp.prototype.getTimestamp = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getText(2, this); };\n    Warp.prototype.setTimestamp = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setText(2, value, this); };\n    Warp.prototype.toString = function () { return \"Warp_\" + _super.prototype.toString.call(this); };\n    Warp._capnp = { displayName: \"Warp\", id: \"dbf542119910200f\", size: new __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"ObjectSize\"](16, 3) };\n    return Warp;\n}(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"]));\n\nvar AllocRecord = /** @class */ (function (_super) {\n    __extends(AllocRecord, _super);\n    function AllocRecord() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AllocRecord.prototype.getAddress = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getText(0, this); };\n    AllocRecord.prototype.setAddress = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setText(0, value, this); };\n    AllocRecord.prototype.getSize = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getUint64(0, this); };\n    AllocRecord.prototype.setSize = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setUint64(0, value, this); };\n    AllocRecord.prototype.getElementSize = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getUint32(8, this); };\n    AllocRecord.prototype.setElementSize = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setUint32(8, value, this); };\n    AllocRecord.prototype.getSpace = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getUint8(12, this); };\n    AllocRecord.prototype.setSpace = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setUint8(12, value, this); };\n    AllocRecord.prototype.getTypeIndex = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getInt32(16, this); };\n    AllocRecord.prototype.setTypeIndex = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setInt32(16, value, this); };\n    AllocRecord.prototype.getTypeString = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getText(1, this); };\n    AllocRecord.prototype.setTypeString = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setText(1, value, this); };\n    AllocRecord.prototype.getNameIndex = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getInt32(20, this); };\n    AllocRecord.prototype.setNameIndex = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setInt32(20, value, this); };\n    AllocRecord.prototype.getNameString = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getText(2, this); };\n    AllocRecord.prototype.setNameString = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setText(2, value, this); };\n    AllocRecord.prototype.getLocation = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getText(3, this); };\n    AllocRecord.prototype.setLocation = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setText(3, value, this); };\n    AllocRecord.prototype.getActive = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getBit(104, this); };\n    AllocRecord.prototype.setActive = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setBit(104, value, this); };\n    AllocRecord.prototype.toString = function () { return \"AllocRecord_\" + _super.prototype.toString.call(this); };\n    AllocRecord._capnp = { displayName: \"AllocRecord\", id: \"f01eee9ad5904e3a\", size: new __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"ObjectSize\"](24, 4) };\n    return AllocRecord;\n}(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"]));\n\nvar Trace = /** @class */ (function (_super) {\n    __extends(Trace, _super);\n    function Trace() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Trace.prototype.adoptWarps = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].adopt(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(0, this)); };\n    Trace.prototype.disownWarps = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].disown(this.getWarps()); };\n    Trace.prototype.getWarps = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getList(0, Trace._Warps, this); };\n    Trace.prototype.hasWarps = function () { return !__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].isNull(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(0, this)); };\n    Trace.prototype.initWarps = function (length) { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].initList(0, Trace._Warps, length, this); };\n    Trace.prototype.setWarps = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].copyFrom(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(0, this)); };\n    Trace.prototype.adoptAllocations = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].adopt(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(1, this)); };\n    Trace.prototype.disownAllocations = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].disown(this.getAllocations()); };\n    Trace.prototype.getAllocations = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getList(1, Trace._Allocations, this); };\n    Trace.prototype.hasAllocations = function () { return !__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].isNull(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(1, this)); };\n    Trace.prototype.initAllocations = function (length) { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].initList(1, Trace._Allocations, length, this); };\n    Trace.prototype.setAllocations = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].copyFrom(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(1, this)); };\n    Trace.prototype.getKernel = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getText(2, this); };\n    Trace.prototype.setKernel = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setText(2, value, this); };\n    Trace.prototype.getStart = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getFloat64(0, this); };\n    Trace.prototype.setStart = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setFloat64(0, value, this); };\n    Trace.prototype.getEnd = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getFloat64(8, this); };\n    Trace.prototype.setEnd = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setFloat64(8, value, this); };\n    Trace.prototype.getType = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getText(3, this); };\n    Trace.prototype.setType = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setText(3, value, this); };\n    Trace.prototype.adoptGridDim = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].adopt(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(4, this)); };\n    Trace.prototype.disownGridDim = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].disown(this.getGridDim()); };\n    Trace.prototype.getGridDim = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getStruct(4, Dim3, this); };\n    Trace.prototype.hasGridDim = function () { return !__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].isNull(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(4, this)); };\n    Trace.prototype.initGridDim = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].initStructAt(4, Dim3, this); };\n    Trace.prototype.setGridDim = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].copyFrom(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(4, this)); };\n    Trace.prototype.adoptBlockDim = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].adopt(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(5, this)); };\n    Trace.prototype.disownBlockDim = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].disown(this.getBlockDim()); };\n    Trace.prototype.getBlockDim = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getStruct(5, Dim3, this); };\n    Trace.prototype.hasBlockDim = function () { return !__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].isNull(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(5, this)); };\n    Trace.prototype.initBlockDim = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].initStructAt(5, Dim3, this); };\n    Trace.prototype.setBlockDim = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].copyFrom(value, __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getPointer(5, this)); };\n    Trace.prototype.getWarpSize = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getUint32(16, this); };\n    Trace.prototype.setWarpSize = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setUint32(16, value, this); };\n    Trace.prototype.getBankSize = function () { return __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].getUint32(20, this); };\n    Trace.prototype.setBankSize = function (value) { __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"].setUint32(20, value, this); };\n    Trace.prototype.toString = function () { return \"Trace_\" + _super.prototype.toString.call(this); };\n    Trace._capnp = { displayName: \"Trace\", id: \"e9cd0a553d9f75a8\", size: new __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"ObjectSize\"](24, 6) };\n    return Trace;\n}(__WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"Struct\"]));\n\nWarp._Accesses = __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"CompositeList\"](MemoryAccess);\nTrace._Warps = __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"CompositeList\"](Warp);\nTrace._Allocations = __WEBPACK_IMPORTED_MODULE_0_capnp_ts__[\"CompositeList\"](AllocRecord);\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\ntslib_1.__exportStar(__webpack_require__(28), exports);\nvar list_element_size_1 = __webpack_require__(3);\nexports.ListElementSize = list_element_size_1.ListElementSize;\nvar message_1 = __webpack_require__(29);\nexports.Message = message_1.Message;\nvar object_size_1 = __webpack_require__(8);\nexports.ObjectSize = object_size_1.ObjectSize;\ntslib_1.__exportStar(__webpack_require__(13), exports);\n\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction _makePrimitiveMaskFn(byteLength, setter) {\n    return function (x) {\n        var dv = new DataView(new ArrayBuffer(byteLength));\n        setter.call(dv, 0, x, true);\n        return dv;\n    };\n}\n/* tslint:disable:no-unsafe-any */\nexports.getFloat32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setFloat32);\nexports.getFloat64Mask = _makePrimitiveMaskFn(8, DataView.prototype.setFloat64);\nexports.getInt16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setInt16);\nexports.getInt32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setInt32);\nexports.getInt8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setInt8);\nexports.getUint16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setUint16);\nexports.getUint32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setUint32);\nexports.getUint8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setUint8);\n/* tslint:enable:no-unsafe-any */\nfunction getBitMask(value, bitOffset) {\n    var dv = new DataView(new ArrayBuffer(1));\n    if (!value)\n        return dv;\n    dv.setUint8(0, 1 << bitOffset % 8);\n    return dv;\n}\nexports.getBitMask = getBitMask;\nfunction getInt64Mask(x) {\n    return x.toDataView();\n}\nexports.getInt64Mask = getInt64Mask;\nfunction getUint64Mask(x) {\n    return x.toDataView();\n}\nexports.getUint64Mask = getUint64Mask;\n\n//# sourceMappingURL=mask.js.map\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar errors_1 = __webpack_require__(5);\nvar util_1 = __webpack_require__(6);\nvar arena_1 = __webpack_require__(33);\nvar packing_1 = __webpack_require__(35);\nvar pointers_1 = __webpack_require__(13);\nvar segment_1 = __webpack_require__(55);\nvar pointer_1 = __webpack_require__(1);\nvar struct_1 = __webpack_require__(15);\nvar trace = debug_1.default('capnp:message');\ntrace('load');\nvar Message = /** @class */ (function () {\n    /**\n     * A Cap'n Proto message.\n     *\n     * SECURITY WARNING: In nodejs do not pass a Buffer's internal array buffer into this constructor. Pass the buffer\n     * directly and everything will be fine. If not, your message will potentially be initialized with random memory\n     * contents!\n     *\n     * The constructor method creates a new Message, optionally using a provided arena for segment allocation, or a buffer\n     * to read from.\n     *\n     * @constructor {Message}\n     *\n     * @param {AnyArena|ArrayBufferView|ArrayBuffer} [src] The source for the message.\n     * A value of `undefined` will cause the message to initialize with a single segment arena only big enough for the\n     * root pointer; it will expand as you go. This is a reasonable choice for most messages.\n     *\n     * Passing an arena will cause the message to use that arena for its segment allocation. Contents will be accepted\n     * as-is.\n     *\n     * Passing an array buffer view (like `DataView`, `Uint8Array` or `Buffer`) will create a **copy** of the source\n     * buffer; beware of the potential performance cost!\n     *\n     * @param {boolean} [packed] Whether or not the message is packed. If `true` (the default), the message will be\n     * unpacked.\n     *\n     * @param {boolean} [singleSegment] If true, `src` will be treated as a message consisting of a single segment without\n     * a framing header.\n     *\n     */\n    function Message(src, packed, singleSegment) {\n        if (packed === void 0) { packed = true; }\n        if (singleSegment === void 0) { singleSegment = false; }\n        this._capnp = initMessage(src, packed, singleSegment);\n        if (src && !isAnyArena(src))\n            preallocateSegments(this);\n        trace('new %s', this);\n    }\n    Message.prototype.allocateSegment = function (byteLength) { return allocateSegment(byteLength, this); };\n    /**\n     * Create a pretty-printed string dump of this message; incredibly useful for debugging.\n     *\n     * WARNING: Do not call this method on large messages!\n     *\n     * @returns {string} A big steaming pile of pretty hex digits.\n     */\n    Message.prototype.dump = function () { return dump(this); };\n    /**\n     * Get a struct pointer for the root of this message. This is primarily used when reading a message; it will not\n     * overwrite existing data.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} A struct representing the root of the message.\n     */\n    Message.prototype.getRoot = function (RootStruct) { return getRoot(RootStruct, this); };\n    /**\n     * Get a segment by its id.\n     *\n     * This will lazily allocate the first segment if it doesn't already exist.\n     *\n     * @param {number} id The segment id.\n     * @returns {Segment} The requested segment.\n     */\n    Message.prototype.getSegment = function (id) { return getSegment(id, this); };\n    /**\n     * Initialize a new message using the provided struct type as the root.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} An initialized struct pointing to the root of the message.\n     */\n    Message.prototype.initRoot = function (RootStruct) { return initRoot(RootStruct, this); };\n    /**\n     * Combine the contents of this message's segments into a single array buffer and prepend a stream framing header\n     * containing information about the following segment data.\n     *\n     * @returns {ArrayBuffer} An ArrayBuffer with the contents of this message.\n     */\n    Message.prototype.toArrayBuffer = function () { return toArrayBuffer(this); };\n    /**\n     * Like `toArrayBuffer()`, but also applies the packing algorithm to the output. This is typically what you want to\n     * use if you're sending the message over a network link or other slow I/O interface where size matters.\n     *\n     * @returns {ArrayBuffer} A packed message.\n     */\n    Message.prototype.toPackedArrayBuffer = function () { return toPackedArrayBuffer(this); };\n    Message.prototype.toString = function () { return \"Message_arena:\" + this._capnp.arena; };\n    Message.allocateSegment = allocateSegment;\n    Message.dump = dump;\n    Message.getRoot = getRoot;\n    Message.getSegment = getSegment;\n    Message.initRoot = initRoot;\n    Message.toArrayBuffer = toArrayBuffer;\n    Message.toPackedArrayBuffer = toPackedArrayBuffer;\n    return Message;\n}());\nexports.Message = Message;\nfunction initMessage(src, packed, singleSegment) {\n    if (packed === void 0) { packed = true; }\n    if (singleSegment === void 0) { singleSegment = false; }\n    if (src === undefined) {\n        return { arena: new arena_1.SingleSegmentArena(), segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };\n    }\n    if (isAnyArena(src))\n        return { arena: src, segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };\n    var buf = src;\n    if (isArrayBufferView(buf))\n        buf = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    if (packed)\n        buf = packing_1.unpack(buf);\n    if (singleSegment) {\n        return {\n            arena: new arena_1.SingleSegmentArena(buf),\n            segments: [],\n            traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,\n        };\n    }\n    return {\n        arena: new arena_1.MultiSegmentArena(getFramedSegments(buf)),\n        segments: [],\n        traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,\n    };\n}\nexports.initMessage = initMessage;\n/**\n * Given an _unpacked_ message with a segment framing header, this will generate an ArrayBuffer for each segment in\n * the message.\n *\n * This method is not typically called directly, but can be useful in certain cases.\n *\n * @static\n * @param {ArrayBuffer} message An unpacked message with a framing header.\n * @returns {ArrayBuffer[]} An array of buffers containing the segment data.\n */\nfunction getFramedSegments(message) {\n    var dv = new DataView(message);\n    var segmentCount = dv.getUint32(0, true) + 1;\n    var segments = new Array(segmentCount);\n    trace('reading %d framed segments from stream', segmentCount);\n    var byteOffset = 4 + segmentCount * 4;\n    byteOffset += byteOffset % 8;\n    if (byteOffset + segmentCount * 4 > message.byteLength)\n        throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n    for (var i = 0; i < segmentCount; i++) {\n        var byteLength = dv.getUint32(4 + i * 4, true) * 8;\n        if (byteOffset + byteLength > message.byteLength)\n            throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n        segments[i] = message.slice(byteOffset, byteOffset + byteLength);\n        byteOffset += byteLength;\n    }\n    return segments;\n}\nexports.getFramedSegments = getFramedSegments;\n/**\n * This method is called on messages that were constructed with existing data to prepopulate the segments array with\n * everything we can find in the arena. Each segment will have it's `byteLength` set to the size of its buffer.\n *\n * Technically speaking, the message's segments will be \"full\" after calling this function. Calling this on your own\n * may void your warranty.\n *\n * @param {Message} m The message to allocate.\n * @returns {void}\n */\nfunction preallocateSegments(m) {\n    var numSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n    if (numSegments < 1)\n        throw new Error(errors_1.MSG_NO_SEGMENTS_IN_ARENA);\n    m._capnp.segments = new Array(numSegments);\n    for (var i = 0; i < numSegments; i++) {\n        // Set up each segment so that they're fully allocated to the extents of the existing buffers.\n        var buffer = arena_1.Arena.getBuffer(i, m._capnp.arena);\n        var segment = new segment_1.Segment(i, m, buffer, buffer.byteLength);\n        m._capnp.segments[i] = segment;\n    }\n}\nexports.preallocateSegments = preallocateSegments;\nfunction isArrayBufferView(src) {\n    return src.byteOffset !== undefined;\n}\nfunction isAnyArena(o) {\n    return o.kind !== undefined;\n}\nfunction allocateSegment(byteLength, m) {\n    trace('allocating %x bytes for %s', byteLength, m);\n    var res = arena_1.Arena.allocate(byteLength, m._capnp.segments, m._capnp.arena);\n    var s;\n    if (res.id === m._capnp.segments.length) {\n        // Note how we're only allowing new segments in if they're exactly the next one in the array. There is no logical\n        // reason for segments to be created out of order.\n        s = new segment_1.Segment(res.id, m, res.buffer);\n        trace('adding new segment %s', s);\n        m._capnp.segments.push(s);\n    }\n    else if (res.id < 0 || res.id > m._capnp.segments.length) {\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, res.id, m));\n    }\n    else {\n        s = m._capnp.segments[res.id];\n        trace('replacing segment %s with buffer (len:%d)', s, res.buffer.byteLength);\n        s.replaceBuffer(res.buffer);\n    }\n    return s;\n}\nexports.allocateSegment = allocateSegment;\nfunction dump(m) {\n    var r = '';\n    if (m._capnp.segments.length === 0)\n        return '================\\nNo Segments\\n================\\n';\n    for (var i = 0; i < m._capnp.segments.length; i++) {\n        r += \"================\\nSegment #\" + i + \"\\n================\\n\";\n        var _a = m._capnp.segments[i], buffer = _a.buffer, byteLength = _a.byteLength;\n        var b = new Uint8Array(buffer, 0, byteLength);\n        r += util_1.dumpBuffer(b);\n    }\n    return r;\n}\nexports.dump = dump;\nfunction getRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    pointer_1.validate(pointers_1.PointerType.STRUCT, root);\n    var ts = pointer_1.getTargetStructSize(root);\n    // Make sure the underlying pointer is actually big enough to hold the data and pointers as specified in the schema.\n    // If not a shallow copy of the struct contents needs to be made before returning.\n    if (ts.dataByteLength < RootStruct._capnp.size.dataByteLength\n        || ts.pointerLength < RootStruct._capnp.size.pointerLength) {\n        trace('need to resize root struct %s', root);\n        struct_1.resize(RootStruct._capnp.size, root);\n    }\n    return root;\n}\nexports.getRoot = getRoot;\nfunction getSegment(id, m) {\n    var segmentLength = m._capnp.segments.length;\n    if (id === 0 && segmentLength === 0) {\n        // Segment zero is special. If we have no segments in the arena we'll want to allocate a new one and leave room\n        // for the root pointer.\n        var arenaSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n        if (arenaSegments === 0) {\n            allocateSegment(constants_1.DEFAULT_BUFFER_SIZE, m);\n        }\n        else {\n            // Okay, the arena already has a buffer we can use. This is totally fine.\n            m._capnp.segments[0] = new segment_1.Segment(0, m, arena_1.Arena.getBuffer(0, m._capnp.arena));\n        }\n        if (!m._capnp.segments[0].hasCapacity(8))\n            throw new Error(errors_1.MSG_SEGMENT_TOO_SMALL);\n        // This will leave room for the root pointer.\n        m._capnp.segments[0].allocate(8);\n        return m._capnp.segments[0];\n    }\n    if (id < 0 || id >= segmentLength)\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, id, m));\n    return m._capnp.segments[id];\n}\nexports.getSegment = getSegment;\nfunction initRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    struct_1.initStruct(RootStruct._capnp.size, root);\n    trace('Initialized root pointer %s for %s.', root, m);\n    return root;\n}\nexports.initRoot = initRoot;\nfunction toArrayBuffer(m) {\n    var streamFrame = getStreamFrame(m);\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        getSegment(0, m);\n    var segments = m._capnp.segments;\n    // Add space for the stream framing.\n    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + util_1.padToWord(s.byteLength); }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        var segmentLength = util_1.padToWord(s.byteLength);\n        out.set(new Uint8Array(s.buffer, 0, segmentLength), o);\n        o += segmentLength;\n    });\n    return out.buffer;\n}\nexports.toArrayBuffer = toArrayBuffer;\nfunction toPackedArrayBuffer(m) {\n    var streamFrame = packing_1.pack(getStreamFrame(m));\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        m.getSegment(0);\n    // NOTE: A copy operation can be avoided here if we capture the intermediate array and use that directly in the copy\n    // loop below, rather than have `pack()` copy it to an ArrayBuffer just to have to copy it again later. If the\n    // intermediate array can be avoided altogether that's even better!\n    var segments = m._capnp.segments.map(function (s) { return packing_1.pack(s.buffer, 0, util_1.padToWord(s.byteLength)); });\n    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + s.byteLength; }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        out.set(new Uint8Array(s), o);\n        o += s.byteLength;\n    });\n    return out.buffer;\n}\nexports.toPackedArrayBuffer = toPackedArrayBuffer;\nfunction getStreamFrame(m) {\n    var length = m._capnp.segments.length;\n    if (length === 0) {\n        // Don't bother allocating the first segment, just return a single zero word for the frame header.\n        return new Float64Array(1).buffer;\n    }\n    var frameLength = 4 + length * 4 + (1 - length % 2) * 4;\n    var out = new DataView(new ArrayBuffer(frameLength));\n    trace('Writing message stream frame with segment count: %d.', length);\n    out.setUint32(0, length - 1, true);\n    m._capnp.segments.forEach(function (s, i) {\n        trace('Message segment %d word count: %d.', s.id, s.byteLength / 8);\n        out.setUint32(i * 4 + 4, s.byteLength / 8, true);\n    });\n    return out.buffer;\n}\nexports.getStreamFrame = getStreamFrame;\n\n//# sourceMappingURL=message.js.map\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(32);\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arena_1 = __webpack_require__(34);\nexports.Arena = arena_1.Arena;\nvar arena_kind_1 = __webpack_require__(11);\nexports.ArenaKind = arena_kind_1.ArenaKind;\nvar multi_segment_arena_1 = __webpack_require__(18);\nexports.MultiSegmentArena = multi_segment_arena_1.MultiSegmentArena;\nvar single_segment_arena_1 = __webpack_require__(20);\nexports.SingleSegmentArena = single_segment_arena_1.SingleSegmentArena;\n\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar errors_1 = __webpack_require__(5);\nvar arena_kind_1 = __webpack_require__(11);\nvar multi_segment_arena_1 = __webpack_require__(18);\nvar single_segment_arena_1 = __webpack_require__(20);\nvar trace = debug_1.default('capnp:arena');\ntrace('load');\nvar Arena = /** @class */ (function () {\n    function Arena() {\n    }\n    Arena.allocate = allocate;\n    Arena.getBuffer = getBuffer;\n    Arena.getNumSegments = getNumSegments;\n    return Arena;\n}());\nexports.Arena = Arena;\nfunction allocate(minSize, segments, a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.allocate(minSize, a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.allocate(minSize, segments, a);\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.allocate = allocate;\nfunction getBuffer(id, a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.getBuffer(id, a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.getBuffer(id, a);\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments(a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.getNumSegments(a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.getNumSegments();\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=arena.js.map\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = __webpack_require__(7);\nvar errors_1 = __webpack_require__(5);\n/**\n * Compute the Hamming weight (number of bits set to 1) of a number. Used to figure out how many bytes follow a tag byte\n * while computing the size of a packed message.\n *\n * WARNING: Using this with floating point numbers will void your warranty.\n *\n * @param {number} x A real integer.\n * @returns {number} The hamming weight (integer).\n */\nfunction getHammingWeight(x) {\n    // Thanks, HACKMEM!\n    var w = x - ((x >> 1) & 0x55555555);\n    w = (w & 0x33333333) + ((w >> 2) & 0x33333333);\n    return ((w + (w >> 4) & 0x0f0f0f0f) * 0x01010101) >> 24;\n}\nexports.getHammingWeight = getHammingWeight;\n/**\n * Compute the tag byte from the 8 bytes of a 64-bit word.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The tag byte.\n */\nfunction getTagByte(a, b, c, d, e, f, g, h) {\n    // Yes, it's pretty. Don't touch it.\n    return (a === 0 ? 0 : 1) |\n        (b === 0 ? 0 : 2) |\n        (c === 0 ? 0 : 4) |\n        (d === 0 ? 0 : 8) |\n        (e === 0 ? 0 : 16) |\n        (f === 0 ? 0 : 32) |\n        (g === 0 ? 0 : 64) |\n        (h === 0 ? 0 : 128);\n}\nexports.getTagByte = getTagByte;\n/**\n * Efficiently calculate the length of a packed Cap'n Proto message.\n *\n * @export\n * @param {ArrayBuffer} packed The packed message.\n * @returns {number} The length of the unpacked message in bytes.\n */\nfunction getUnpackedByteLength(packed) {\n    var p = new Uint8Array(packed);\n    var wordLength = 0;\n    var lastTag = 0x77;\n    for (var i = 0; i < p.byteLength;) {\n        var tag = p[i];\n        if (lastTag === 0 /* ZERO */) {\n            wordLength += tag;\n            i++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            wordLength += tag;\n            i += tag * 8 + 1;\n            lastTag = 0x77;\n        }\n        else {\n            wordLength++;\n            i += getHammingWeight(tag) + 1;\n            lastTag = tag;\n        }\n    }\n    return wordLength * 8;\n}\nexports.getUnpackedByteLength = getUnpackedByteLength;\n/**\n * Compute the number of zero bytes that occur in a given 64-bit word, provided as eight separate bytes.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The number of these bytes that are zero.\n */\nfunction getZeroByteCount(a, b, c, d, e, f, g, h) {\n    return (a === 0 ? 1 : 0) +\n        (b === 0 ? 1 : 0) +\n        (c === 0 ? 1 : 0) +\n        (d === 0 ? 1 : 0) +\n        (e === 0 ? 1 : 0) +\n        (f === 0 ? 1 : 0) +\n        (g === 0 ? 1 : 0) +\n        (h === 0 ? 1 : 0);\n}\nexports.getZeroByteCount = getZeroByteCount;\n/**\n * Pack a section of a Cap'n Proto message into a compressed format. This will efficiently compress zero bytes (which\n * are common in idiomatic Cap'n Proto messages) into a compact form.\n *\n * For stream-framed messages this is called once for the frame header and once again for each segment in the message.\n *\n * The returned array buffer is trimmed to the exact size of the packed message with a single copy operation at the end.\n * This should be decent on CPU time but does require quite a lot of memory (a normal array is filled up with each\n * packed byte until the packing is complete).\n *\n * @export\n * @param {ArrayBuffer} unpacked The message to pack.\n * @param {number} [byteOffset] Starting byte offset to read bytes from, defaults to 0.\n * @param {number} [byteLength] Total number of bytes to read, defaults to the remainder of the buffer contents.\n * @returns {ArrayBuffer} A packed version of the message.\n */\nfunction pack(unpacked, byteOffset, byteLength) {\n    if (byteOffset === void 0) { byteOffset = 0; }\n    if (unpacked.byteLength % 8 !== 0)\n        throw new Error(errors_1.MSG_PACK_NOT_WORD_ALIGNED);\n    var src = new Uint8Array(unpacked, byteOffset, byteLength);\n    // TODO: Maybe we should do this with buffers? This costs more than 8x the final compressed size in temporary RAM.\n    var dst = [];\n    /* Just have to be sure it's neither ZERO nor SPAN. */\n    var lastTag = 0x77;\n    /** This is where we need to remember to write the SPAN tag (0xff). */\n    var spanTagOffset = NaN;\n    /** How many words have been copied during the current span. */\n    var spanWordLength = 0;\n    /**\n     * When this hits zero, we've had PACK_SPAN_THRESHOLD zero bytes pass by and it's time to bail from the span.\n     */\n    var spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n    for (var srcByteOffset = 0; srcByteOffset < src.byteLength; srcByteOffset += 8) {\n        /** Read in the entire word. Yes, this feels silly but it's fast! */\n        var a = src[srcByteOffset];\n        var b = src[srcByteOffset + 1];\n        var c = src[srcByteOffset + 2];\n        var d = src[srcByteOffset + 3];\n        var e = src[srcByteOffset + 4];\n        var f = src[srcByteOffset + 5];\n        var g = src[srcByteOffset + 6];\n        var h = src[srcByteOffset + 7];\n        var tag = getTagByte(a, b, c, d, e, f, g, h);\n        /** If this is true we'll skip the normal word write logic after the switch statement. */\n        var skipWriteWord = true;\n        switch (lastTag) {\n            case 0 /* ZERO */:\n                // We're writing a span of words with all zeroes in them. See if we need to bail out of the fast path.\n                if (tag !== 0 /* ZERO */ || spanWordLength >= 0xff) {\n                    // There's a bit in there or we got too many zeroes. Damn, we need to bail.\n                    dst.push(spanWordLength);\n                    spanWordLength = 0;\n                    skipWriteWord = false;\n                }\n                else {\n                    // Kay, let's quickly inc this and go.\n                    spanWordLength++;\n                }\n                break;\n            case 255 /* SPAN */:\n                // We're writing a span of nonzero words.\n                var zeroCount = getZeroByteCount(a, b, c, d, e, f, g, h);\n                // See if we need to bail now.\n                spanThreshold -= zeroCount;\n                if (spanThreshold <= 0 || spanWordLength >= 0xff) {\n                    // Alright, time to get packing again. Write the number of words we skipped to the beginning of the span.\n                    dst[spanTagOffset] = spanWordLength;\n                    spanWordLength = 0;\n                    spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n                    // We have to write this word normally.\n                    skipWriteWord = false;\n                }\n                else {\n                    // Just write this word verbatim.\n                    dst.push(a, b, c, d, e, f, g, h);\n                    spanWordLength++;\n                }\n                break;\n            default:\n                // Didn't get a special tag last time, let's write this as normal.\n                skipWriteWord = false;\n                break;\n        }\n        // A goto is fast, idk why people keep hatin'.\n        if (skipWriteWord)\n            continue;\n        dst.push(tag);\n        lastTag = tag;\n        if (a !== 0)\n            dst.push(a);\n        if (b !== 0)\n            dst.push(b);\n        if (c !== 0)\n            dst.push(c);\n        if (d !== 0)\n            dst.push(d);\n        if (e !== 0)\n            dst.push(e);\n        if (f !== 0)\n            dst.push(f);\n        if (g !== 0)\n            dst.push(g);\n        if (h !== 0)\n            dst.push(h);\n        // Record the span tag offset if needed, making sure to actually leave room for it.\n        if (tag === 255 /* SPAN */) {\n            spanTagOffset = dst.length;\n            dst.push(0);\n        }\n    }\n    // We're done. If we were writing a span let's finish it.\n    if (lastTag === 0 /* ZERO */) {\n        dst.push(spanWordLength);\n    }\n    else if (lastTag === 255 /* SPAN */) {\n        dst[spanTagOffset] = spanWordLength;\n    }\n    return new Uint8Array(dst).buffer;\n}\nexports.pack = pack;\n/**\n * Unpack a compressed Cap'n Proto message into a new ArrayBuffer.\n *\n * Unlike the `pack` function, this is able to efficiently determine the exact size needed for the output buffer and\n * runs considerably more efficiently.\n *\n * @export\n * @param {ArrayBuffer} packed An array buffer containing the packed message.\n * @returns {ArrayBuffer} The unpacked message.\n */\nfunction unpack(packed) {\n    // We have no choice but to read the packed buffer one byte at a time.\n    var src = new Uint8Array(packed);\n    var dst = new Uint8Array(new ArrayBuffer(getUnpackedByteLength(packed)));\n    /** The last tag byte that we've seen - it starts at a \"neutral\" value. */\n    var lastTag = 0x77;\n    for (var srcByteOffset = 0, dstByteOffset = 0; srcByteOffset < src.byteLength;) {\n        var tag = src[srcByteOffset];\n        if (lastTag === 0 /* ZERO */) {\n            // We have a span of zeroes. New array buffers are guaranteed to be initialized to zero so we just seek ahead.\n            dstByteOffset += tag * 8;\n            srcByteOffset++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            // We have a span of unpacked bytes. Copy them verbatim from the source buffer.\n            var spanByteLength = tag * 8;\n            dst.set(src.subarray(srcByteOffset + 1, srcByteOffset + 1 + spanByteLength), dstByteOffset);\n            dstByteOffset += spanByteLength;\n            srcByteOffset += 1 + spanByteLength;\n            lastTag = 0x77;\n        }\n        else {\n            // Okay, a normal tag. Let's read past the tag and copy bytes that have a bit set in the tag.\n            srcByteOffset++;\n            for (var i = 1; i <= 128; i <<= 1) {\n                // We only need to actually touch `dst` if there's a nonzero byte (it's already initialized to zeroes).\n                if ((tag & i) !== 0)\n                    dst[dstByteOffset] = src[srcByteOffset++];\n                dstByteOffset++;\n            }\n            lastTag = tag;\n        }\n    }\n    return dst.buffer;\n}\nexports.unpack = unpack;\n\n//# sourceMappingURL=packing.js.map\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pointer_1 = __webpack_require__(1);\nvar pointer_list_1 = __webpack_require__(10);\nexports.AnyPointerList = pointer_list_1.PointerList(pointer_1.Pointer);\n\n//# sourceMappingURL=any-pointer-list.js.map\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar trace = debug_1.default('capnp:pointer-allocation-result');\ntrace('load');\n/**\n * This is used as the return value for `Pointer.prototype.initPointer`. Turns out using a class in V8 for multiple\n * return values is faster than using an array or anonymous object.\n *\n * http://jsben.ch/#/zTdbD\n *\n * @export\n * @class PointerAllocationResult\n */\nvar PointerAllocationResult = /** @class */ (function () {\n    function PointerAllocationResult(pointer, offsetWords) {\n        this.pointer = pointer;\n        this.offsetWords = offsetWords;\n    }\n    return PointerAllocationResult;\n}());\nexports.PointerAllocationResult = PointerAllocationResult;\n\n//# sourceMappingURL=pointer-allocation-result.js.map\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar BoolList = /** @class */ (function (_super) {\n    tslib_1.__extends(BoolList, _super);\n    function BoolList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BoolList.prototype.get = function (index) {\n        var bitMask = 1 << index % 8;\n        var byteOffset = index >>> 3;\n        var c = pointer_1.getContent(this);\n        var v = c.segment.getUint8(c.byteOffset + byteOffset);\n        return (v & bitMask) !== 0;\n    };\n    BoolList.prototype.set = function (index, value) {\n        var bitMask = 1 << index % 8;\n        var c = pointer_1.getContent(this);\n        var byteOffset = c.byteOffset + (index >>> 3);\n        var v = c.segment.getUint8(byteOffset);\n        c.segment.setUint8(byteOffset, value ? v | bitMask : v & ~bitMask);\n    };\n    BoolList.prototype.toString = function () {\n        return \"Bool_\" + _super.prototype.toString.call(this);\n    };\n    BoolList._capnp = {\n        displayName: 'List<boolean>',\n        size: list_element_size_1.ListElementSize.BIT,\n    };\n    return BoolList;\n}(list_1.List));\nexports.BoolList = BoolList;\n\n//# sourceMappingURL=bool-list.js.map\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nfunction CompositeList(CompositeClass) {\n    return _a = /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.get = function (index) {\n                return new CompositeClass(this.segment, this.byteOffset, this._capnp.depthLimit - 1, index);\n            };\n            class_1.prototype.set = function (index, value) {\n                pointer_1.copyFrom(value, this.get(index));\n            };\n            class_1.prototype.toString = function () {\n                return \"Composite_\" + _super.prototype.toString.call(this) + \",cls:\" + CompositeClass.toString();\n            };\n            return class_1;\n        }(list_1.List)),\n        _a._capnp = {\n            compositeSize: CompositeClass._capnp.size,\n            displayName: \"List<\" + CompositeClass._capnp.displayName + \">\",\n            size: list_element_size_1.ListElementSize.COMPOSITE,\n        },\n        _a;\n    var _a;\n}\nexports.CompositeList = CompositeList;\n\n//# sourceMappingURL=composite-list.js.map\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_1 = __webpack_require__(14);\nvar pointer_list_1 = __webpack_require__(10);\nexports.DataList = pointer_list_1.PointerList(data_1.Data);\n\n//# sourceMappingURL=data-list.js.map\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Float32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Float32List, _super);\n    function Float32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Float32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getFloat32(c.byteOffset + index * 4);\n    };\n    Float32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setFloat32(c.byteOffset + index * 4, value);\n    };\n    Float32List.prototype.toString = function () {\n        return \"Float32_\" + _super.prototype.toString.call(this);\n    };\n    Float32List._capnp = {\n        displayName: 'List<Float32>',\n        size: list_element_size_1.ListElementSize.BYTE_4,\n    };\n    return Float32List;\n}(list_1.List));\nexports.Float32List = Float32List;\n\n//# sourceMappingURL=float32-list.js.map\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Float64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Float64List, _super);\n    function Float64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Float64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getFloat64(c.byteOffset + index * 8);\n    };\n    Float64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setFloat64(c.byteOffset + index * 8, value);\n    };\n    Float64List.prototype.toString = function () {\n        return \"Float64_\" + _super.prototype.toString.call(this);\n    };\n    Float64List._capnp = {\n        displayName: 'List<Float64>',\n        size: list_element_size_1.ListElementSize.BYTE_8,\n    };\n    return Float64List;\n}(list_1.List));\nexports.Float64List = Float64List;\n\n//# sourceMappingURL=float64-list.js.map\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int8List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int8List, _super);\n    function Int8List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int8List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt8(c.byteOffset + index);\n    };\n    Int8List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt8(c.byteOffset + index, value);\n    };\n    Int8List.prototype.toString = function () {\n        return \"Int8_\" + _super.prototype.toString.call(this);\n    };\n    Int8List._capnp = {\n        displayName: 'List<Int8>',\n        size: list_element_size_1.ListElementSize.BYTE,\n    };\n    return Int8List;\n}(list_1.List));\nexports.Int8List = Int8List;\n\n//# sourceMappingURL=int8-list.js.map\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int16List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int16List, _super);\n    function Int16List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int16List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt16(c.byteOffset + index * 2);\n    };\n    Int16List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt16(c.byteOffset + index * 2, value);\n    };\n    Int16List.prototype.toString = function () {\n        return \"Int16_\" + _super.prototype.toString.call(this);\n    };\n    Int16List._capnp = {\n        displayName: 'List<Int16>',\n        size: list_element_size_1.ListElementSize.BYTE_2,\n    };\n    return Int16List;\n}(list_1.List));\nexports.Int16List = Int16List;\n\n//# sourceMappingURL=int16-list.js.map\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int32List, _super);\n    function Int32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt32(c.byteOffset + index * 4);\n    };\n    Int32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt32(c.byteOffset + index * 4, value);\n    };\n    Int32List.prototype.toString = function () {\n        return \"Int32_\" + _super.prototype.toString.call(this);\n    };\n    Int32List._capnp = {\n        displayName: 'List<Int32>',\n        size: list_element_size_1.ListElementSize.BYTE_4,\n    };\n    return Int32List;\n}(list_1.List));\nexports.Int32List = Int32List;\n\n//# sourceMappingURL=int32-list.js.map\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int64List, _super);\n    function Int64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt64(c.byteOffset + index * 8);\n    };\n    Int64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt64(c.byteOffset + index * 8, value);\n    };\n    Int64List.prototype.toString = function () {\n        return \"Int64_\" + _super.prototype.toString.call(this);\n    };\n    Int64List._capnp = {\n        displayName: 'List<Int64>',\n        size: list_element_size_1.ListElementSize.BYTE_8,\n    };\n    return Int64List;\n}(list_1.List));\nexports.Int64List = Int64List;\n\n//# sourceMappingURL=int64-list.js.map\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interface_1 = __webpack_require__(22);\nvar pointer_list_1 = __webpack_require__(10);\nexports.InterfaceList = pointer_list_1.PointerList(interface_1.Interface);\n\n//# sourceMappingURL=interface-list.js.map\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar util_1 = __webpack_require__(6);\nvar uint64_1 = __webpack_require__(23);\nvar trace = debug_1.default('capnp:int64');\ntrace('load');\n/**\n * Represents a signed 64-bit integer stored using a Uint8Array in little-endian format.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Int64 = /** @class */ (function (_super) {\n    tslib_1.__extends(Int64, _super);\n    function Int64() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Int64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    Int64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as an Int64 value.\n     *\n     * The value will be negative if the string is either preceded with a `-` sign, or already in the negative 2's\n     * complement form.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Int64} The string parsed as a 64-bit signed integer.\n     */\n    Int64.fromHexString = function (source) {\n        if (source.substr(0, 2) === '0x')\n            source = source.substr(2);\n        if (source.length < 1)\n            return Int64.fromNumber(0);\n        var neg = source[0] === '-';\n        if (neg)\n            source = source.substr(1);\n        source = util_1.pad(source, 16);\n        if (source.length !== 16)\n            throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++)\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        var val = new Int64(buf);\n        if (neg)\n            val.negate();\n        return val;\n    };\n    Int64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Int64.prototype.equals = function (other) {\n        return _super.prototype.equals.call(this, other);\n    };\n    Int64.prototype.inspect = function () {\n        return \"[Int64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    Int64.prototype.negate = function () {\n        for (var b = this.buffer, carry = 1, i = 0; i < 8; i++) {\n            var v = (b[i] ^ 0xff) + carry;\n            b[i] = v & 0xff;\n            carry = v >> 8;\n        }\n    };\n    Int64.prototype.setValue = function (loWord, hiWord) {\n        var negate = false;\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            negate = hi < 0;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Int64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n        if (negate)\n            this.negate();\n    };\n    Int64.prototype.toHexString = function () {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        if (negate)\n            this.negate();\n        var hex = '';\n        for (var i = 7; i >= 0; i--) {\n            var v = b[i].toString(16);\n            if (v.length === 1)\n                v = '0' + v;\n            hex += v;\n        }\n        if (negate) {\n            this.negate();\n            hex = '-' + hex;\n        }\n        return hex;\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +/-Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Int64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        var x = 0;\n        var carry = 1;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            if (negate) {\n                v = (v ^ 0xff) + carry;\n                carry = v >> 8;\n                v = v & 0xff;\n            }\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace('Coercing out of range value %d to Infinity.', x);\n            return negate ? -Infinity : Infinity;\n        }\n        return negate ? -x : x;\n    };\n    return Int64;\n}(uint64_1.Uint64));\nexports.Int64 = Int64;\n\n//# sourceMappingURL=int64.js.map\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar text_1 = __webpack_require__(17);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar TextList = /** @class */ (function (_super) {\n    tslib_1.__extends(TextList, _super);\n    function TextList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TextList.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        c.byteOffset += index * 8;\n        return text_1.Text.fromPointer(c).get(0);\n    };\n    TextList.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.byteOffset += index * 8;\n        text_1.Text.fromPointer(c).set(0, value);\n    };\n    TextList.prototype.toString = function () {\n        return \"Text_\" + _super.prototype.toString.call(this);\n    };\n    TextList._capnp = {\n        displayName: 'List<Text>',\n        size: list_element_size_1.ListElementSize.POINTER,\n    };\n    return TextList;\n}(list_1.List));\nexports.TextList = TextList;\n\n//# sourceMappingURL=text-list.js.map\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint8List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint8List, _super);\n    function Uint8List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint8List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint8(c.byteOffset + index);\n    };\n    Uint8List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint8(c.byteOffset + index, value);\n    };\n    Uint8List.prototype.toString = function () {\n        return \"Uint8_\" + _super.prototype.toString.call(this);\n    };\n    Uint8List._capnp = {\n        displayName: 'List<Uint8>',\n        size: list_element_size_1.ListElementSize.BYTE,\n    };\n    return Uint8List;\n}(list_1.List));\nexports.Uint8List = Uint8List;\n\n//# sourceMappingURL=uint8-list.js.map\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint16List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint16List, _super);\n    function Uint16List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint16List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint16(c.byteOffset + index * 2);\n    };\n    Uint16List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint16(c.byteOffset + index * 2, value);\n    };\n    Uint16List.prototype.toString = function () {\n        return \"Uint16_\" + _super.prototype.toString.call(this);\n    };\n    Uint16List._capnp = {\n        displayName: 'List<Uint16>',\n        size: list_element_size_1.ListElementSize.BYTE_2,\n    };\n    return Uint16List;\n}(list_1.List));\nexports.Uint16List = Uint16List;\n\n//# sourceMappingURL=uint16-list.js.map\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint32List, _super);\n    function Uint32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint32(c.byteOffset + index * 4);\n    };\n    Uint32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint32(c.byteOffset + index * 4, value);\n    };\n    Uint32List.prototype.toString = function () {\n        return \"Uint32_\" + _super.prototype.toString.call(this);\n    };\n    Uint32List._capnp = {\n        displayName: 'List<Uint32>',\n        size: list_element_size_1.ListElementSize.BYTE_4,\n    };\n    return Uint32List;\n}(list_1.List));\nexports.Uint32List = Uint32List;\n\n//# sourceMappingURL=uint32-list.js.map\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(2);\nvar debug_1 = __webpack_require__(0);\nvar list_element_size_1 = __webpack_require__(3);\nvar list_1 = __webpack_require__(4);\nvar pointer_1 = __webpack_require__(1);\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint64List, _super);\n    function Uint64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint64(c.byteOffset + index * 8);\n    };\n    Uint64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint64(c.byteOffset + index * 8, value);\n    };\n    Uint64List.prototype.toString = function () {\n        return \"Uint64_\" + _super.prototype.toString.call(this);\n    };\n    Uint64List._capnp = {\n        displayName: 'List<Uint64>',\n        size: list_element_size_1.ListElementSize.BYTE_8,\n    };\n    return Uint64List;\n}(list_1.List));\nexports.Uint64List = Uint64List;\n\n//# sourceMappingURL=uint64-list.js.map\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Why would anyone **SANE** ever use this!?\n *\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pointer_list_1 = __webpack_require__(10);\nvar void_1 = __webpack_require__(24);\nexports.VoidList = pointer_list_1.PointerList(void_1.Void);\n\n//# sourceMappingURL=void-list.js.map\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = __webpack_require__(0);\nvar constants_1 = __webpack_require__(7);\nvar errors_1 = __webpack_require__(5);\nvar types_1 = __webpack_require__(16);\nvar util_1 = __webpack_require__(6);\nvar pointers_1 = __webpack_require__(13);\nvar trace = debug_1.default('capnp:segment');\ntrace('load');\nvar Segment = /** @class */ (function () {\n    function Segment(id, message, buffer, byteLength) {\n        if (byteLength === void 0) { byteLength = 0; }\n        this[Symbol.toStringTag] = 'Segment';\n        this.id = id;\n        this.message = message;\n        this.buffer = buffer;\n        this._dv = new DataView(buffer);\n        this.byteOffset = 0;\n        this.byteLength = byteLength;\n    }\n    /**\n     * Attempt to allocate the requested number of bytes in this segment. If this segment is full this method will return\n     * a pointer to freshly allocated space in another segment from the same message.\n     *\n     * @param {number} byteLength The number of bytes to allocate, will be rounded up to the nearest word.\n     * @returns {Pointer} A pointer to the newly allocated space.\n     */\n    Segment.prototype.allocate = function (byteLength) {\n        trace('allocate(%d)', byteLength);\n        var segment = this;\n        byteLength = util_1.padToWord(byteLength);\n        if (byteLength > constants_1.MAX_SEGMENT_LENGTH - 8)\n            throw new Error(util_1.format(errors_1.SEG_SIZE_OVERFLOW, byteLength));\n        if (!segment.hasCapacity(byteLength))\n            segment = segment.message.allocateSegment(byteLength);\n        var byteOffset = segment.byteLength;\n        segment.byteLength = segment.byteLength + byteLength;\n        trace('Allocated %x bytes in %s (requested segment: %s).', byteLength, this, segment);\n        return new pointers_1.Pointer(segment, byteOffset);\n    };\n    /**\n     * Quickly copy a word (8 bytes) from `srcSegment` into this one at the given offset.\n     *\n     * @param {number} byteOffset The offset to write the word to.\n     * @param {Segment} srcSegment The segment to copy the word from.\n     * @param {number} srcByteOffset The offset from the start of `srcSegment` to copy from.\n     * @returns {void}\n     */\n    Segment.prototype.copyWord = function (byteOffset, srcSegment, srcByteOffset) {\n        var value = srcSegment._dv.getFloat64(srcByteOffset, constants_1.NATIVE_LITTLE_ENDIAN);\n        this._dv.setFloat64(byteOffset, value, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    /**\n     * Quickly copy words from `srcSegment` into this one.\n     *\n     * @param {number} byteOffset The offset to start copying into.\n     * @param {Segment} srcSegment The segment to copy from.\n     * @param {number} srcByteOffset The start offset to copy from.\n     * @param {number} wordLength The number of words to copy.\n     * @returns {void}\n     */\n    Segment.prototype.copyWords = function (byteOffset, srcSegment, srcByteOffset, wordLength) {\n        var dst = new Float64Array(this.buffer, byteOffset, wordLength);\n        var src = new Float64Array(srcSegment.buffer, srcByteOffset, wordLength);\n        dst.set(src);\n    };\n    /**\n     * Quickly fill a number of words in the buffer with zeroes.\n     *\n     * @param {number} byteOffset The first byte to set to zero.\n     * @param {number} wordLength The number of words (not bytes!) to zero out.\n     * @returns {void}\n     */\n    Segment.prototype.fillZeroWords = function (byteOffset, wordLength) {\n        new Float64Array(this.buffer, byteOffset, wordLength).fill(0);\n    };\n    /**\n     * Get the total number of bytes available in this segment (the size of its underlying buffer).\n     *\n     * @returns {number} The total number of bytes this segment can hold.\n     */\n    Segment.prototype.getCapacity = function () {\n        return this.buffer.byteLength;\n    };\n    /**\n     * Read a float32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat32 = function (byteOffset) {\n        return this._dv.getFloat32(byteOffset, true);\n    };\n    /**\n     * Read a float64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat64 = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, true);\n    };\n    /**\n     * Read an int16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt16 = function (byteOffset) {\n        return this._dv.getInt16(byteOffset, true);\n    };\n    /**\n     * Read an int32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt32 = function (byteOffset) {\n        return this._dv.getInt32(byteOffset, true);\n    };\n    /**\n     * Read an int64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt64 = function (byteOffset) {\n        return new types_1.Int64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read an int8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt8 = function (byteOffset) {\n        return this._dv.getInt8(byteOffset);\n    };\n    /**\n     * Read a uint16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint16 = function (byteOffset) {\n        return this._dv.getUint16(byteOffset, true);\n    };\n    /**\n     * Read a uint32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint32 = function (byteOffset) {\n        return this._dv.getUint32(byteOffset, true);\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     * NOTE: this does not copy the memory region, so updates to the underlying buffer will affect the Uint64 value!\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint64 = function (byteOffset) {\n        return new types_1.Uint64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint8 = function (byteOffset) {\n        return this._dv.getUint8(byteOffset);\n    };\n    Segment.prototype.hasCapacity = function (byteLength) {\n        trace('hasCapacity(%d)', byteLength);\n        // capacity - allocated >= requested\n        return this.buffer.byteLength - this.byteLength >= byteLength;\n    };\n    /**\n     * Quickly check the word at the given offset to see if it is equal to zero.\n     *\n     * PERF_V8: Fastest way to do this is by reading the whole word as a `number` (float64) in the _native_ endian format\n     * and see if it's zero.\n     *\n     * Benchmark: http://jsben.ch/#/Pjooc\n     *\n     * @param {number} byteOffset The offset to the word.\n     * @returns {boolean} `true` if the word is zero.\n     */\n    Segment.prototype.isWordZero = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, constants_1.NATIVE_LITTLE_ENDIAN) === 0;\n    };\n    /**\n     * Swap out this segment's underlying buffer with a new one. It's assumed that the new buffer has the same content but\n     * more free space, otherwise all existing pointers to this segment will be hilariously broken.\n     *\n     * @param {ArrayBuffer} buffer The new buffer to use.\n     * @returns {void}\n     */\n    Segment.prototype.replaceBuffer = function (buffer) {\n        trace('replaceBuffer(%p)', buffer);\n        if (this.buffer === buffer)\n            return;\n        if (buffer.byteLength < this.byteLength)\n            throw new Error(errors_1.SEG_REPLACEMENT_BUFFER_TOO_SMALL);\n        this._dv = new DataView(buffer);\n        this.buffer = buffer;\n    };\n    /**\n     * Write a float32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat32 = function (byteOffset, val) {\n        this._dv.setFloat32(byteOffset, val, true);\n    };\n    /**\n     * Write an float64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat64 = function (byteOffset, val) {\n        this._dv.setFloat64(byteOffset, val, true);\n    };\n    /**\n     * Write an int16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt16 = function (byteOffset, val) {\n        this._dv.setInt16(byteOffset, val, true);\n    };\n    /**\n     * Write an int32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt32 = function (byteOffset, val) {\n        this._dv.setInt32(byteOffset, val, true);\n    };\n    /**\n     * Write an int8 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt8 = function (byteOffset, val) {\n        this._dv.setInt8(byteOffset, val);\n    };\n    /**\n     * Write an int64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Int64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint16 = function (byteOffset, val) {\n        this._dv.setUint16(byteOffset, val, true);\n    };\n    /**\n     * Write a uint32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint32 = function (byteOffset, val) {\n        this._dv.setUint32(byteOffset, val, true);\n    };\n    /**\n     * Write a uint64 value to the specified offset.\n     * TODO: benchmark other ways to perform this write operation.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Uint64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset + 0, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint8 (byte) value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint8 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val);\n    };\n    /**\n     * Write a zero word (8 bytes) to the specified offset. This is slightly faster than calling `setUint64` or\n     * `setFloat64` with a zero value.\n     *\n     * Benchmark: http://jsben.ch/#/dUdPI\n     *\n     * @param {number} byteOffset The offset of the word to set to zero.\n     * @returns {void}\n     */\n    Segment.prototype.setWordZero = function (byteOffset) {\n        this._dv.setFloat64(byteOffset, 0, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    Segment.prototype.toString = function () {\n        return util_1.format('Segment_id:%d,off:%a,len:%a,cap:%a', this.id, this.byteLength, this.byteOffset, this.buffer.byteLength);\n    };\n    return Segment;\n}());\nexports.Segment = Segment;\n\n//# sourceMappingURL=segment.js.map\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 2fb454eaf3269c6ec367.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/cuda-profile/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 25);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2fb454eaf3269c6ec367","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/browser.js\n// module id = 0\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar orphan_1 = require(\"./orphan\");\nvar pointer_allocation_result_1 = require(\"./pointer-allocation-result\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar errors_1 = require(\"../../errors\");\nvar trace = debug_1.default('capnp:pointer');\ntrace('load');\n/**\n * A pointer referencing a single byte location in a segment. This is typically used for Cap'n Proto pointers, but is\n * also sometimes used to reference an offset to a pointer's content or tag words.\n *\n * @export\n * @class Pointer\n */\nvar Pointer = /** @class */ (function () {\n    function Pointer(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        if (depthLimit === 0)\n            throw new Error(util_1.format(errors_1.PTR_DEPTH_LIMIT_EXCEEDED, this));\n        // Make sure we keep track of all pointer allocations; there's a limit per message (prevent DoS).\n        trackPointerAllocation(segment.message, this);\n        // NOTE: It's okay to have a pointer to the end of the segment; you'll see this when creating pointers to the\n        // beginning of the content of a newly-allocated composite list with zero elements. Unlike other language\n        // implementations buffer over/underflows are not a big issue since all buffer access is bounds checked in native\n        // code anyway.\n        if (byteOffset < 0 || byteOffset > segment.byteLength) {\n            throw new Error(util_1.format(errors_1.PTR_OFFSET_OUT_OF_BOUNDS, byteOffset));\n        }\n        this._capnp = { compositeList: false, depthLimit: depthLimit };\n        this.segment = segment;\n        this.byteOffset = byteOffset;\n        trace('new %s', this);\n    }\n    Pointer.prototype.toString = function () {\n        return util_1.format('Pointer_%d@%a,%s,limit:%x', this.segment.id, this.byteOffset, dump(this), this._capnp.depthLimit);\n    };\n    Pointer.adopt = adopt;\n    Pointer.copyFrom = copyFrom;\n    Pointer.disown = disown;\n    Pointer.dump = dump;\n    Pointer.isNull = isNull;\n    Pointer._capnp = {\n        displayName: 'Pointer',\n    };\n    return Pointer;\n}());\nexports.Pointer = Pointer;\n/**\n * Adopt an orphaned pointer, making the pointer point to the orphaned content without copying it.\n *\n * @param {Orphan<Pointer>} src The orphan to adopt.\n * @param {Pointer} p The the pointer to adopt into.\n * @returns {void}\n */\nfunction adopt(src, p) {\n    src._moveTo(p);\n}\nexports.adopt = adopt;\n/**\n * Convert a pointer to an Orphan, zeroing out the pointer and leaving its content untouched. If the content is no\n * longer needed, call `disown()` on the orphaned pointer to erase the contents as well.\n *\n * Call `adopt()` on the orphan with the new target pointer location to move it back into the message; the orphan\n * object is then invalidated after adoption (can only adopt once!).\n *\n * @param {T} p The pointer to turn into an Orphan.\n * @returns {Orphan<T>} An orphaned pointer.\n */\nfunction disown(p) {\n    return new orphan_1.Orphan(p);\n}\nexports.disown = disown;\nfunction dump(p) {\n    return util_1.bufferToHex(p.segment.buffer.slice(p.byteOffset, p.byteOffset + 8));\n}\nexports.dump = dump;\n/**\n * Get the total number of bytes required to hold a list of the provided size with the given length, rounded up to the\n * nearest word.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @param {number} length The length of the list.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list; required if\n * `elementSize === ListElementSize.COMPOSITE`.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListByteLength(elementSize, length, compositeSize) {\n    switch (elementSize) {\n        case list_element_size_1.ListElementSize.BIT:\n            return util_1.padToWord(length + 7 >>> 3);\n        case list_element_size_1.ListElementSize.BYTE:\n        case list_element_size_1.ListElementSize.BYTE_2:\n        case list_element_size_1.ListElementSize.BYTE_4:\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n        case list_element_size_1.ListElementSize.VOID:\n            return util_1.padToWord(getListElementByteLength(elementSize) * length);\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            if (compositeSize === undefined)\n                throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, NaN));\n            return length * util_1.padToWord(object_size_1.getByteLength(compositeSize));\n        /* istanbul ignore next */\n        default:\n            throw new Error(errors_1.PTR_INVALID_LIST_SIZE);\n    }\n}\nexports.getListByteLength = getListByteLength;\n/**\n * Get the number of bytes required to hold a list element of the provided size. `COMPOSITE` elements do not have a\n * fixed size, and `BIT` elements are packed into exactly a single bit, so these both return `NaN`.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListElementByteLength(elementSize) {\n    switch (elementSize) {\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.BIT:\n            return NaN;\n        case list_element_size_1.ListElementSize.BYTE:\n            return 1;\n        case list_element_size_1.ListElementSize.BYTE_2:\n            return 2;\n        case list_element_size_1.ListElementSize.BYTE_4:\n            return 4;\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n            return 8;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            // Caller has to figure it out based on the tag word.\n            return NaN;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.VOID:\n            return 0;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n    }\n}\nexports.getListElementByteLength = getListElementByteLength;\n/**\n * Add an offset to the pointer's offset and return a new Pointer for that address.\n *\n * @param {number} offset The number of bytes to add to the offset.\n * @param {Pointer} p The pointer to add from.\n * @returns {Pointer} A new pointer to the address.\n */\nfunction add(offset, p) {\n    return new Pointer(p.segment, p.byteOffset + offset, p._capnp.depthLimit);\n}\nexports.add = add;\n/**\n * Replace a pointer with a deep copy of the pointer at `src` and all of its contents.\n *\n * @param {Pointer} src The pointer to copy.\n * @param {Pointer} p The pointer to copy into.\n * @returns {void}\n */\nfunction copyFrom(src, p) {\n    // If the pointer is the same then this is a noop.\n    if (p.segment === src.segment && p.byteOffset === src.byteOffset) {\n        trace('ignoring copy operation from identical pointer %s', src);\n        return;\n    }\n    // Make sure we erase this pointer's contents before moving on. If src is null, that's all we do.\n    erase(p); // noop if null\n    if (isNull(src))\n        return;\n    switch (getTargetPointerType(src)) {\n        case pointer_type_1.PointerType.STRUCT:\n            copyFromStruct(src, p);\n            break;\n        case pointer_type_1.PointerType.LIST:\n            copyFromList(src, p);\n            break;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n}\nexports.copyFrom = copyFrom;\n/**\n * Recursively erase a pointer, any far pointers/landing pads/tag words, and the content it points to.\n *\n * Note that this will leave \"holes\" of zeroes in the message, since the space cannot be reclaimed. With packing this\n * will have a negligible effect on the final message size.\n *\n * FIXME: This may need protection against infinite recursion...\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erase(p) {\n    if (isNull(p))\n        return;\n    // First deal with the contents.\n    var c;\n    switch (getTargetPointerType(p)) {\n        case pointer_type_1.PointerType.STRUCT:\n            var size = getTargetStructSize(p);\n            c = getContent(p);\n            // Wipe the data section.\n            c.segment.fillZeroWords(c.byteOffset, size.dataByteLength / 8);\n            // Iterate over all the pointers and nuke them.\n            for (var i = 0; i < size.pointerLength; i++) {\n                erase(add(i * 8, c));\n            }\n            break;\n        case pointer_type_1.PointerType.LIST:\n            var elementSize = getTargetListElementSize(p);\n            var length = getTargetListLength(p);\n            var contentWords = util_1.padToWord(length * getListElementByteLength(elementSize));\n            c = getContent(p);\n            if (elementSize === list_element_size_1.ListElementSize.POINTER) {\n                for (var i = 0; i < length; i++) {\n                    erase(new Pointer(c.segment, c.byteOffset + i * 8, p._capnp.depthLimit - 1));\n                }\n                // Calling erase on each pointer takes care of the content, nothing left to do here.\n                break;\n            }\n            else if (elementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n                // Read some stuff from the tag word.\n                var tag = add(-8, c);\n                var compositeSize = getStructSize(tag);\n                var compositeByteLength = object_size_1.getByteLength(compositeSize);\n                contentWords = getOffsetWords(tag);\n                // Kill the tag word.\n                c.segment.setWordZero(c.byteOffset - 8);\n                // Recursively erase each pointer.\n                for (var i = 0; i < length; i++) {\n                    for (var j = 0; j < compositeSize.pointerLength; j++) {\n                        erase(new Pointer(c.segment, c.byteOffset + i * compositeByteLength + j * 8, p._capnp.depthLimit - 1));\n                    }\n                }\n            }\n            c.segment.fillZeroWords(c.byteOffset, contentWords);\n            break;\n        case pointer_type_1.PointerType.OTHER:\n            // No content.\n            break;\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n    erasePointer(p);\n}\nexports.erase = erase;\n/**\n * Set the pointer (and far pointer landing pads, if applicable) to zero. Does not touch the pointer's content.\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erasePointer(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p)) {\n            // Kill the double-far tag word.\n            landingPad.segment.setWordZero(landingPad.byteOffset + 8);\n        }\n        // Kill the landing pad.\n        landingPad.segment.setWordZero(landingPad.byteOffset);\n    }\n    // Finally! Kill the pointer itself...\n    p.segment.setWordZero(p.byteOffset);\n}\nexports.erasePointer = erasePointer;\n/**\n * Interpret the pointer as a far pointer, returning its target segment and offset.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the far target.\n */\nfunction followFar(p) {\n    var targetSegment = p.segment.message.getSegment(p.segment.getUint32(p.byteOffset + 4));\n    var targetWordOffset = p.segment.getUint32(p.byteOffset) >>> 3;\n    return new Pointer(targetSegment, targetWordOffset * 8, p._capnp.depthLimit - 1);\n}\nexports.followFar = followFar;\n/**\n * If the pointer address references a far pointer, follow it to the location where the actual pointer data is written.\n * Otherwise, returns the pointer unmodified.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A new pointer representing the target location, or `p` if it is not a far pointer.\n */\nfunction followFars(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p))\n            landingPad.byteOffset += 8;\n        return landingPad;\n    }\n    return p;\n}\nexports.followFars = followFars;\nfunction getCapabilityId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getCapabilityId = getCapabilityId;\nfunction isCompositeList(p) {\n    return getTargetPointerType(p) === pointer_type_1.PointerType.LIST && getTargetListElementSize(p) === list_element_size_1.ListElementSize.COMPOSITE;\n}\n/**\n * Obtain the location of the pointer's content, following far pointers as needed.\n * If the pointer is a struct pointer and `compositeIndex` is set, it will be offset by a multiple of the struct's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @param {boolean} [ignoreCompositeIndex] If true, will not follow the composite struct pointer's composite index and\n * instead return a pointer to the parent list's contents (also the beginning of the first struct).\n * @returns {Pointer} A pointer to the beginning of the pointer's content.\n */\nfunction getContent(p, ignoreCompositeIndex) {\n    var c;\n    if (isDoubleFar(p)) {\n        var landingPad = followFar(p);\n        c = new Pointer(p.segment.message.getSegment(getFarSegmentId(landingPad)), getOffsetWords(landingPad) * 8);\n    }\n    else {\n        var target = followFars(p);\n        c = new Pointer(target.segment, target.byteOffset + 8 + getOffsetWords(target) * 8);\n    }\n    if (isCompositeList(p))\n        c.byteOffset += 8;\n    if (!ignoreCompositeIndex && p._capnp.compositeIndex !== undefined) {\n        // Seek backwards by one word so we can read the struct size off the tag word.\n        c.byteOffset -= 8;\n        // Seek ahead by `compositeIndex` multiples of the struct's total size.\n        c.byteOffset += 8 + p._capnp.compositeIndex * object_size_1.getByteLength(object_size_1.padToWord(getStructSize(c)));\n    }\n    return c;\n}\nexports.getContent = getContent;\n/**\n * Read the target segment ID from a far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The target segment ID.\n */\nfunction getFarSegmentId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getFarSegmentId = getFarSegmentId;\n/**\n * Get a number indicating the size of the list's elements.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the list's elements.\n */\nfunction getListElementSize(p) {\n    return p.segment.getUint32(p.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n}\nexports.getListElementSize = getListElementSize;\n/**\n * Get the number of elements in a list pointer. For composite lists, it instead represents the total number of words in\n * the list (not counting the tag word).\n *\n * This method does **not** attempt to distinguish between composite and non-composite lists. To get the correct\n * length for composite lists use `getTargetListLength()` instead.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The length of the list, or total number of words for composite lists.\n */\nfunction getListLength(p) {\n    return p.segment.getUint32(p.byteOffset + 4) >>> 3;\n}\nexports.getListLength = getListLength;\n/**\n * Get the offset (in words) from the end of a pointer to the start of its content. For struct pointers, this is the\n * beginning of the data section, and for list pointers it is the location of the first element. The value should\n * always be zero for interface pointers.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The offset, in words, from the end of the pointer to the start of the data section.\n */\nfunction getOffsetWords(p) {\n    var o = p.segment.getInt32(p.byteOffset);\n    // Far pointers only have 29 offset bits.\n    return o & 2 ? o >> 3 : o >> 2;\n}\nexports.getOffsetWords = getOffsetWords;\n/**\n * Look up the pointer's type.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer.\n */\nfunction getPointerType(p) {\n    return p.segment.getUint32(p.byteOffset) & constants_1.POINTER_TYPE_MASK;\n}\nexports.getPointerType = getPointerType;\n/**\n * Read the number of data words from this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of data words in the struct.\n */\nfunction getStructDataWords(p) {\n    return p.segment.getUint16(p.byteOffset + 4);\n}\nexports.getStructDataWords = getStructDataWords;\n/**\n * Read the number of pointers contained in this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of pointers in this struct.\n */\nfunction getStructPointerLength(p) {\n    return p.segment.getUint16(p.byteOffset + 6);\n}\nexports.getStructPointerLength = getStructPointerLength;\n/**\n * Get an object describing this struct pointer's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} The size of the struct.\n */\nfunction getStructSize(p) {\n    return new object_size_1.ObjectSize(getStructDataWords(p) * 8, getStructPointerLength(p));\n}\nexports.getStructSize = getStructSize;\n/**\n * Get a pointer to this pointer's composite list tag word, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the list's composite tag word.\n */\nfunction getTargetCompositeListTag(p) {\n    var c = getContent(p);\n    // The composite list tag is always one word before the content.\n    c.byteOffset -= 8;\n    return c;\n}\nexports.getTargetCompositeListTag = getTargetCompositeListTag;\n/**\n * Get the object size for the target composite list, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} An object describing the size of each struct in the list.\n */\nfunction getTargetCompositeListSize(p) {\n    return getStructSize(getTargetCompositeListTag(p));\n}\nexports.getTargetCompositeListSize = getTargetCompositeListSize;\n/**\n * Get the size of the list elements referenced by this pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the elements in the list.\n */\nfunction getTargetListElementSize(p) {\n    return getListElementSize(followFars(p));\n}\nexports.getTargetListElementSize = getTargetListElementSize;\n/**\n * Get the length of the list referenced by this pointer, following far pointers if necessary. If the list is a\n * composite list, it will look up the tag word and read the length from there.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of elements in the list.\n */\nfunction getTargetListLength(p) {\n    var t = followFars(p);\n    if (getListElementSize(t) === list_element_size_1.ListElementSize.COMPOSITE) {\n        // The content is prefixed by a tag word; it's a struct pointer whose offset contains the list's length.\n        return getOffsetWords(getTargetCompositeListTag(p));\n    }\n    return getListLength(t);\n}\nexports.getTargetListLength = getTargetListLength;\n/**\n * Get the type of a pointer, following far pointers if necessary. For non-far pointers this is equivalent to calling\n * `getPointerType()`.\n *\n * The target of a far pointer can never be another far pointer, and this method will throw if such a situation is\n * encountered.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer referenced by this pointer.\n */\nfunction getTargetPointerType(p) {\n    var t = getPointerType(followFars(p));\n    if (t === pointer_type_1.PointerType.FAR)\n        throw new Error(util_1.format(errors_1.PTR_INVALID_FAR_TARGET, p));\n    return t;\n}\nexports.getTargetPointerType = getTargetPointerType;\n/**\n * Get the size of the struct referenced by a pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The poiner to read from.\n * @returns {ObjectSize} The size of the struct referenced by this pointer.\n */\nfunction getTargetStructSize(p) {\n    return getStructSize(followFars(p));\n}\nexports.getTargetStructSize = getTargetStructSize;\n/**\n * Initialize a pointer to point at the data in the content segment. If the content segment is not the same as the\n * pointer's segment, this will allocate and write far pointers as needed. Nothing is written otherwise.\n *\n * The return value includes a pointer to write the pointer's actual data to (the eventual far target), and the offset\n * value (in words) to use for that pointer. In the case of double-far pointers this offset will always be zero.\n *\n * @param {Segment} contentSegment The segment containing this pointer's content.\n * @param {number} contentOffset The offset within the content segment for the beginning of this pointer's content.\n * @param {Pointer} p The pointer to initialize.\n * @returns {PointerAllocationResult} An object containing a pointer (where the pointer data should be written), and\n * the value to use as the offset for that pointer.\n */\nfunction initPointer(contentSegment, contentOffset, p) {\n    if (p.segment !== contentSegment) {\n        // Need a far pointer.\n        trace('Initializing far pointer %s -> %s.', p, contentSegment);\n        if (!contentSegment.hasCapacity(8)) {\n            // GAH! Not enough space in the content segment for a landing pad so we need a double far pointer.\n            var landingPad_1 = p.segment.allocate(16);\n            trace('GAH! Initializing double-far pointer in %s from %s -> %s.', p, contentSegment, landingPad_1);\n            setFarPointer(true, landingPad_1.byteOffset / 8, landingPad_1.segment.id, p);\n            setFarPointer(false, contentOffset / 8, contentSegment.id, landingPad_1);\n            landingPad_1.byteOffset += 8;\n            return new pointer_allocation_result_1.PointerAllocationResult(landingPad_1, 0);\n        }\n        // Allocate a far pointer landing pad in the target segment.\n        var landingPad = contentSegment.allocate(8);\n        if (landingPad.segment.id !== contentSegment.id) {\n            throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n        }\n        setFarPointer(false, landingPad.byteOffset / 8, landingPad.segment.id, p);\n        return new pointer_allocation_result_1.PointerAllocationResult(landingPad, (contentOffset - landingPad.byteOffset - 8) / 8);\n    }\n    trace('Initializing intra-segment pointer %s -> %a.', p, contentOffset);\n    return new pointer_allocation_result_1.PointerAllocationResult(p, (contentOffset - p.byteOffset - 8) / 8);\n}\nexports.initPointer = initPointer;\n/**\n * Check if the pointer is a double-far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if it is a double-far pointer, `false` otherwise.\n */\nfunction isDoubleFar(p) {\n    return getPointerType(p) === pointer_type_1.PointerType.FAR && (p.segment.getUint32(p.byteOffset) & constants_1.POINTER_DOUBLE_FAR_MASK) !== 0;\n}\nexports.isDoubleFar = isDoubleFar;\n/**\n * Quickly check to see if the pointer is \"null\". A \"null\" pointer is a zero word, equivalent to an empty struct\n * pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if the pointer is \"null\".\n */\nfunction isNull(p) {\n    return p.segment.isWordZero(p.byteOffset);\n}\nexports.isNull = isNull;\n/**\n * Relocate a pointer to the given destination, ensuring that it points to the same content. This will create far\n * pointers as needed if the content is in a different segment than the destination. After the relocation the source\n * pointer will be erased and is no longer valid.\n *\n * @param {Pointer} dst The desired location for the `src` pointer. Any existing contents will be erased before\n * relocating!\n * @param {Pointer} src The pointer to relocate.\n * @returns {void}\n */\nfunction relocateTo(dst, src) {\n    var t = followFars(src);\n    var lo = t.segment.getUint8(t.byteOffset) & 0x03; // discard the offset\n    var hi = t.segment.getUint32(t.byteOffset + 4);\n    // Make sure anything dst was pointing to is wiped out.\n    erase(dst);\n    var res = initPointer(t.segment, t.byteOffset + 8 + getOffsetWords(t) * 8, dst);\n    // Keep the low 2 bits and write the new offset.\n    res.pointer.segment.setUint32(res.pointer.byteOffset, lo | (res.offsetWords << 2));\n    // Keep the high 32 bits intact.\n    res.pointer.segment.setUint32(res.pointer.byteOffset + 4, hi);\n    erasePointer(src);\n}\nexports.relocateTo = relocateTo;\n/**\n * Write a far pointer.\n *\n * @param {boolean} doubleFar Set to `true` if this is a double far pointer.\n * @param {number} offsetWords The offset, in words, to the target pointer.\n * @param {number} segmentId The segment the target pointer is located in.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setFarPointer(doubleFar, offsetWords, segmentId, p) {\n    var A = pointer_type_1.PointerType.FAR;\n    var B = doubleFar ? 1 : 0;\n    var C = offsetWords;\n    var D = segmentId;\n    p.segment.setUint32(p.byteOffset, A | B << 2 | C << 3);\n    p.segment.setUint32(p.byteOffset + 4, D);\n}\nexports.setFarPointer = setFarPointer;\n/**\n * Write a raw interface pointer.\n *\n * @param {number} capId The capability ID.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setInterfacePointer(capId, p) {\n    p.segment.setUint32(p.byteOffset, pointer_type_1.PointerType.OTHER);\n    p.segment.setUint32(p.byteOffset + 4, capId);\n}\nexports.setInterfacePointer = setInterfacePointer;\n/**\n * Write a raw list pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the list content.\n * @param {ListElementSize} size The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {Pointer} p The pointer to write to.\n * @param {ObjectSize} [compositeSize] For composite lists this describes the size of each element in this list. This\n * is required for composite lists.\n * @returns {void}\n */\nfunction setListPointer(offsetWords, size, length, p, compositeSize) {\n    if (p === undefined)\n        throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n    var A = pointer_type_1.PointerType.LIST;\n    var B = offsetWords;\n    var C = size;\n    var D = length;\n    if (size === list_element_size_1.ListElementSize.COMPOSITE) {\n        if (compositeSize === undefined)\n            throw new TypeError(errors_1.TYPE_COMPOSITE_SIZE_UNDEFINED);\n        D *= object_size_1.getWordLength(compositeSize);\n    }\n    p.segment.setUint32(p.byteOffset, A | B << 2);\n    p.segment.setUint32(p.byteOffset + 4, C | D << 3);\n}\nexports.setListPointer = setListPointer;\n/**\n * Write a raw struct pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the struct's data\n * section.\n * @param {ObjectSize} size An object describing the size of the struct.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setStructPointer(offsetWords, size, p) {\n    var A = pointer_type_1.PointerType.STRUCT;\n    var B = offsetWords;\n    var C = object_size_1.getDataWordLength(size);\n    var D = size.pointerLength;\n    p.segment.setUint32(p.byteOffset, A | B << 2);\n    p.segment.setUint16(p.byteOffset + 4, C);\n    p.segment.setUint16(p.byteOffset + 6, D);\n}\nexports.setStructPointer = setStructPointer;\n/**\n * Read some bits off a pointer to make sure it has the right pointer data.\n *\n * @param {PointerType} pointerType The expected pointer type.\n * @param {Pointer} p The pointer to validate.\n * @param {ListElementSize} [elementSize] For list pointers, the expected element size. Leave this\n * undefined for struct pointers.\n * @returns {void}\n */\nfunction validate(pointerType, p, elementSize) {\n    if (isNull(p))\n        return;\n    var t = followFars(p);\n    // Check the pointer type.\n    var A = t.segment.getUint32(t.byteOffset) & constants_1.POINTER_TYPE_MASK;\n    if (A !== pointerType)\n        throw new Error(util_1.format(errors_1.PTR_WRONG_POINTER_TYPE, p, pointerType));\n    // Check the list element size, if provided.\n    if (elementSize !== undefined) {\n        var C = t.segment.getUint32(t.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n        if (C !== elementSize)\n            throw new Error(util_1.format(errors_1.PTR_WRONG_LIST_TYPE, p, list_element_size_1.ListElementSize[elementSize]));\n    }\n}\nexports.validate = validate;\nfunction copyFromList(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcElementSize = getTargetListElementSize(src);\n    var srcLength = getTargetListLength(src);\n    var srcCompositeSize;\n    var srcStructByteLength;\n    var dstContent;\n    if (srcElementSize === list_element_size_1.ListElementSize.POINTER) {\n        dstContent = dst.segment.allocate(object_size_1.getByteLength(getTargetCompositeListSize(src)) * srcLength);\n        // Recursively copy each pointer in the list.\n        for (var i = 0; i < srcLength; i++) {\n            var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + (i << 3), src._capnp.depthLimit - 1);\n            var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + (i << 3), dst._capnp.depthLimit - 1);\n            copyFrom(srcPtr, dstPtr);\n        }\n    }\n    else if (srcElementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n        srcCompositeSize = object_size_1.padToWord(getTargetCompositeListSize(src));\n        srcStructByteLength = object_size_1.getByteLength(srcCompositeSize);\n        dstContent = dst.segment.allocate(object_size_1.getByteLength(srcCompositeSize) * srcLength + 8);\n        // Copy the tag word.\n        dstContent.segment.copyWord(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset - 8);\n        // Copy the entire contents, including all pointers. This should be more efficient than making `srcLength`\n        // copies to skip the pointer sections, and we're about to rewrite all those pointers anyway.\n        // PERF: Skip this step if the composite struct only contains pointers.\n        if (srcCompositeSize.dataByteLength > 0) {\n            var wordLength = object_size_1.getWordLength(srcCompositeSize) * srcLength;\n            dstContent.segment.copyWords(dstContent.byteOffset + 8, srcContent.segment, srcContent.byteOffset, wordLength);\n        }\n        // Recursively copy all the pointers in each struct.\n        for (var i = 0; i < srcLength; i++) {\n            for (var j = 0; j < srcCompositeSize.pointerLength; j++) {\n                var offset = i * srcStructByteLength + srcCompositeSize.dataByteLength + (j << 3);\n                var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n                var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset + 8, dst._capnp.depthLimit - 1);\n                copyFrom(srcPtr, dstPtr);\n            }\n        }\n    }\n    else {\n        var byteLength = util_1.padToWord(srcElementSize === list_element_size_1.ListElementSize.BIT\n            ? srcLength + 7 >>> 3\n            : getListElementByteLength(srcElementSize) * srcLength);\n        var wordLength = byteLength >>> 3;\n        dstContent = dst.segment.allocate(byteLength);\n        // Copy all of the list contents word-by-word.\n        dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, wordLength);\n    }\n    // Initialize the list pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setListPointer(res.offsetWords, srcElementSize, srcLength, res.pointer, srcCompositeSize);\n}\nexports.copyFromList = copyFromList;\nfunction copyFromStruct(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcSize = getTargetStructSize(src);\n    var srcDataWordLength = object_size_1.getDataWordLength(srcSize);\n    // Allocate space for the destination content.\n    var dstContent = dst.segment.allocate(object_size_1.getByteLength(srcSize));\n    // Copy the data section.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, srcDataWordLength);\n    // Copy the pointer section.\n    for (var i = 0; i < srcSize.pointerLength; i++) {\n        var offset = srcSize.dataByteLength + i * 8;\n        var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n        var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset, dst._capnp.depthLimit - 1);\n        copyFrom(srcPtr, dstPtr);\n    }\n    // Don't touch dst if it's already initialized as a composite list pointer. With composite struct pointers there's\n    // no pointer to copy here and we've already copied the contents.\n    if (dst._capnp.compositeList)\n        return;\n    // Initialize the struct pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setStructPointer(res.offsetWords, srcSize, res.pointer);\n}\nexports.copyFromStruct = copyFromStruct;\n/**\n * Track the allocation of a new Pointer object.\n *\n * This will decrement an internal counter tracking how many bytes have been traversed in the message so far. After\n * a certain limit, this method will throw an error in order to prevent a certain class of DoS attacks.\n *\n * @param {Message} message The message the pointer belongs to.\n * @param {Pointer} p The pointer being allocated.\n * @returns {void}\n */\nfunction trackPointerAllocation(message, p) {\n    message._capnp.traversalLimit -= 8;\n    if (message._capnp.traversalLimit <= 0) {\n        throw new Error(util_1.format(errors_1.PTR_TRAVERSAL_LIMIT_EXCEEDED, p));\n    }\n}\nexports.trackPointerAllocation = trackPointerAllocation;\n\n//# sourceMappingURL=pointer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/pointer.js\n// module id = 1\n// module chunks = 0","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslib/tslib.es6.js\n// module id = 2\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ListElementSize;\n(function (ListElementSize) {\n    ListElementSize[ListElementSize[\"VOID\"] = 0] = \"VOID\";\n    ListElementSize[ListElementSize[\"BIT\"] = 1] = \"BIT\";\n    ListElementSize[ListElementSize[\"BYTE\"] = 2] = \"BYTE\";\n    ListElementSize[ListElementSize[\"BYTE_2\"] = 3] = \"BYTE_2\";\n    ListElementSize[ListElementSize[\"BYTE_4\"] = 4] = \"BYTE_4\";\n    ListElementSize[ListElementSize[\"BYTE_8\"] = 5] = \"BYTE_8\";\n    ListElementSize[ListElementSize[\"POINTER\"] = 6] = \"POINTER\";\n    ListElementSize[ListElementSize[\"COMPOSITE\"] = 7] = \"COMPOSITE\";\n})(ListElementSize = exports.ListElementSize || (exports.ListElementSize = {}));\nexports.ListElementOffset = [\n    0,\n    0.125,\n    1,\n    2,\n    4,\n    8,\n    8,\n    NaN,\n];\n\n//# sourceMappingURL=list-element-size.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/list-element-size.js\n// module id = 3\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list');\ntrace('load');\n/**\n * A generic list class. Implements Filterable,\n */\nvar List = /** @class */ (function (_super) {\n    tslib_1.__extends(List, _super);\n    function List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    List.toString = function () {\n        return this._capnp.displayName;\n    };\n    List.prototype.all = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            if (!callbackfn(this.get(i), i))\n                return false;\n        }\n        return true;\n    };\n    List.prototype.any = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++)\n            if (callbackfn(this.get(i), i))\n                return true;\n        return false;\n    };\n    List.prototype.ap = function (callbackfns) {\n        var _this = this;\n        var length = this.getLength();\n        var res = [];\n        var _loop_1 = function (i) {\n            res.push.apply(res, callbackfns.map(function (f) { return f(_this.get(i), i); }));\n        };\n        for (var i = 0; i < length; i++) {\n            _loop_1(i);\n        }\n        return res;\n    };\n    List.prototype.concat = function (other) {\n        var length = this.getLength();\n        var otherLength = other.getLength();\n        var res = new Array(length + otherLength);\n        for (var i = 0; i < length; i++)\n            res[i] = this.get(i);\n        for (var i = 0; i < otherLength; i++)\n            res[i + length] = other.get(i);\n        return res;\n    };\n    List.prototype.drop = function (n) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = n; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.dropWhile = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        var drop = true;\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            if (drop)\n                drop = callbackfn(v, i);\n            if (!drop)\n                res.push(v);\n        }\n        return res;\n    };\n    List.prototype.empty = function () { return []; };\n    List.prototype.every = function (callbackfn) { return this.all(callbackfn); };\n    List.prototype.filter = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        for (var i = 0; i < length; i++) {\n            var value = this.get(i);\n            if (callbackfn(value, i))\n                res.push(value);\n        }\n        return res;\n    };\n    List.prototype.find = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            var value = this.get(i);\n            if (callbackfn(value, i))\n                return value;\n        }\n        return undefined;\n    };\n    List.prototype.forEach = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++)\n            callbackfn(this.get(i), i);\n    };\n    List.prototype.get = function (_index) {\n        throw new TypeError();\n    };\n    /**\n     * Get the length of this list.\n     *\n     * @returns {number} The number of elements in this list.\n     */\n    List.prototype.getLength = function () {\n        return pointer_1.getTargetListLength(this);\n    };\n    List.prototype.groupBy = function (callbackfn) {\n        var length = this.getLength();\n        var res = {};\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            res[callbackfn(v, i)] = v;\n        }\n        return res;\n    };\n    List.prototype.intersperse = function (sep) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = 0; i < length; i++) {\n            if (i > 0)\n                res.push(sep);\n            res.push(this.get(i));\n        }\n        return res;\n    };\n    List.prototype.map = function (callbackfn) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = 0; i < length; i++)\n            res[i] = callbackfn(this.get(i), i);\n        return res;\n    };\n    List.prototype.reduce = function (callbackfn, initialValue) {\n        var i = 0;\n        var res;\n        if (initialValue === undefined) {\n            // LINT: It's okay, I know what I'm doing here.\n            /* tslint:disable-next-line:no-any */\n            res = this.get(0);\n            i++;\n        }\n        else {\n            res = initialValue;\n        }\n        for (; i < this.getLength(); i++)\n            res = callbackfn(res, this.get(i), i);\n        return res;\n    };\n    List.prototype.set = function (_index, _value) {\n        throw new TypeError();\n    };\n    List.prototype.slice = function (start, end) {\n        if (start === void 0) { start = 0; }\n        var length = end ? Math.min(this.getLength(), end) : this.getLength();\n        var res = new Array(length - start);\n        for (var i = start; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.some = function (callbackfn) { return this.any(callbackfn); };\n    List.prototype.take = function (n) {\n        var length = Math.min(this.getLength(), n);\n        var res = new Array(length);\n        for (var i = 0; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.takeWhile = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        var take;\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            take = callbackfn(v, i);\n            if (!take)\n                return res;\n            res.push(v);\n        }\n        return res;\n    };\n    List.prototype.toArray = function () {\n        return this.map(util_1.identity);\n    };\n    List.prototype.toString = function () {\n        return \"List_\" + _super.prototype.toString.call(this);\n    };\n    List._capnp = {\n        displayName: 'List<Generic>',\n        size: list_element_size_1.ListElementSize.VOID,\n    };\n    List.initList = initList;\n    return List;\n}(pointer_1.Pointer));\nexports.List = List;\n/**\n * Initialize the list with the given element size and length. This will allocate new space for the list, ideally in\n * the same segment as this pointer.\n *\n * @param {ListElementSize} elementSize The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {List<T>} l The list to initialize.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list. This value is required for\n * composite lists.\n * @returns {void}\n */\nfunction initList(elementSize, length, l, compositeSize) {\n    var c;\n    switch (elementSize) {\n        case list_element_size_1.ListElementSize.BIT:\n            c = l.segment.allocate(Math.ceil(length / 8));\n            break;\n        case list_element_size_1.ListElementSize.BYTE:\n        case list_element_size_1.ListElementSize.BYTE_2:\n        case list_element_size_1.ListElementSize.BYTE_4:\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n            c = l.segment.allocate(length * pointer_1.getListElementByteLength(elementSize));\n            break;\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            if (compositeSize === undefined)\n                throw new Error(util_1.format(errors_1.PTR_COMPOSITE_SIZE_UNDEFINED));\n            compositeSize = object_size_1.padToWord(compositeSize);\n            var byteLength = object_size_1.getByteLength(compositeSize) * length;\n            // We need to allocate an extra 8 bytes for the tag word, then make sure we write the length to it. We advance\n            // the content pointer by 8 bytes so that it then points to the first list element as intended. Everything\n            // starts off zeroed out so these nested structs don't need to be initialized in any way.\n            c = l.segment.allocate(byteLength + 8);\n            pointer_1.setStructPointer(length, compositeSize, c);\n            trace('Wrote composite tag word %s for %s.', c, l);\n            break;\n        case list_element_size_1.ListElementSize.VOID:\n            // No need to allocate anything, we can write the list pointer right here.\n            pointer_1.setListPointer(0, elementSize, length, l);\n            return;\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n    }\n    var res = pointer_1.initPointer(c.segment, c.byteOffset, l);\n    pointer_1.setListPointer(res.offsetWords, elementSize, length, res.pointer, compositeSize);\n}\nexports.initList = initList;\n\n//# sourceMappingURL=list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/list.js\n// module id = 4\n// module chunks = 0","\"use strict\";\n/**\n * This file contains all the error strings used in the library. Also contains silliness.\n *\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"./constants\");\nvar trace = debug_1.default('capnp:errors');\ntrace('load');\nfunction assertNever(n) {\n    throw new Error(exports.INVARIANT_UNREACHABLE_CODE + (\" (never block hit with: \" + n + \")\"));\n}\nexports.assertNever = assertNever;\n// Invariant violations (sometimes known as \"precondition failed\").\n//\n// All right, hold up the brakes. This is a serious 1 === 0 WHAT THE FAILURE moment here. Tell the SO's you won't be\n// home for dinner.\nexports.INVARIANT_UNREACHABLE_CODE = 'CAPNP-TS000 Unreachable code detected.';\n// Message errors.\n//\n// Now who told you it would be a good idea to fuzz the inputs? You just made the program sad.\nexports.MSG_INVALID_FRAME_HEADER = 'CAPNP-TS001 Attempted to parse an invalid message frame header; are you sure this is a Cap\\'n Proto message?';\nexports.MSG_NO_SEGMENTS_IN_ARENA = 'CAPNP-TS002 Attempted to preallocate a message with no segments in the arena.';\nexports.MSG_PACK_NOT_WORD_ALIGNED = 'CAPNP-TS003 Attempted to pack a message that was not word-aligned.';\nexports.MSG_SEGMENT_OUT_OF_BOUNDS = 'CAPNP-TS004 Segment ID %X is out of bounds for message %s.';\nexports.MSG_SEGMENT_TOO_SMALL = 'CAPNP-TS005 First segment must have at least enough room to hold the root pointer (8 bytes).';\n// Used for methods that are not yet implemented.\n//\n// My bad. I'll get to it. Eventually.\nexports.NOT_IMPLEMENTED = 'CAPNP-TS006 %s is not implemented.';\n// Pointer-related errors.\n//\n// Look, this is probably the hardest part of the code. Cut some slack here! You probably found a bug.\nexports.PTR_ADOPT_COMPOSITE_STRUCT = 'CAPNP-TS007 Attempted to adopt a struct into a composite list (%s).';\nexports.PTR_ADOPT_WRONG_MESSAGE = 'CAPNP-TS008 Attempted to adopt %s into a pointer in a different message %s.';\nexports.PTR_ALREADY_ADOPTED = 'CAPNP-TS009 Attempted to adopt %s more than once.';\nexports.PTR_COMPOSITE_SIZE_UNDEFINED = 'CAPNP-TS010 Attempted to set a composite list without providing a composite element size.';\nexports.PTR_DEPTH_LIMIT_EXCEEDED = 'CAPNP-TS011 Nesting depth limit exceeded for %s.';\nexports.PTR_DISOWN_COMPOSITE_STRUCT = 'CAPNP-TS012 Attempted to disown a struct member from a composite list (%s).';\nexports.PTR_INIT_COMPOSITE_STRUCT = 'CAPNP-TS013 Attempted to initialize a struct member from a composite list (%s).';\nexports.PTR_INIT_NON_GROUP = 'CAPNP-TS014 Attempted to initialize a group field with a non-group struct class.';\nexports.PTR_INVALID_FAR_TARGET = 'CAPNP-TS015 Target of a far pointer (%s) is another far pointer.';\nexports.PTR_INVALID_LIST_SIZE = 'CAPNP-TS016 Invalid list element size: %x.';\nexports.PTR_INVALID_POINTER_TYPE = 'CAPNP-TS017 Invalid pointer type: %x.';\nexports.PTR_INVALID_UNION_ACCESS = 'CAPNP-TS018 Attempted to access getter on %s for union field %s that is not currently set (wanted: %d, found: %d).';\nexports.PTR_OFFSET_OUT_OF_BOUNDS = 'CAPNP-TS019 Pointer offset %a is out of bounds for underlying buffer.';\nexports.PTR_STRUCT_DATA_OUT_OF_BOUNDS = 'CAPNP-TS020 Attempted to access out-of-bounds struct data (struct: %s, %d bytes at %a, data words: %d).';\nexports.PTR_STRUCT_POINTER_OUT_OF_BOUNDS = 'CAPNP-TS021 Attempted to access out-of-bounds struct pointer (%s, index: %d, length: %d).';\nexports.PTR_TRAVERSAL_LIMIT_EXCEEDED = 'CAPNP-TS022 Traversal limit exceeded! Slow down! %s';\nexports.PTR_WRONG_LIST_TYPE = 'CAPNP-TS023 Cannot convert %s to a %s list.';\nexports.PTR_WRONG_POINTER_TYPE = 'CAPNP-TS024 Attempted to convert pointer %s to a %s type.';\nexports.PTR_WRONG_COMPOSITE_DATA_SIZE = 'CAPNP-TS025 Attempted to convert %s to a composite list with the wrong data size (found: %d).';\nexports.PTR_WRONG_COMPOSITE_PTR_SIZE = 'CAPNP-TS026 Attempted to convert %s to a composite list with the wrong pointer size (found: %d).';\nexports.PTR_WRONG_STRUCT_DATA_SIZE = 'CAPNP-TS027 Attempted to convert %s to a struct with the wrong data size (found: %d).';\nexports.PTR_WRONG_STRUCT_PTR_SIZE = 'CAPNP-TS028 Attempted to convert %s to a struct with the wrong pointer size (found: %d).';\n// Custom error messages for the built-in `RangeError` class.\n//\n// You don't get a witty comment with these.\nexports.RANGE_INT32_OVERFLOW = 'CAPNP-TS029 32-bit signed integer overflow detected.';\nexports.RANGE_INT64_UNDERFLOW = 'CAPNP-TS030 Buffer is not large enough to hold a word.';\nexports.RANGE_INVALID_UTF8 = 'CAPNP-TS031 Invalid UTF-8 code sequence detected.';\nexports.RANGE_SIZE_OVERFLOW = \"CAPNP-TS032 Size %x exceeds maximum \" + constants_1.MAX_SEGMENT_LENGTH.toString(16) + \".\";\nexports.RANGE_UINT32_OVERFLOW = 'CAPNP-TS033 32-bit unsigned integer overflow detected.';\n// Segment-related errors.\n//\n// These suck. Deal with it.\nexports.SEG_BUFFER_NOT_ALLOCATED = 'CAPNP-TS034 allocate() needs to be called at least once before getting a buffer.';\nexports.SEG_GET_NON_ZERO_SINGLE = 'CAPNP-TS035 Attempted to get a segment other than 0 (%d) from a single segment arena.';\nexports.SEG_ID_OUT_OF_BOUNDS = 'CAPNP-TS036 Attempted to get an out-of-bounds segment (%d).';\nexports.SEG_NOT_WORD_ALIGNED = 'CAPNP-TS037 Segment buffer length %d is not a multiple of 8.';\nexports.SEG_REPLACEMENT_BUFFER_TOO_SMALL = 'CAPNP-TS038 Attempted to replace a segment buffer with one that is smaller than the allocated space.';\nexports.SEG_SIZE_OVERFLOW = \"CAPNP-TS039 Requested size %x exceeds maximum value (\" + constants_1.MAX_SEGMENT_LENGTH + \").\";\n// Custom error messages for the built-in `TypeError` class.\n//\n// If it looks like a duck, quacks like an elephant, and has hooves for feet, it's probably JavaScript.\nexports.TYPE_COMPOSITE_SIZE_UNDEFINED = 'CAPNP-TS040 Must provide a composite element size for composite list pointers.';\nexports.TYPE_GET_GENERIC_LIST = 'CAPNP-TS041 Attempted to call get() on a generic list.';\nexports.TYPE_SET_GENERIC_LIST = 'CAPNP-TS042 Attempted to call set() on a generic list.';\n\n//# sourceMappingURL=errors.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/errors.js\n// module id = 5\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// LINT: a lot of the util functions need the any type.\n/* tslint:disable:no-any no-unsafe-any */\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"./constants\");\nvar errors_1 = require(\"./errors\");\nvar trace = debug_1.default('capnp:util');\ntrace('load');\n/**\n * Dump a hex string from the given buffer.\n *\n * @export\n * @param {ArrayBuffer} buffer The buffer to convert.\n * @returns {string} A hexadecimal string representing the buffer.\n */\nfunction bufferToHex(buffer) {\n    var a = new Uint8Array(buffer);\n    var h = [];\n    for (var i = 0; i < a.byteLength; i++)\n        h.push(pad(a[i].toString(16), 2));\n    return \"[\" + h.join(' ') + \"]\";\n}\nexports.bufferToHex = bufferToHex;\n/**\n * Throw an error if the provided value cannot be represented as a 32-bit integer.\n *\n * @export\n * @param {number} value The number to check.\n * @returns {number} The same number if it is valid.\n */\nfunction checkInt32(value) {\n    if (value > constants_1.MAX_INT32 || value < -constants_1.MAX_INT32)\n        throw new RangeError(errors_1.RANGE_INT32_OVERFLOW);\n    return value;\n}\nexports.checkInt32 = checkInt32;\nfunction checkUint32(value) {\n    if (value < 0 || value > constants_1.MAX_UINT32)\n        throw new RangeError(errors_1.RANGE_UINT32_OVERFLOW);\n    return value;\n}\nexports.checkUint32 = checkUint32;\n/**\n * Decode a UTF-8 encoded byte array into a JavaScript string (UCS-2).\n *\n * @export\n * @param {Uint8Array} src A utf-8 encoded byte array.\n * @returns {string} A string representation of the byte array.\n */\nfunction decodeUtf8(src) {\n    // This ain't for the faint of heart, kids. If you suffer from seizures, heart palpitations, or have had a history of\n    // stroke you may want to look away now.\n    var l = src.byteLength;\n    var dst = '';\n    var i = 0;\n    var cp = 0;\n    var a = 0;\n    var b = 0;\n    var c = 0;\n    var d = 0;\n    while (i < l) {\n        a = src[i++];\n        if ((a & 128) === 0) {\n            cp = a;\n        }\n        else if ((a & 224) === 192) {\n            if (i >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            cp = ((a & 31) << 6) | (b & 63);\n        }\n        else if ((a & 240) === 224) {\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            cp = ((a & 15) << 12) | ((b & 63) << 6) | (c & 63);\n        }\n        else if ((a & 248) === 240) {\n            if (i + 2 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            d = src[i++];\n            cp = ((a & 7) << 18) | ((b & 63) << 12) | ((c & 63) << 6) | (d & 63);\n        }\n        else {\n            throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n        }\n        if (cp <= 0xd7ff || (cp >= 0xe000 && cp <= 0xffff)) {\n            dst += String.fromCharCode(cp);\n        }\n        else {\n            // We must reach into the astral plane and construct the surrogate pair!\n            cp -= 0x00010000;\n            var hi = (cp >>> 10) + 0xd800;\n            var lo = (cp & 0x03ff) + 0xdc00;\n            if (hi < 0xd800 || hi > 0xdbff)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            dst += String.fromCharCode(hi, lo);\n        }\n    }\n    return dst;\n}\nexports.decodeUtf8 = decodeUtf8;\nfunction dumpBuffer(buffer) {\n    var b = buffer instanceof ArrayBuffer\n        ? new Uint8Array(buffer)\n        : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    var byteLength = Math.min(b.byteLength, constants_1.MAX_BUFFER_DUMP_BYTES);\n    var r = format('\\n=== buffer[%d] ===', byteLength);\n    for (var j = 0; j < byteLength; j += 16) {\n        r += \"\\n\" + pad(j.toString(16), 8) + \": \";\n        var s = '';\n        var k = void 0;\n        for (k = 0; k < 16 && j + k < b.byteLength; k++) {\n            var v = b[j + k];\n            r += pad(v.toString(16), 2) + \" \";\n            // Printable ASCII range.\n            s += v > 31 && v < 255 ? String.fromCharCode(v) : '·';\n            if (k === 7)\n                r += ' ';\n        }\n        r += \"\" + repeat((17 - k) * 3, ' ') + s;\n    }\n    r += '\\n';\n    if (byteLength !== b.byteLength) {\n        r += format('=== (truncated %d bytes) ===\\n', b.byteLength - byteLength);\n    }\n    return r;\n}\nexports.dumpBuffer = dumpBuffer;\n/**\n * Encode a JavaScript string (UCS-2) to a UTF-8 encoded string inside a Uint8Array.\n *\n * Note that the underlying buffer for the array will likely be larger than the actual contents; ignore the extra bytes.\n *\n * @export\n * @param {string} src The input string.\n * @returns {Uint8Array} A UTF-8 encoded buffer with the string's contents.\n */\nfunction encodeUtf8(src) {\n    var l = src.length;\n    var dst = new Uint8Array(new ArrayBuffer(l * 4));\n    var j = 0;\n    for (var i = 0; i < l; i++) {\n        var c = src.charCodeAt(i);\n        if (c <= 0x7f) {\n            dst[j++] = c;\n        }\n        else if (c <= 0x07ff) {\n            dst[j++] = 192 | (c >>> 6);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else if (c <= 0xd7ff || c >= 0xe000) {\n            dst[j++] = 224 | (c >>> 12);\n            dst[j++] = 128 | ((c >>> 6) & 63);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else {\n            // Make sure the surrogate pair is complete.\n            /* istanbul ignore next */\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            // I cast thee back into the astral plane.\n            var hi = c - 0xd800;\n            var lo = src.charCodeAt(++i) - 0xdc00;\n            var cp = ((hi << 10) | lo) + 0x00010000;\n            dst[j++] = 240 | (cp >>> 18);\n            dst[j++] = 128 | ((cp >>> 12) & 63);\n            dst[j++] = 128 | ((cp >>> 6) & 63);\n            dst[j++] = 128 | ((cp >>> 0) & 63);\n        }\n    }\n    return dst.subarray(0, j);\n}\nexports.encodeUtf8 = encodeUtf8;\n/**\n * Produce a `printf`-style string. Nice for providing arguments to `assert` without paying the cost for string\n * concatenation up front. Precision is supported for floating point numbers.\n *\n * @param {string} s The format string. Supported format specifiers: b, c, d, f, j, o, s, x, and X.\n * @param {...any} args Values to be formatted in the string. Arguments beyond what are consumed by the format string\n * are ignored.\n * @returns {string} The formatted string.\n */\nfunction format(s) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var n = s.length;\n    var arg;\n    var argIndex = 0;\n    var c;\n    var escaped = false;\n    var i = 0;\n    var leadingZero = false;\n    var precision;\n    var result = '';\n    function nextArg() {\n        return args[argIndex++];\n    }\n    function slurpNumber() {\n        var digits = '';\n        while (/\\d/.test(s[i])) {\n            digits += s[i++];\n            c = s[i];\n        }\n        return digits.length > 0 ? parseInt(digits, 10) : null;\n    }\n    for (; i < n; ++i) {\n        c = s[i];\n        if (escaped) {\n            escaped = false;\n            if (c === '.') {\n                leadingZero = false;\n                c = s[++i];\n            }\n            else if (c === '0' && s[i + 1] === '.') {\n                leadingZero = true;\n                i += 2;\n                c = s[i];\n            }\n            else {\n                leadingZero = true;\n            }\n            precision = slurpNumber();\n            switch (c) {\n                case 'a':// number in hex with padding\n                    result += '0x' + pad(parseInt(nextArg(), 10).toString(16), 8);\n                    break;\n                case 'b':// number in binary\n                    result += parseInt(nextArg(), 10).toString(2);\n                    break;\n                case 'c':// character\n                    arg = nextArg();\n                    if (typeof arg === 'string' || arg instanceof String) {\n                        result += arg;\n                    }\n                    else {\n                        result += String.fromCharCode(parseInt(arg, 10));\n                    }\n                    break;\n                case 'd':// number in decimal\n                    result += parseInt(nextArg(), 10);\n                    break;\n                case 'f':// floating point number\n                    var tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n                    result += leadingZero ? tmp : tmp.replace(/^0/, '');\n                    break;\n                case 'j':// JSON\n                    result += JSON.stringify(nextArg());\n                    break;\n                case 'o':// number in octal\n                    result += '0' + parseInt(nextArg(), 10).toString(8);\n                    break;\n                case 's':// string\n                    result += nextArg();\n                    break;\n                case 'x':// lowercase hexadecimal\n                    result += '0x' + parseInt(nextArg(), 10).toString(16);\n                    break;\n                case 'X':// uppercase hexadecimal\n                    result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();\n                    break;\n                default:\n                    result += c;\n                    break;\n            }\n        }\n        else if (c === '%') {\n            escaped = true;\n        }\n        else {\n            result += c;\n        }\n    }\n    return result;\n}\nexports.format = format;\n/**\n * Return the thing that was passed in. Yaaaaawn.\n *\n * @export\n * @template T\n * @param {T} x A thing.\n * @returns {T} The same thing.\n */\nfunction identity(x) {\n    return x;\n}\nexports.identity = identity;\nfunction pad(v, width, pad) {\n    if (pad === void 0) { pad = '0'; }\n    return v.length >= width ? v : new Array(width - v.length + 1).join(pad) + v;\n}\nexports.pad = pad;\n/**\n * Add padding to a number to make it divisible by 8. Typically used to pad byte sizes so they align to a word boundary.\n *\n * @export\n * @param {number} size The number to pad.\n * @returns {number} The padded number.\n */\nfunction padToWord(size) {\n    return (size + 7) & ~7;\n}\nexports.padToWord = padToWord;\n/**\n * Repeat a string n times. Shamelessly copied from lodash.repeat.\n *\n * @param {number} times Number of times to repeat.\n * @param {string} str The string to repeat.\n * @returns {string} The repeated string.\n */\nfunction repeat(times, str) {\n    var out = '';\n    var n = times;\n    var s = str;\n    if (n < 1 || n > Number.MAX_VALUE)\n        return out;\n    // https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    do {\n        if (n % 2)\n            out += s;\n        n = Math.floor(n / 2);\n        if (n)\n            s += s;\n    } while (n);\n    return out;\n}\nexports.repeat = repeat;\n// Set up custom debug formatters.\n/* tslint:disable:no-string-literal */\n/* istanbul ignore next */\ndebug_1.default.formatters['h'] = function (v) { return v.toString('hex'); };\n/* istanbul ignore next */\ndebug_1.default.formatters['x'] = function (v) { return \"0x\" + v.toString(16); };\n/* istanbul ignore next */\ndebug_1.default.formatters['a'] = function (v) { return \"0x\" + pad(v.toString(16), 8); };\n/* istanbul ignore next */\ndebug_1.default.formatters['X'] = function (v) { return \"0x\" + v.toString(16).toUpperCase(); };\n/* tslint:enable:no-string-literal */\n\n//# sourceMappingURL=util.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/util.js\n// module id = 6\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Perform some bit gymnastics to determine the native endian format.\nvar tmpWord = new DataView(new ArrayBuffer(8));\n(new Uint16Array(tmpWord.buffer))[0] = 0x0102;\n/** Default size (in bytes) for newly allocated segments. */\nexports.DEFAULT_BUFFER_SIZE = 4096;\nexports.DEFAULT_DECODE_LIMIT = 64 << 20; // 64 MiB\n/**\n * Limit to how deeply nested pointers are allowed to be. The root struct of a message will start at this value, and it\n * is decremented as pointers are dereferenced.\n */\nexports.DEFAULT_DEPTH_LIMIT = 64;\n/**\n * Limit to the number of **bytes** that can be traversed in a single message. This is necessary to prevent certain\n * classes of DoS attacks where maliciously crafted data can be self-referencing in a way that wouldn't trigger the\n * depth limit.\n *\n * For this reason, it is advised to cache pointers into variables and not constantly dereference them since the\n * message's traversal limit gets decremented each time.\n */\nexports.DEFAULT_TRAVERSE_LIMIT = 64 << 20; // 64 MiB\n/**\n * When allocating array buffers dynamically (while packing or in certain Arena implementations) the previous buffer's\n * size is multiplied by this number to determine the next buffer's size. This is chosen to keep both time spent\n * reallocating and wasted memory to a minimum.\n *\n * Smaller numbers would save memory at the expense of CPU time.\n */\nexports.GROWTH_FACTOR = 1.5;\n/** A bitmask applied to obtain the size of a list pointer. */\nexports.LIST_SIZE_MASK = 0x00000007;\n/** Maximum number of bytes to dump at once when dumping array buffers to string. */\nexports.MAX_BUFFER_DUMP_BYTES = 8192;\n/** The maximum value for a 32-bit integer. */\nexports.MAX_INT32 = 0x7fffffff;\n/** The maximum value for a 32-bit unsigned integer. */\nexports.MAX_UINT32 = 0xffffffff;\n/** The largest integer that can be precisely represented in JavaScript. */\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n/** Maximum limit on the number of segments in a message stream. */\nexports.MAX_STREAM_SEGMENTS = 512;\n/** The smallest integer that can be precisely represented in JavaScript. */\nexports.MIN_SAFE_INTEGER = -9007199254740991;\n/** Minimum growth increment for a SingleSegmentArena. */\nexports.MIN_SINGLE_SEGMENT_GROWTH = 4096;\n/**\n * This will be `true` if the machine running this code stores numbers natively in little-endian format. This is useful\n * for some numeric type conversions when the endianness does not affect the output. Using the native endianness for\n * these operations is _slightly_ faster.\n */\nexports.NATIVE_LITTLE_ENDIAN = tmpWord.getUint8(0) === 0x02;\n/**\n * When packing a message, this is the number of zero bytes required after a SPAN (0xff) tag is written to the packed\n * message before the span is terminated.\n *\n * This little detail is left up to the implementation because it can be tuned for performance. Setting this to a higher\n * value may help with messages that contain a ton of text/data.\n *\n * It is imperative to never set this below 1 or else BAD THINGS. You have been warned.\n */\nexports.PACK_SPAN_THRESHOLD = 2;\n/**\n * How far to travel into a nested pointer structure during a deep copy; when this limit is exhausted the copy\n * operation will throw an error.\n */\nexports.POINTER_COPY_LIMIT = 32;\n/** A bitmask for looking up the double-far flag on a far pointer. */\nexports.POINTER_DOUBLE_FAR_MASK = 0x00000004;\n/** A bitmask for looking up the pointer type. */\nexports.POINTER_TYPE_MASK = 0x00000003;\n/** Used for some 64-bit conversions, equal to Math.pow(2, 32). */\nexports.VAL32 = 0x100000000;\n/** The maximum value allowed for depth traversal limits. */\nexports.MAX_DEPTH = exports.MAX_INT32;\n/** The maximum byte length for a single segment. */\nexports.MAX_SEGMENT_LENGTH = exports.MAX_UINT32;\n\n//# sourceMappingURL=constants.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/constants.js\n// module id = 7\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar _ = require(\"../util\");\nvar trace = debug_1.default('capnp:object-size');\ntrace('load');\n/**\n * A simple object that describes the size of a struct.\n *\n * @export\n * @class ObjectSize\n */\nvar ObjectSize = /** @class */ (function () {\n    function ObjectSize(dataByteLength, pointerCount) {\n        this.dataByteLength = dataByteLength;\n        this.pointerLength = pointerCount;\n    }\n    ObjectSize.prototype.toString = function () {\n        return _.format('ObjectSize_dw:%d,pc:%d', getDataWordLength(this), this.pointerLength);\n    };\n    return ObjectSize;\n}());\nexports.ObjectSize = ObjectSize;\nfunction getByteLength(o) {\n    return o.dataByteLength + o.pointerLength * 8;\n}\nexports.getByteLength = getByteLength;\nfunction getDataWordLength(o) {\n    return o.dataByteLength / 8;\n}\nexports.getDataWordLength = getDataWordLength;\nfunction getWordLength(o) {\n    return o.dataByteLength / 8 + o.pointerLength;\n}\nexports.getWordLength = getWordLength;\nfunction padToWord(o) {\n    return new ObjectSize(_.padToWord(o.dataByteLength), o.pointerLength);\n}\nexports.padToWord = padToWord;\n\n//# sourceMappingURL=object-size.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/object-size.js\n// module id = 8\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PointerType;\n(function (PointerType) {\n    PointerType[PointerType[\"STRUCT\"] = 0] = \"STRUCT\";\n    PointerType[PointerType[\"LIST\"] = 1] = \"LIST\";\n    PointerType[PointerType[\"FAR\"] = 2] = \"FAR\";\n    PointerType[PointerType[\"OTHER\"] = 3] = \"OTHER\";\n})(PointerType = exports.PointerType || (exports.PointerType = {}));\n\n//# sourceMappingURL=pointer-type.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js\n// module id = 9\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nfunction PointerList(PointerClass) {\n    return _a = /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.get = function (index) {\n                var c = pointer_1.getContent(this);\n                return new PointerClass(c.segment, c.byteOffset + index * 8, this._capnp.depthLimit - 1);\n            };\n            class_1.prototype.set = function (index, value) {\n                pointer_1.copyFrom(value, this.get(index));\n            };\n            class_1.prototype.toString = function () {\n                return \"Pointer_\" + _super.prototype.toString.call(this) + \",cls:\" + PointerClass.toString();\n            };\n            return class_1;\n        }(list_1.List)),\n        _a._capnp = {\n            displayName: \"List<\" + PointerClass._capnp.displayName + \">\",\n            size: list_element_size_1.ListElementSize.POINTER,\n        },\n        _a;\n    var _a;\n}\nexports.PointerList = PointerList;\n\n//# sourceMappingURL=pointer-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js\n// module id = 10\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ArenaKind;\n(function (ArenaKind) {\n    ArenaKind[ArenaKind[\"SINGLE_SEGMENT\"] = 0] = \"SINGLE_SEGMENT\";\n    ArenaKind[ArenaKind[\"MULTI_SEGMENT\"] = 1] = \"MULTI_SEGMENT\";\n})(ArenaKind = exports.ArenaKind || (exports.ArenaKind = {}));\n\n//# sourceMappingURL=arena-kind.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/arena/arena-kind.js\n// module id = 11\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar serialization_1 = require(\"./serialization\");\nexports.ListElementSize = serialization_1.ListElementSize;\nexports.Message = serialization_1.Message;\nexports.ObjectSize = serialization_1.ObjectSize;\nexports.AnyPointerList = serialization_1.AnyPointerList;\nexports.BoolList = serialization_1.BoolList;\nexports.CompositeList = serialization_1.CompositeList;\nexports.Data = serialization_1.Data;\nexports.DataList = serialization_1.DataList;\nexports.Float32List = serialization_1.Float32List;\nexports.Float64List = serialization_1.Float64List;\nexports.Int16List = serialization_1.Int16List;\nexports.Int32List = serialization_1.Int32List;\nexports.Int64List = serialization_1.Int64List;\nexports.Int8List = serialization_1.Int8List;\nexports.Interface = serialization_1.Interface;\nexports.InterfaceList = serialization_1.InterfaceList;\nexports.List = serialization_1.List;\nexports.Orphan = serialization_1.Orphan;\nexports.PointerList = serialization_1.PointerList;\nexports.PointerType = serialization_1.PointerType;\nexports.Pointer = serialization_1.Pointer;\nexports.Struct = serialization_1.Struct;\nexports.Text = serialization_1.Text;\nexports.TextList = serialization_1.TextList;\nexports.Uint16List = serialization_1.Uint16List;\nexports.Uint32List = serialization_1.Uint32List;\nexports.Uint64List = serialization_1.Uint64List;\nexports.Uint8List = serialization_1.Uint8List;\nexports.VoidList = serialization_1.VoidList;\nexports.Void = serialization_1.Void;\nexports.getBitMask = serialization_1.getBitMask;\nexports.getFloat32Mask = serialization_1.getFloat32Mask;\nexports.getFloat64Mask = serialization_1.getFloat64Mask;\nexports.getInt16Mask = serialization_1.getInt16Mask;\nexports.getInt32Mask = serialization_1.getInt32Mask;\nexports.getInt64Mask = serialization_1.getInt64Mask;\nexports.getInt8Mask = serialization_1.getInt8Mask;\nexports.getUint16Mask = serialization_1.getUint16Mask;\nexports.getUint32Mask = serialization_1.getUint32Mask;\nexports.getUint64Mask = serialization_1.getUint64Mask;\nexports.getUint8Mask = serialization_1.getUint8Mask;\nvar types_1 = require(\"./types\");\nexports.Int64 = types_1.Int64;\nexports.Uint64 = types_1.Uint64;\n\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/index.js\n// module id = 12\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar any_pointer_list_1 = require(\"./any-pointer-list\");\nexports.AnyPointerList = any_pointer_list_1.AnyPointerList;\nvar bool_list_1 = require(\"./bool-list\");\nexports.BoolList = bool_list_1.BoolList;\nvar composite_list_1 = require(\"./composite-list\");\nexports.CompositeList = composite_list_1.CompositeList;\nvar data_1 = require(\"./data\");\nexports.Data = data_1.Data;\nvar data_list_1 = require(\"./data-list\");\nexports.DataList = data_list_1.DataList;\nvar float32_list_1 = require(\"./float32-list\");\nexports.Float32List = float32_list_1.Float32List;\nvar float64_list_1 = require(\"./float64-list\");\nexports.Float64List = float64_list_1.Float64List;\nvar int8_list_1 = require(\"./int8-list\");\nexports.Int8List = int8_list_1.Int8List;\nvar int16_list_1 = require(\"./int16-list\");\nexports.Int16List = int16_list_1.Int16List;\nvar int32_list_1 = require(\"./int32-list\");\nexports.Int32List = int32_list_1.Int32List;\nvar int64_list_1 = require(\"./int64-list\");\nexports.Int64List = int64_list_1.Int64List;\nvar interface_1 = require(\"./interface\");\nexports.Interface = interface_1.Interface;\nvar interface_list_1 = require(\"./interface-list\");\nexports.InterfaceList = interface_list_1.InterfaceList;\nvar list_1 = require(\"./list\");\nexports.List = list_1.List;\nvar orphan_1 = require(\"./orphan\");\nexports.Orphan = orphan_1.Orphan;\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.PointerList = pointer_list_1.PointerList;\nvar pointer_type_1 = require(\"./pointer-type\");\nexports.PointerType = pointer_type_1.PointerType;\nvar pointer_1 = require(\"./pointer\");\nexports.Pointer = pointer_1.Pointer;\nvar struct_1 = require(\"./struct\");\nexports.Struct = struct_1.Struct;\nvar text_1 = require(\"./text\");\nexports.Text = text_1.Text;\nvar text_list_1 = require(\"./text-list\");\nexports.TextList = text_list_1.TextList;\nvar uint8_list_1 = require(\"./uint8-list\");\nexports.Uint8List = uint8_list_1.Uint8List;\nvar uint16_list_1 = require(\"./uint16-list\");\nexports.Uint16List = uint16_list_1.Uint16List;\nvar uint32_list_1 = require(\"./uint32-list\");\nexports.Uint32List = uint32_list_1.Uint32List;\nvar uint64_list_1 = require(\"./uint64-list\");\nexports.Uint64List = uint64_list_1.Uint64List;\nvar void_1 = require(\"./void\");\nexports.Void = void_1.Void;\nexports.VOID = void_1.VOID;\nvar void_list_1 = require(\"./void-list\");\nexports.VoidList = void_list_1.VoidList;\n\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/index.js\n// module id = 13\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default('capnp:data');\ntrace('load');\n/**\n * A generic blob of bytes. Can be converted to a DataView or Uint8Array to access its contents using `toDataView()` and\n * `toUint8Array()`. Use `copyBuffer()` to copy an entire buffer at once.\n *\n * @export\n * @class Data\n * @extends {List<number>}\n */\nvar Data = /** @class */ (function (_super) {\n    tslib_1.__extends(Data, _super);\n    function Data() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Data.fromPointer = function (pointer) {\n        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n        return this._fromPointerUnchecked(pointer);\n    };\n    Data._fromPointerUnchecked = function (pointer) {\n        return new this(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n    };\n    /**\n     * Copy the contents of `src` into this Data pointer. If `src` is smaller than the length of this pointer then the\n     * remaining bytes will be zeroed out. Extra bytes in `src` are ignored.\n     *\n     * @param {(ArrayBuffer | ArrayBufferView)} src The source buffer.\n     * @returns {void}\n     */\n    // TODO: Would be nice to have a way to zero-copy a buffer by allocating a new segment into the message with that\n    // buffer data.\n    Data.prototype.copyBuffer = function (src) {\n        var c = pointer_1.getContent(this);\n        var dstLength = this.getLength();\n        var srcLength = src.byteLength;\n        var i = src instanceof ArrayBuffer\n            ? new Uint8Array(src)\n            : new Uint8Array(src.buffer, src.byteOffset, Math.min(dstLength, srcLength));\n        var o = new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n        o.set(i);\n        if (dstLength > srcLength) {\n            trace('Zeroing out remaining %d bytes after copy into %s.', dstLength - srcLength, this);\n            o.fill(0, srcLength, dstLength);\n        }\n        else if (dstLength < srcLength) {\n            trace('Truncated %d bytes from source buffer while copying to %s.', srcLength - dstLength, this);\n        }\n    };\n    /**\n     * Read a byte from the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to read.\n     * @returns {number} The byte value.\n     */\n    Data.prototype.get = function (byteOffset) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint8(c.byteOffset + byteOffset);\n    };\n    /**\n     * Write a byte at the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to set.\n     * @param {number} value The byte value to set.\n     * @returns {void}\n     */\n    Data.prototype.set = function (byteOffset, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint8(c.byteOffset + byteOffset, value);\n    };\n    /**\n     * Creates a **copy** of the underlying buffer data and returns it as an ArrayBuffer.\n     *\n     * To obtain a reference to the underlying buffer instead, use `toUint8Array()` or `toDataView()`.\n     *\n     * @returns {ArrayBuffer} A copy of this data buffer.\n     */\n    Data.prototype.toArrayBuffer = function () {\n        var c = pointer_1.getContent(this);\n        return c.segment.buffer.slice(c.byteOffset, c.byteOffset + this.getLength());\n    };\n    /**\n     * Convert this Data pointer to a DataView representing the pointer's contents.\n     *\n     * WARNING: The DataView references memory from a message segment, so do not venture outside the bounds of the\n     * DataView or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toDataView = function () {\n        var c = pointer_1.getContent(this);\n        return new DataView(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    Data.prototype.toString = function () {\n        return \"Data_\" + _super.prototype.toString.call(this);\n    };\n    /**\n     * Convert this Data pointer to a Uint8Array representing the pointer's contents.\n     *\n     * WARNING: The Uint8Array references memory from a message segment, so do not venture outside the bounds of the\n     * Uint8Array or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toUint8Array = function () {\n        var c = pointer_1.getContent(this);\n        return new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    return Data;\n}(list_1.List));\nexports.Data = Data;\n\n//# sourceMappingURL=data.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/data.js\n// module id = 14\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar types_1 = require(\"../../types\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar data_1 = require(\"./data\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar text_1 = require(\"./text\");\nvar errors_1 = require(\"../../errors\");\nvar trace = debug_1.default('capnp:struct');\ntrace('load');\n// Used to apply bit masks (default values).\nvar TMP_WORD = new DataView(new ArrayBuffer(8));\nvar Struct = /** @class */ (function (_super) {\n    tslib_1.__extends(Struct, _super);\n    /**\n     * Create a new pointer to a struct.\n     *\n     * @constructor {Struct}\n     * @param {Segment} segment The segment the pointer resides in.\n     * @param {number} byteOffset The offset from the beginning of the segment to the beginning of the pointer data.\n     * @param {any} [depthLimit=MAX_DEPTH] The nesting depth limit for this object.\n     * @param {number} [compositeIndex] If set, then this pointer is actually a reference to a composite list\n     * (`this._getPointerTargetType() === PointerType.LIST`), and this number is used as the index of the struct within\n     * the list. It is not valid to call `initStruct()` on a composite struct – the struct contents are initialized when\n     * the list pointer is initialized.\n     */\n    function Struct(segment, byteOffset, depthLimit, compositeIndex) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        _this._capnp.compositeIndex = compositeIndex;\n        _this._capnp.compositeList = compositeIndex !== undefined;\n        return _this;\n    }\n    Struct.toString = function () {\n        return this._capnp.displayName;\n    };\n    Struct.prototype.toString = function () {\n        return \"Struct_\" + _super.prototype.toString.call(this) +\n            (\"\" + (this._capnp.compositeIndex === undefined ? '' : \",ci:\" + this._capnp.compositeIndex));\n    };\n    Struct._capnp = {\n        displayName: 'Struct',\n    };\n    Struct.getAs = getAs;\n    Struct.getBit = getBit;\n    Struct.getData = getData;\n    Struct.getFloat32 = getFloat32;\n    Struct.getFloat64 = getFloat64;\n    Struct.getUint8 = getUint8;\n    Struct.getUint16 = getUint16;\n    Struct.getUint32 = getUint32;\n    Struct.getUint64 = getUint64;\n    Struct.getInt8 = getInt8;\n    Struct.getInt16 = getInt16;\n    Struct.getInt32 = getInt32;\n    Struct.getInt64 = getInt64;\n    Struct.getList = getList;\n    Struct.getPointer = getPointer;\n    Struct.getPointerAs = getPointerAs;\n    Struct.getStruct = getStruct;\n    Struct.getText = getText;\n    Struct.initData = initData;\n    Struct.initList = initList;\n    Struct.initStruct = initStruct;\n    Struct.initStructAt = initStructAt;\n    Struct.setBit = setBit;\n    Struct.setFloat32 = setFloat32;\n    Struct.setFloat64 = setFloat64;\n    Struct.setUint8 = setUint8;\n    Struct.setUint16 = setUint16;\n    Struct.setUint32 = setUint32;\n    Struct.setUint64 = setUint64;\n    Struct.setInt8 = setInt8;\n    Struct.setInt16 = setInt16;\n    Struct.setInt32 = setInt32;\n    Struct.setInt64 = setInt64;\n    Struct.setText = setText;\n    Struct.testWhich = testWhich;\n    return Struct;\n}(pointer_1.Pointer));\nexports.Struct = Struct;\n/**\n * Initialize a struct with the provided object size. This will allocate new space for the struct contents, ideally in\n * the same segment as this pointer.\n *\n * @param {ObjectSize} size An object describing the size of the struct's data and pointer sections.\n * @param {Struct} s The struct to initialize.\n * @returns {void}\n */\nfunction initStruct(size, s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_INIT_COMPOSITE_STRUCT, s));\n    // Make sure to clear existing contents before overwriting the pointer data (erase is a noop if already empty).\n    pointer_1.erase(s);\n    var c = s.segment.allocate(object_size_1.getByteLength(size));\n    var res = pointer_1.initPointer(c.segment, c.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, size, res.pointer);\n}\nexports.initStruct = initStruct;\nfunction initStructAt(index, StructClass, p) {\n    var s = getPointerAs(index, StructClass, p);\n    initStruct(StructClass._capnp.size, s);\n    return s;\n}\nexports.initStructAt = initStructAt;\n/**\n * Make a shallow copy of a struct's contents and update the pointer to point to the new content. The data and pointer\n * sections will be resized to the provided size.\n *\n * WARNING: This method can cause data loss if `dstSize` is smaller than the original size!\n *\n * @param {ObjectSize} dstSize The desired size for the struct contents.\n * @param {Struct} s The struct to resize.\n * @returns {void}\n */\nfunction resize(dstSize, s) {\n    var srcSize = getSize(s);\n    var srcContent = pointer_1.getContent(s);\n    var dstContent = s.segment.allocate(object_size_1.getByteLength(dstSize));\n    // Only copy the data section for now. The pointer section will need to be rewritten.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, Math.min(object_size_1.getDataWordLength(srcSize), object_size_1.getDataWordLength(dstSize)));\n    var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, dstSize, res.pointer);\n    // Iterate through the new pointer section and update the offsets so they point to the right place. This is a bit\n    // more complicated than it appears due to the fact that the original pointers could have been far pointers, and\n    // the new pointers might need to be allocated as far pointers if the segment is full.\n    for (var i = 0; i < Math.min(srcSize.pointerLength, dstSize.pointerLength); i++) {\n        var srcPtr = new pointer_1.Pointer(srcContent.segment, srcContent.byteOffset + srcSize.dataByteLength + i * 8);\n        var srcPtrTarget = pointer_1.followFars(srcPtr);\n        var srcPtrContent = pointer_1.getContent(srcPtr);\n        var dstPtr = new pointer_1.Pointer(dstContent.segment, dstContent.byteOffset + dstSize.dataByteLength + i * 8);\n        // For composite lists the offset needs to point to the tag word, not the first element which is what getContent\n        // returns.\n        if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n            pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n            srcPtrContent.byteOffset -= 8;\n        }\n        var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n        // Read the old pointer data, but discard the original offset.\n        var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n        var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n        r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n        r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n    }\n    // Zero out the old data and pointer sections.\n    srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize));\n}\nexports.resize = resize;\nfunction adopt(src, s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_ADOPT_COMPOSITE_STRUCT, s));\n    pointer_1.Pointer.adopt(src, s);\n}\nexports.adopt = adopt;\nfunction disown(s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_DISOWN_COMPOSITE_STRUCT, s));\n    return pointer_1.Pointer.disown(s);\n}\nexports.disown = disown;\n/**\n * Convert a struct to a struct of the provided class. Particularly useful when casting to nested group types.\n *\n * @protected\n * @template T\n * @param {StructCtor<T>} StructClass The struct class to convert to. Not particularly useful if `Struct`.\n * @param {Struct} s The struct to convert.\n * @returns {T} A new instance of the desired struct class pointing to the same location.\n */\nfunction getAs(StructClass, s) {\n    return new StructClass(s.segment, s.byteOffset, s._capnp.depthLimit, s._capnp.compositeIndex);\n}\nexports.getAs = getAs;\n/**\n * Read a boolean (bit) value out of a struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {boolean} The value.\n */\nfunction getBit(bitOffset, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    if (defaultMask === undefined)\n        return (v & bitMask) !== 0;\n    var defaultValue = defaultMask.getUint8(0);\n    return ((v ^ defaultValue) & bitMask) !== 0;\n}\nexports.getBit = getBit;\nfunction getData(index, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        list_1.List.initList(list_element_size_1.ListElementSize.BYTE, 0, l);\n    }\n    return l;\n}\nexports.getData = getData;\nfunction getDataSection(s) {\n    return pointer_1.getContent(s);\n}\nexports.getDataSection = getDataSection;\n/**\n * Read a float32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getFloat32(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getFloat32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getFloat32 = getFloat32;\n/**\n * Read a float64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n        var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n        TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n        TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n        return TMP_WORD.getFloat64(0, constants_1.NATIVE_LITTLE_ENDIAN);\n    }\n    return ds.segment.getFloat64(ds.byteOffset + byteOffset);\n}\nexports.getFloat64 = getFloat64;\n/**\n * Read an int16 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt16(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n    TMP_WORD.setUint16(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt16(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt16 = getInt16;\n/**\n * Read an int32 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt32(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt32 = getInt32;\n/**\n * Read an int64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt64(ds.byteOffset + byteOffset);\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Int64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getInt64 = getInt64;\n/**\n * Read an int8 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt8(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n    TMP_WORD.setUint8(0, v);\n    return TMP_WORD.getInt8(0);\n}\nexports.getInt8 = getInt8;\nfunction getList(index, ListClass, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        list_1.List.initList(ListClass._capnp.size, 0, l, ListClass._capnp.compositeSize);\n    }\n    else if (ListClass._capnp.compositeSize !== undefined) {\n        // If this is a composite list we need to be sure the composite elements are big enough to hold everything as\n        // specified in the schema. If the new schema has added fields we'll need to \"resize\" (shallow-copy) the list so\n        // it has room for the new fields.\n        var srcSize = pointer_1.getTargetCompositeListSize(l);\n        var dstSize = ListClass._capnp.compositeSize;\n        if (dstSize.dataByteLength > srcSize.dataByteLength || dstSize.pointerLength > srcSize.pointerLength) {\n            var srcContent = pointer_1.getContent(l);\n            var srcLength = pointer_1.getTargetListLength(l);\n            trace('resizing composite list %s due to protocol upgrade, new size: %d', l, object_size_1.getByteLength(dstSize) * srcLength);\n            // Allocate an extra 8 bytes for the tag.\n            var dstContent = l.segment.allocate(object_size_1.getByteLength(dstSize) * srcLength + 8);\n            var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, l);\n            pointer_1.setListPointer(res.offsetWords, ListClass._capnp.size, srcLength, res.pointer, dstSize);\n            // Write the new tag word.\n            pointer_1.setStructPointer(srcLength, dstSize, dstContent);\n            // Seek ahead past the tag word before copying the content.\n            dstContent.byteOffset += 8;\n            for (var i = 0; i < srcLength; i++) {\n                var srcElementOffset = srcContent.byteOffset + i * object_size_1.getByteLength(srcSize);\n                var dstElementOffset = dstContent.byteOffset + i * object_size_1.getByteLength(dstSize);\n                // Copy the data section.\n                dstContent.segment.copyWords(dstElementOffset, srcContent.segment, srcElementOffset, object_size_1.getWordLength(srcSize));\n                // Iterate through the pointers and update the offsets so they point to the right place.\n                for (var j = 0; j < srcSize.pointerLength; j++) {\n                    var srcPtr = new pointer_1.Pointer(srcContent.segment, srcElementOffset + srcSize.dataByteLength + j * 8);\n                    var dstPtr = new pointer_1.Pointer(dstContent.segment, dstElementOffset + dstSize.dataByteLength + j * 8);\n                    var srcPtrTarget = pointer_1.followFars(srcPtr);\n                    var srcPtrContent = pointer_1.getContent(srcPtr);\n                    if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n                        pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n                        srcPtrContent.byteOffset -= 8;\n                    }\n                    var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n                    // Read the old pointer data, but discard the original offset.\n                    var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n                    var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n                    r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n                    r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n                }\n            }\n            // Zero out the old content.\n            srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize) * srcLength);\n        }\n    }\n    return l;\n}\nexports.getList = getList;\nfunction getPointer(index, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new pointer_1.Pointer(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointer = getPointer;\nfunction getPointerAs(index, PointerClass, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new PointerClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointerAs = getPointerAs;\nfunction getPointerSection(s) {\n    var ps = pointer_1.getContent(s);\n    ps.byteOffset += util_1.padToWord(getSize(s).dataByteLength);\n    return ps;\n}\nexports.getPointerSection = getPointerSection;\nfunction getSize(s) {\n    if (s._capnp.compositeIndex !== undefined) {\n        // For composite lists the object size is stored in a tag word right before the content.\n        var c = pointer_1.getContent(s, true);\n        c.byteOffset -= 8;\n        return pointer_1.getStructSize(c);\n    }\n    return pointer_1.getTargetStructSize(s);\n}\nexports.getSize = getSize;\nfunction getStruct(index, StructClass, s) {\n    var t = getPointerAs(index, StructClass, s);\n    if (pointer_1.isNull(t)) {\n        initStruct(StructClass._capnp.size, t);\n    }\n    else {\n        pointer_1.validate(pointer_type_1.PointerType.STRUCT, t);\n        var ts = pointer_1.getTargetStructSize(t);\n        // This can happen when reading a struct that was constructed with an older version of the same schema, and new\n        // fields were added to the struct. A shallow copy of the struct will be made so that there's enough room for the\n        // data and pointer sections. This will unfortunately leave a \"hole\" of zeroes in the message, but that hole will\n        // at least compress well.\n        if (ts.dataByteLength < StructClass._capnp.size.dataByteLength\n            || ts.pointerLength < StructClass._capnp.size.pointerLength) {\n            trace('need to resize child struct %s', t);\n            resize(StructClass._capnp.size, t);\n        }\n    }\n    return t;\n}\nexports.getStruct = getStruct;\nfunction getText(index, s) {\n    return text_1.Text.fromPointer(getPointer(index, s)).get(0);\n}\nexports.getText = getText;\n/**\n * Read an uint16 value out of a struct..\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint16(ds.byteOffset + byteOffset);\n    return ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n}\nexports.getUint16 = getUint16;\n/**\n * Read an uint32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint32(ds.byteOffset + byteOffset);\n    return ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n}\nexports.getUint32 = getUint32;\n/**\n * Read an uint64 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint64(ds.byteOffset + byteOffset);\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Uint64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getUint64 = getUint64;\n/**\n * Read an uint8 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint8(ds.byteOffset + byteOffset);\n    return ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n}\nexports.getUint8 = getUint8;\nfunction initData(index, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(list_element_size_1.ListElementSize.BYTE, length, l);\n    return l;\n}\nexports.initData = initData;\nfunction initList(index, ListClass, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(ListClass._capnp.size, length, l, ListClass._capnp.compositeSize);\n    return l;\n}\nexports.initList = initList;\n/**\n * Write a boolean (bit) value to the struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {boolean} value The value to write (writes a 0 for `false`, 1 for `true`).\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setBit(bitOffset, value, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var b = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    // If the default mask bit is set, that means `true` values are actually written as `0`.\n    if (defaultMask !== undefined)\n        value = (defaultMask.getUint8(0) & bitMask) !== 0 ? !value : value;\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value ? b | bitMask : b & ~bitMask);\n}\nexports.setBit = setBit;\n/**\n * Write a primitive float32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setFloat32(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat32 = setFloat32;\n/**\n * Write a primitive float64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat64(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var lo = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        var hi = TMP_WORD.getUint32(4, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(4, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, lo);\n        ds.segment.setUint32(ds.byteOffset + byteOffset + 4, hi);\n        return;\n    }\n    ds.segment.setFloat64(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat64 = setFloat64;\n/**\n * Write a primitive int16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt16(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint16(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint16(0, true);\n        ds.segment.setUint16(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt16(ds.byteOffset + byteOffset, value);\n}\nexports.setInt16 = setInt16;\n/**\n * Write a primitive int32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt32(ds.byteOffset + byteOffset, value);\n}\nexports.setInt32 = setInt32;\n/**\n * Write a primitive int64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Int64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Int64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setInt64(ds.byteOffset + byteOffset, value);\n}\nexports.setInt64 = setInt64;\n/**\n * Write a primitive int8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt8(0, value);\n        var v = TMP_WORD.getUint8(0) ^ defaultMask.getUint8(0);\n        ds.segment.setUint8(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt8(ds.byteOffset + byteOffset, value);\n}\nexports.setInt8 = setInt8;\nfunction setPointer(index, value, s) {\n    pointer_1.copyFrom(value, getPointer(index, s));\n}\nexports.setPointer = setPointer;\nfunction setText(index, value, s) {\n    text_1.Text.fromPointer(getPointer(index, s)).set(0, value);\n}\nexports.setText = setText;\n/**\n * Write a primitive uint16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint16(0, true);\n    ds.segment.setUint16(ds.byteOffset + byteOffset, value);\n}\nexports.setUint16 = setUint16;\n/**\n * Write a primitive uint32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint32(0, true);\n    ds.segment.setUint32(ds.byteOffset + byteOffset, value);\n}\nexports.setUint32 = setUint32;\n/**\n * Write a primitive uint64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Uint64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Uint64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setUint64(ds.byteOffset + byteOffset, value);\n}\nexports.setUint64 = setUint64;\n/**\n * Write a primitive uint8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint8(0);\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value);\n}\nexports.setUint8 = setUint8;\nfunction testWhich(name, found, wanted, s) {\n    if (found !== wanted)\n        throw new Error(util_1.format(errors_1.PTR_INVALID_UNION_ACCESS, s, name, found, wanted));\n}\nexports.testWhich = testWhich;\nfunction checkDataBounds(byteOffset, byteLength, s) {\n    var dataByteLength = getSize(s).dataByteLength;\n    if (byteOffset < 0 || byteLength < 0 || byteOffset + byteLength > dataByteLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_DATA_OUT_OF_BOUNDS, s, byteLength, byteOffset, dataByteLength));\n    }\n}\nexports.checkDataBounds = checkDataBounds;\nfunction checkPointerBounds(index, s) {\n    var pointerLength = getSize(s).pointerLength;\n    if (index < 0 || index >= pointerLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_POINTER_OUT_OF_BOUNDS, s, index, pointerLength));\n    }\n}\nexports.checkPointerBounds = checkPointerBounds;\n\n//# sourceMappingURL=struct.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/struct.js\n// module id = 15\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar int64_1 = require(\"./int64\");\nexports.Int64 = int64_1.Int64;\nvar uint64_1 = require(\"./uint64\");\nexports.Uint64 = uint64_1.Uint64;\n\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/types/index.js\n// module id = 16\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default('capnp:text');\ntrace('load');\nvar Text = /** @class */ (function (_super) {\n    tslib_1.__extends(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Text.fromPointer = function (pointer) {\n        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n        return textFromPointerUnchecked(pointer);\n    };\n    /**\n     * Read a utf-8 encoded string value from this pointer.\n     *\n     * @param {number} [index] The index at which to start reading; defaults to zero.\n     * @returns {string} The string value.\n     */\n    Text.prototype.get = function (index) {\n        if (index === void 0) { index = 0; }\n        if (index !== 0)\n            trace('Called get() on %s with a strange index (%d).', this, index);\n        if (pointer_1.isNull(this))\n            return '';\n        var c = pointer_1.getContent(this);\n        // Remember to exclude the NUL byte.\n        return util_1.decodeUtf8(new Uint8Array(c.segment.buffer, c.byteOffset + index, this.getLength() - index));\n    };\n    /**\n     * Get the number of utf-8 encoded bytes in this text. This does **not** include the NUL byte.\n     *\n     * @returns {number} The number of bytes allocated for the text.\n     */\n    Text.prototype.getLength = function () {\n        return _super.prototype.getLength.call(this) - 1;\n    };\n    /**\n     * Write a utf-8 encoded string value starting at the specified index.\n     *\n     * @param {number} index The index at which to start copying the string. Note that if this is not zero the bytes\n     * before `index` will be left as-is. All bytes after `index` will be overwritten.\n     * @param {string} value The string value to set.\n     * @returns {void}\n     */\n    Text.prototype.set = function (index, value) {\n        if (index !== 0)\n            trace('Called set() on %s with a strange index (%d).', this, index);\n        var src = util_1.encodeUtf8(value);\n        var dstLength = src.byteLength + index;\n        var c;\n        var original;\n        // TODO: Consider reusing existing space if list is already initialized and there's enough room for the value.\n        if (!pointer_1.isNull(this)) {\n            c = pointer_1.getContent(this);\n            // Only copy bytes that will remain after copying. Everything after `index` should end up truncated.\n            var originalLength = this.getLength();\n            if (originalLength >= index) {\n                originalLength = index;\n            }\n            else {\n                trace('%d byte gap exists between original text and new text in %s.', index - originalLength, this);\n            }\n            original = new Uint8Array(c.segment.buffer.slice(c.byteOffset, c.byteOffset + Math.min(originalLength, index)));\n            pointer_1.erase(this);\n        }\n        // Always allocate an extra byte for the NUL byte.\n        list_1.initList(list_element_size_1.ListElementSize.BYTE, dstLength + 1, this);\n        c = pointer_1.getContent(this);\n        var dst = new Uint8Array(c.segment.buffer, c.byteOffset, dstLength);\n        if (original)\n            dst.set(original);\n        dst.set(src, index);\n    };\n    Text.prototype.toString = function () {\n        return \"Text_\" + _super.prototype.toString.call(this);\n    };\n    return Text;\n}(list_1.List));\nexports.Text = Text;\nfunction textFromPointerUnchecked(pointer) {\n    return new Text(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n}\n\n//# sourceMappingURL=text.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/text.js\n// module id = 17\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar arena_allocation_result_1 = require(\"./arena-allocation-result\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar trace = debug_1.default('capnp:arena:multi');\ntrace('load');\nvar MultiSegmentArena = /** @class */ (function () {\n    function MultiSegmentArena(buffers) {\n        if (buffers === void 0) { buffers = []; }\n        this.kind = arena_kind_1.ArenaKind.MULTI_SEGMENT;\n        this.buffers = buffers;\n        trace('new %s', this);\n    }\n    MultiSegmentArena.prototype.toString = function () { return util_1.format('MultiSegmentArena_segments:%d', getNumSegments(this)); };\n    MultiSegmentArena.allocate = allocate;\n    MultiSegmentArena.getBuffer = getBuffer;\n    MultiSegmentArena.getNumSegments = getNumSegments;\n    return MultiSegmentArena;\n}());\nexports.MultiSegmentArena = MultiSegmentArena;\nfunction allocate(minSize, m) {\n    var b = new ArrayBuffer(util_1.padToWord(Math.max(minSize, constants_1.DEFAULT_BUFFER_SIZE)));\n    m.buffers.push(b);\n    return new arena_allocation_result_1.ArenaAllocationResult(m.buffers.length - 1, b);\n}\nexports.allocate = allocate;\nfunction getBuffer(id, m) {\n    if (id < 0 || id >= m.buffers.length)\n        throw new Error(util_1.format(errors_1.SEG_ID_OUT_OF_BOUNDS, id));\n    return m.buffers[id];\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments(m) {\n    return m.buffers.length;\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=multi-segment-arena.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/arena/multi-segment-arena.js\n// module id = 18\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar trace = debug_1.default('capnp:serialization:arena:arena-allocation-result');\ntrace('load');\nvar ArenaAllocationResult = /** @class */ (function () {\n    function ArenaAllocationResult(id, buffer) {\n        this.id = id;\n        this.buffer = buffer;\n        trace('new', this);\n    }\n    return ArenaAllocationResult;\n}());\nexports.ArenaAllocationResult = ArenaAllocationResult;\n\n//# sourceMappingURL=arena-allocation-result.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/arena/arena-allocation-result.js\n// module id = 19\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar arena_allocation_result_1 = require(\"./arena-allocation-result\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar trace = debug_1.default('capnp:arena:single');\ntrace('load');\nvar SingleSegmentArena = /** @class */ (function () {\n    function SingleSegmentArena(buffer) {\n        if (buffer === void 0) { buffer = new ArrayBuffer(constants_1.DEFAULT_BUFFER_SIZE); }\n        this.kind = arena_kind_1.ArenaKind.SINGLE_SEGMENT;\n        if ((buffer.byteLength & 7) !== 0)\n            throw new Error(util_1.format(errors_1.SEG_NOT_WORD_ALIGNED, buffer.byteLength));\n        this.buffer = buffer;\n        trace('new %s', this);\n    }\n    SingleSegmentArena.prototype.toString = function () { return util_1.format('SingleSegmentArena_len:%x', this.buffer.byteLength); };\n    SingleSegmentArena.allocate = allocate;\n    SingleSegmentArena.getBuffer = getBuffer;\n    SingleSegmentArena.getNumSegments = getNumSegments;\n    return SingleSegmentArena;\n}());\nexports.SingleSegmentArena = SingleSegmentArena;\nfunction allocate(minSize, segments, s) {\n    trace('Allocating %x bytes for segment 0 in %s.', minSize, s);\n    var srcBuffer = segments.length > 0 ? segments[0].buffer : s.buffer;\n    if (minSize < constants_1.MIN_SINGLE_SEGMENT_GROWTH) {\n        minSize = constants_1.MIN_SINGLE_SEGMENT_GROWTH;\n    }\n    else {\n        minSize = util_1.padToWord(minSize);\n    }\n    s.buffer = new ArrayBuffer(srcBuffer.byteLength + minSize);\n    // PERF: Assume that the source and destination buffers are word-aligned and use Float64Array to copy them one word\n    // at a time.\n    new Float64Array(s.buffer).set(new Float64Array(srcBuffer));\n    return new arena_allocation_result_1.ArenaAllocationResult(0, s.buffer);\n}\nexports.allocate = allocate;\nfunction getBuffer(id, s) {\n    if (id !== 0)\n        throw new Error(util_1.format(errors_1.SEG_GET_NON_ZERO_SINGLE, id));\n    return s.buffer;\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments() {\n    return 1;\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=single-segment-arena.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/arena/single-segment-arena.js\n// module id = 20\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default('capnp:orphan');\ntrace('load');\n// Technically speaking this class doesn't need to be generic, but the extra type checking enforced by this helps to\n// make sure you don't accidentally adopt a pointer of the wrong type.\n/**\n * An orphaned pointer. This object itself is technically a pointer to the original pointer's content, which was left\n * untouched in its original message. The original pointer data is encoded as attributes on the Orphan object, ready to\n * be reconstructed once another pointer is ready to adopt it.\n *\n * @export\n * @class Orphan\n * @extends {Pointer}\n * @template T\n */\nvar Orphan = /** @class */ (function () {\n    function Orphan(src) {\n        var c = pointer_1.getContent(src);\n        this.segment = c.segment;\n        this.byteOffset = c.byteOffset;\n        this._capnp = {};\n        // Read vital info from the src pointer so we can reconstruct it during adoption.\n        this._capnp.type = pointer_1.getTargetPointerType(src);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this._capnp.size = pointer_1.getTargetStructSize(src);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                this._capnp.length = pointer_1.getTargetListLength(src);\n                this._capnp.elementSize = pointer_1.getTargetListElementSize(src);\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE)\n                    this._capnp.size = pointer_1.getTargetCompositeListSize(src);\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                this._capnp.capId = pointer_1.getCapabilityId(src);\n                break;\n            default:\n                // COVERAGE: Unreachable code.\n                /* istanbul ignore next */\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        // Zero out the source pointer (but not the contents!).\n        pointer_1.erasePointer(src);\n    }\n    /**\n     * Adopt (move) this orphan into the target pointer location. This will allocate far pointers in `dst` as needed.\n     *\n     * @param {T} dst The destination pointer.\n     * @returns {void}\n     */\n    Orphan.prototype._moveTo = function (dst) {\n        if (this._capnp === undefined)\n            throw new Error(util_1.format(errors_1.PTR_ALREADY_ADOPTED, this));\n        // TODO: Implement copy semantics when this happens.\n        if (this.segment.message !== dst.segment.message)\n            throw new Error(util_1.format(errors_1.PTR_ADOPT_WRONG_MESSAGE, this, dst));\n        // Recursively wipe out the destination pointer first.\n        pointer_1.erase(dst);\n        var res = pointer_1.initPointer(this.segment, this.byteOffset, dst);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                pointer_1.setStructPointer(res.offsetWords, this._capnp.size, res.pointer);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var offsetWords = res.offsetWords;\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE)\n                    offsetWords--; // The tag word gets skipped.\n                pointer_1.setListPointer(offsetWords, this._capnp.elementSize, this._capnp.length, res.pointer, this._capnp.size);\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                pointer_1.setInterfacePointer(this._capnp.capId, res.pointer);\n                break;\n            /* istanbul ignore next */\n            default:\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.dispose = function () {\n        // FIXME: Should this throw?\n        if (this._capnp === undefined) {\n            trace('not disposing an already disposed orphan', this);\n            return;\n        }\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this.segment.fillZeroWords(this.byteOffset, object_size_1.getWordLength(this._capnp.size));\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var byteLength = pointer_1.getListByteLength(this._capnp.elementSize, this._capnp.length, this._capnp.size);\n                this.segment.fillZeroWords(this.byteOffset, byteLength);\n                break;\n            default:\n                // Other pointer types don't actually have any content.\n                break;\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.toString = function () {\n        return util_1.format('Orphan_%d@%a,type:%s', this.segment.id, this.byteOffset, this._capnp && this._capnp.type);\n    };\n    return Orphan;\n}());\nexports.Orphan = Orphan;\n\n//# sourceMappingURL=orphan.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/orphan.js\n// module id = 21\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar pointer_1 = require(\"./pointer\");\nvar Interface = /** @class */ (function (_super) {\n    tslib_1.__extends(Interface, _super);\n    function Interface(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, 'new Interface'));\n        return _this;\n    }\n    return Interface;\n}(pointer_1.Pointer));\nexports.Interface = Interface;\n\n//# sourceMappingURL=interface.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/interface.js\n// module id = 22\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar util_1 = require(\"../util\");\nvar trace = debug_1.default('capnp:uint64');\ntrace('load');\n/**\n * Represents an unsigned 64-bit integer stored using a Uint8Array in little-endian format. It's a little bit faster\n * than int64 because we don't need to keep track of the sign bit or perform two's compliment operations on set.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * Note that overflow is not implemented, so negative numbers passed into `setValue()` will be negated first.\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Uint64 = /** @class */ (function () {\n    /**\n     * Creates a new instance; this is a no-frills constructor for speed. Use the factory methods if you need to convert\n     * from other types or use a different offset into the buffer.\n     *\n     * Will throw if the buffer is not at least 8 bytes long.\n     *\n     * @constructor\n     * @param {Uint8Array} buffer The buffer to use for this 64-bit word; the bytes must be in little-endian order.\n     */\n    function Uint64(buffer) {\n        if (buffer.byteLength < 8)\n            throw new RangeError(errors_1.RANGE_INT64_UNDERFLOW);\n        this.buffer = buffer;\n    }\n    Uint64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Uint64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as a Uint64 value.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Uint64} The string parsed as a 64-bit unsigned integer.\n     */\n    Uint64.fromHexString = function (source) {\n        if (source.substr(0, 2) === '0x')\n            source = source.substr(2);\n        if (source.length < 1)\n            return Uint64.fromNumber(0);\n        if (source[0] === '-')\n            throw new RangeError('Source must not be negative.');\n        source = util_1.pad(source, 16);\n        if (source.length !== 16)\n            throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++)\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        return new Uint64(buf);\n    };\n    Uint64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    Uint64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Uint64.prototype.equals = function (other) {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== other.buffer[i])\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.inspect = function () {\n        return \"[Uint64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    /**\n     * Faster way to check for zero values without converting to a number first.\n     *\n     * @returns {boolean} `true` if the contained value is zero.\n     * @memberOf Uint64\n     */\n    Uint64.prototype.isZero = function () {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== 0)\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.setValue = function (loWord, hiWord) {\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Uint64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Uint64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var x = 0;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace('Coercing out of range value %d to Infinity.', x);\n            return Infinity;\n        }\n        return x;\n    };\n    Uint64.prototype.valueOf = function () {\n        return this.toNumber(false);\n    };\n    Uint64.prototype.toArrayBuffer = function () {\n        return this.buffer.buffer;\n    };\n    Uint64.prototype.toDataView = function () {\n        return new DataView(this.buffer.buffer);\n    };\n    Uint64.prototype.toHexString = function () {\n        var hex = '';\n        for (var i = 7; i >= 0; i--) {\n            var v = this.buffer[i].toString(16);\n            if (v.length === 1)\n                v = '0' + v;\n            hex += v;\n        }\n        return hex;\n    };\n    Uint64.prototype.toString = function (radix) {\n        return this.toNumber(true).toString(radix);\n    };\n    Uint64.prototype.toUint8Array = function () {\n        return this.buffer;\n    };\n    return Uint64;\n}());\nexports.Uint64 = Uint64;\n\n//# sourceMappingURL=uint64.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/types/uint64.js\n// module id = 23\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar object_size_1 = require(\"../object-size\");\nvar struct_1 = require(\"./struct\");\nvar Void = /** @class */ (function (_super) {\n    tslib_1.__extends(Void, _super);\n    function Void() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Void._capnp = {\n        displayName: 'Void',\n        id: '0',\n        size: new object_size_1.ObjectSize(0, 0),\n    };\n    return Void;\n}(struct_1.Struct));\nexports.Void = Void;\n// This following line makes a mysterious \"whooshing\" sound when it runs.\nexports.VOID = undefined;\n\n//# sourceMappingURL=void.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/void.js\n// module id = 24\n// module chunks = 0","import {Dim3 as Dim3Formatted, Trace as TraceFormatted} from '../capnp/cupr.capnp';\nimport * as capnp from 'capnp-ts';\nimport {Trace} from '../lib/serialization/trace';\nimport {Dim3} from '../lib/serialization/dim3';\n\nconst ctx: Worker = self as {} as Worker;\n\nfunction parseDim3(dim: Dim3Formatted): Dim3\n{\n    return {\n        x: dim.getX(),\n        y: dim.getY(),\n        z: dim.getZ()\n    };\n}\n\nctx.onmessage = message =>\n{\n    const payload = new capnp.Message(message.data, true);\n    const trace: TraceFormatted = payload.getRoot(TraceFormatted);\n\n    const parsed: Trace = {\n        type: trace.getType(),\n        kernel: trace.getKernel(),\n        start: trace.getStart(),\n        end: trace.getEnd(),\n        warps: trace.getWarps().map(warp => ({\n            accesses: warp.getAccesses().map(access => ({\n                threadIdx: parseDim3(access.getThreadIdx()),\n                address: access.getAddress(),\n                value: access.getValue()\n            })),\n            blockIdx: parseDim3(warp.getBlockIdx()),\n            warpId: warp.getWarpId(),\n            debugId: warp.getDebugId(),\n            size: warp.getSize(),\n            kind: warp.getKind(),\n            space: warp.getSpace(),\n            typeIndex: warp.getTypeIndex(),\n            timestamp: warp.getTimestamp()\n        })),\n        allocations: trace.getAllocations().map(alloc => ({\n            address: alloc.getAddress(),\n            size: alloc.getSize().toNumber(),\n            elementSize: alloc.getElementSize(),\n            space: alloc.getSpace(),\n            typeIndex: alloc.getTypeIndex(),\n            typeString: alloc.getTypeString(),\n            active: alloc.getActive(),\n            nameIndex: alloc.getNameIndex(),\n            nameString: alloc.getNameString(),\n            location: alloc.getLocation()\n        })),\n        gridDim: parseDim3(trace.getGridDim()),\n        blockDim: parseDim3(trace.getBlockDim()),\n        warpSize: trace.getWarpSize(),\n        bankSize: trace.getBankSize()\n    };\n\n    ctx.postMessage(parsed);\n};\n\nexport default {} as WebpackWorker;\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/worker/capnp.worker.ts","/**\n * This file has been automatically generated by the [capnpc-ts utility](https://github.com/jdiaz5513/capnp-ts).\n */\n\n/* tslint:disable */\n\nimport * as capnp from \"capnp-ts\";\nimport { ObjectSize as __O, Struct as __S } from 'capnp-ts';\nexport const _capnpFileId = \"db50473b24db4f29\";\nexport class Dim3 extends __S {\n    static readonly _capnp = { displayName: \"Dim3\", id: \"87bddb55c89457c5\", size: new __O(16, 0) };\n    getX(): number { return __S.getInt32(0, this); }\n    setX(value: number): void { __S.setInt32(0, value, this); }\n    getY(): number { return __S.getInt32(4, this); }\n    setY(value: number): void { __S.setInt32(4, value, this); }\n    getZ(): number { return __S.getInt32(8, this); }\n    setZ(value: number): void { __S.setInt32(8, value, this); }\n    toString(): string { return \"Dim3_\" + super.toString(); }\n}\nexport class MemoryAccess extends __S {\n    static readonly _capnp = { displayName: \"MemoryAccess\", id: \"d678722a813fdd16\", size: new __O(0, 3) };\n    adoptThreadIdx(value: capnp.Orphan<Dim3>): void { __S.adopt(value, __S.getPointer(0, this)); }\n    disownThreadIdx(): capnp.Orphan<Dim3> { return __S.disown(this.getThreadIdx()); }\n    getThreadIdx(): Dim3 { return __S.getStruct(0, Dim3, this); }\n    hasThreadIdx(): boolean { return !__S.isNull(__S.getPointer(0, this)); }\n    initThreadIdx(): Dim3 { return __S.initStructAt(0, Dim3, this); }\n    setThreadIdx(value: Dim3): void { __S.copyFrom(value, __S.getPointer(0, this)); }\n    getAddress(): string { return __S.getText(1, this); }\n    setAddress(value: string): void { __S.setText(1, value, this); }\n    getValue(): string { return __S.getText(2, this); }\n    setValue(value: string): void { __S.setText(2, value, this); }\n    toString(): string { return \"MemoryAccess_\" + super.toString(); }\n}\nexport class Warp extends __S {\n    static readonly _capnp = { displayName: \"Warp\", id: \"dbf542119910200f\", size: new __O(16, 3) };\n    static _Accesses: capnp.ListCtor<MemoryAccess>;\n    adoptAccesses(value: capnp.Orphan<capnp.List<MemoryAccess>>): void { __S.adopt(value, __S.getPointer(0, this)); }\n    disownAccesses(): capnp.Orphan<capnp.List<MemoryAccess>> { return __S.disown(this.getAccesses()); }\n    getAccesses(): capnp.List<MemoryAccess> { return __S.getList(0, Warp._Accesses, this); }\n    hasAccesses(): boolean { return !__S.isNull(__S.getPointer(0, this)); }\n    initAccesses(length: number): capnp.List<MemoryAccess> { return __S.initList(0, Warp._Accesses, length, this); }\n    setAccesses(value: capnp.List<MemoryAccess>): void { __S.copyFrom(value, __S.getPointer(0, this)); }\n    adoptBlockIdx(value: capnp.Orphan<Dim3>): void { __S.adopt(value, __S.getPointer(1, this)); }\n    disownBlockIdx(): capnp.Orphan<Dim3> { return __S.disown(this.getBlockIdx()); }\n    getBlockIdx(): Dim3 { return __S.getStruct(1, Dim3, this); }\n    hasBlockIdx(): boolean { return !__S.isNull(__S.getPointer(1, this)); }\n    initBlockIdx(): Dim3 { return __S.initStructAt(1, Dim3, this); }\n    setBlockIdx(value: Dim3): void { __S.copyFrom(value, __S.getPointer(1, this)); }\n    getWarpId(): number { return __S.getInt32(0, this); }\n    setWarpId(value: number): void { __S.setInt32(0, value, this); }\n    getDebugId(): number { return __S.getInt32(4, this); }\n    setDebugId(value: number): void { __S.setInt32(4, value, this); }\n    getSize(): number { return __S.getUint8(8, this); }\n    setSize(value: number): void { __S.setUint8(8, value, this); }\n    getKind(): number { return __S.getUint8(9, this); }\n    setKind(value: number): void { __S.setUint8(9, value, this); }\n    getSpace(): number { return __S.getUint8(10, this); }\n    setSpace(value: number): void { __S.setUint8(10, value, this); }\n    getTypeIndex(): number { return __S.getInt32(12, this); }\n    setTypeIndex(value: number): void { __S.setInt32(12, value, this); }\n    getTimestamp(): string { return __S.getText(2, this); }\n    setTimestamp(value: string): void { __S.setText(2, value, this); }\n    toString(): string { return \"Warp_\" + super.toString(); }\n}\nexport class AllocRecord extends __S {\n    static readonly _capnp = { displayName: \"AllocRecord\", id: \"f01eee9ad5904e3a\", size: new __O(24, 4) };\n    getAddress(): string { return __S.getText(0, this); }\n    setAddress(value: string): void { __S.setText(0, value, this); }\n    getSize(): capnp.Uint64 { return __S.getUint64(0, this); }\n    setSize(value: capnp.Uint64): void { __S.setUint64(0, value, this); }\n    getElementSize(): number { return __S.getUint32(8, this); }\n    setElementSize(value: number): void { __S.setUint32(8, value, this); }\n    getSpace(): number { return __S.getUint8(12, this); }\n    setSpace(value: number): void { __S.setUint8(12, value, this); }\n    getTypeIndex(): number { return __S.getInt32(16, this); }\n    setTypeIndex(value: number): void { __S.setInt32(16, value, this); }\n    getTypeString(): string { return __S.getText(1, this); }\n    setTypeString(value: string): void { __S.setText(1, value, this); }\n    getNameIndex(): number { return __S.getInt32(20, this); }\n    setNameIndex(value: number): void { __S.setInt32(20, value, this); }\n    getNameString(): string { return __S.getText(2, this); }\n    setNameString(value: string): void { __S.setText(2, value, this); }\n    getLocation(): string { return __S.getText(3, this); }\n    setLocation(value: string): void { __S.setText(3, value, this); }\n    getActive(): boolean { return __S.getBit(104, this); }\n    setActive(value: boolean): void { __S.setBit(104, value, this); }\n    toString(): string { return \"AllocRecord_\" + super.toString(); }\n}\nexport class Trace extends __S {\n    static readonly _capnp = { displayName: \"Trace\", id: \"e9cd0a553d9f75a8\", size: new __O(24, 6) };\n    static _Warps: capnp.ListCtor<Warp>;\n    static _Allocations: capnp.ListCtor<AllocRecord>;\n    adoptWarps(value: capnp.Orphan<capnp.List<Warp>>): void { __S.adopt(value, __S.getPointer(0, this)); }\n    disownWarps(): capnp.Orphan<capnp.List<Warp>> { return __S.disown(this.getWarps()); }\n    getWarps(): capnp.List<Warp> { return __S.getList(0, Trace._Warps, this); }\n    hasWarps(): boolean { return !__S.isNull(__S.getPointer(0, this)); }\n    initWarps(length: number): capnp.List<Warp> { return __S.initList(0, Trace._Warps, length, this); }\n    setWarps(value: capnp.List<Warp>): void { __S.copyFrom(value, __S.getPointer(0, this)); }\n    adoptAllocations(value: capnp.Orphan<capnp.List<AllocRecord>>): void { __S.adopt(value, __S.getPointer(1, this)); }\n    disownAllocations(): capnp.Orphan<capnp.List<AllocRecord>> { return __S.disown(this.getAllocations()); }\n    getAllocations(): capnp.List<AllocRecord> { return __S.getList(1, Trace._Allocations, this); }\n    hasAllocations(): boolean { return !__S.isNull(__S.getPointer(1, this)); }\n    initAllocations(length: number): capnp.List<AllocRecord> { return __S.initList(1, Trace._Allocations, length, this); }\n    setAllocations(value: capnp.List<AllocRecord>): void { __S.copyFrom(value, __S.getPointer(1, this)); }\n    getKernel(): string { return __S.getText(2, this); }\n    setKernel(value: string): void { __S.setText(2, value, this); }\n    getStart(): number { return __S.getFloat64(0, this); }\n    setStart(value: number): void { __S.setFloat64(0, value, this); }\n    getEnd(): number { return __S.getFloat64(8, this); }\n    setEnd(value: number): void { __S.setFloat64(8, value, this); }\n    getType(): string { return __S.getText(3, this); }\n    setType(value: string): void { __S.setText(3, value, this); }\n    adoptGridDim(value: capnp.Orphan<Dim3>): void { __S.adopt(value, __S.getPointer(4, this)); }\n    disownGridDim(): capnp.Orphan<Dim3> { return __S.disown(this.getGridDim()); }\n    getGridDim(): Dim3 { return __S.getStruct(4, Dim3, this); }\n    hasGridDim(): boolean { return !__S.isNull(__S.getPointer(4, this)); }\n    initGridDim(): Dim3 { return __S.initStructAt(4, Dim3, this); }\n    setGridDim(value: Dim3): void { __S.copyFrom(value, __S.getPointer(4, this)); }\n    adoptBlockDim(value: capnp.Orphan<Dim3>): void { __S.adopt(value, __S.getPointer(5, this)); }\n    disownBlockDim(): capnp.Orphan<Dim3> { return __S.disown(this.getBlockDim()); }\n    getBlockDim(): Dim3 { return __S.getStruct(5, Dim3, this); }\n    hasBlockDim(): boolean { return !__S.isNull(__S.getPointer(5, this)); }\n    initBlockDim(): Dim3 { return __S.initStructAt(5, Dim3, this); }\n    setBlockDim(value: Dim3): void { __S.copyFrom(value, __S.getPointer(5, this)); }\n    getWarpSize(): number { return __S.getUint32(16, this); }\n    setWarpSize(value: number): void { __S.setUint32(16, value, this); }\n    getBankSize(): number { return __S.getUint32(20, this); }\n    setBankSize(value: number): void { __S.setUint32(20, value, this); }\n    toString(): string { return \"Trace_\" + super.toString(); }\n}\nWarp._Accesses = capnp.CompositeList(MemoryAccess);\nTrace._Warps = capnp.CompositeList(Warp);\nTrace._Allocations = capnp.CompositeList(AllocRecord);\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/capnp/cupr.capnp.ts","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./mask\"), exports);\nvar list_element_size_1 = require(\"./list-element-size\");\nexports.ListElementSize = list_element_size_1.ListElementSize;\nvar message_1 = require(\"./message\");\nexports.Message = message_1.Message;\nvar object_size_1 = require(\"./object-size\");\nexports.ObjectSize = object_size_1.ObjectSize;\ntslib_1.__exportStar(require(\"./pointers\"), exports);\n\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/index.js\n// module id = 27\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction _makePrimitiveMaskFn(byteLength, setter) {\n    return function (x) {\n        var dv = new DataView(new ArrayBuffer(byteLength));\n        setter.call(dv, 0, x, true);\n        return dv;\n    };\n}\n/* tslint:disable:no-unsafe-any */\nexports.getFloat32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setFloat32);\nexports.getFloat64Mask = _makePrimitiveMaskFn(8, DataView.prototype.setFloat64);\nexports.getInt16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setInt16);\nexports.getInt32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setInt32);\nexports.getInt8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setInt8);\nexports.getUint16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setUint16);\nexports.getUint32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setUint32);\nexports.getUint8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setUint8);\n/* tslint:enable:no-unsafe-any */\nfunction getBitMask(value, bitOffset) {\n    var dv = new DataView(new ArrayBuffer(1));\n    if (!value)\n        return dv;\n    dv.setUint8(0, 1 << bitOffset % 8);\n    return dv;\n}\nexports.getBitMask = getBitMask;\nfunction getInt64Mask(x) {\n    return x.toDataView();\n}\nexports.getInt64Mask = getInt64Mask;\nfunction getUint64Mask(x) {\n    return x.toDataView();\n}\nexports.getUint64Mask = getUint64Mask;\n\n//# sourceMappingURL=mask.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/mask.js\n// module id = 28\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar util_1 = require(\"../util\");\nvar arena_1 = require(\"./arena\");\nvar packing_1 = require(\"./packing\");\nvar pointers_1 = require(\"./pointers\");\nvar segment_1 = require(\"./segment\");\nvar pointer_1 = require(\"./pointers/pointer\");\nvar struct_1 = require(\"./pointers/struct\");\nvar trace = debug_1.default('capnp:message');\ntrace('load');\nvar Message = /** @class */ (function () {\n    /**\n     * A Cap'n Proto message.\n     *\n     * SECURITY WARNING: In nodejs do not pass a Buffer's internal array buffer into this constructor. Pass the buffer\n     * directly and everything will be fine. If not, your message will potentially be initialized with random memory\n     * contents!\n     *\n     * The constructor method creates a new Message, optionally using a provided arena for segment allocation, or a buffer\n     * to read from.\n     *\n     * @constructor {Message}\n     *\n     * @param {AnyArena|ArrayBufferView|ArrayBuffer} [src] The source for the message.\n     * A value of `undefined` will cause the message to initialize with a single segment arena only big enough for the\n     * root pointer; it will expand as you go. This is a reasonable choice for most messages.\n     *\n     * Passing an arena will cause the message to use that arena for its segment allocation. Contents will be accepted\n     * as-is.\n     *\n     * Passing an array buffer view (like `DataView`, `Uint8Array` or `Buffer`) will create a **copy** of the source\n     * buffer; beware of the potential performance cost!\n     *\n     * @param {boolean} [packed] Whether or not the message is packed. If `true` (the default), the message will be\n     * unpacked.\n     *\n     * @param {boolean} [singleSegment] If true, `src` will be treated as a message consisting of a single segment without\n     * a framing header.\n     *\n     */\n    function Message(src, packed, singleSegment) {\n        if (packed === void 0) { packed = true; }\n        if (singleSegment === void 0) { singleSegment = false; }\n        this._capnp = initMessage(src, packed, singleSegment);\n        if (src && !isAnyArena(src))\n            preallocateSegments(this);\n        trace('new %s', this);\n    }\n    Message.prototype.allocateSegment = function (byteLength) { return allocateSegment(byteLength, this); };\n    /**\n     * Create a pretty-printed string dump of this message; incredibly useful for debugging.\n     *\n     * WARNING: Do not call this method on large messages!\n     *\n     * @returns {string} A big steaming pile of pretty hex digits.\n     */\n    Message.prototype.dump = function () { return dump(this); };\n    /**\n     * Get a struct pointer for the root of this message. This is primarily used when reading a message; it will not\n     * overwrite existing data.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} A struct representing the root of the message.\n     */\n    Message.prototype.getRoot = function (RootStruct) { return getRoot(RootStruct, this); };\n    /**\n     * Get a segment by its id.\n     *\n     * This will lazily allocate the first segment if it doesn't already exist.\n     *\n     * @param {number} id The segment id.\n     * @returns {Segment} The requested segment.\n     */\n    Message.prototype.getSegment = function (id) { return getSegment(id, this); };\n    /**\n     * Initialize a new message using the provided struct type as the root.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} An initialized struct pointing to the root of the message.\n     */\n    Message.prototype.initRoot = function (RootStruct) { return initRoot(RootStruct, this); };\n    /**\n     * Combine the contents of this message's segments into a single array buffer and prepend a stream framing header\n     * containing information about the following segment data.\n     *\n     * @returns {ArrayBuffer} An ArrayBuffer with the contents of this message.\n     */\n    Message.prototype.toArrayBuffer = function () { return toArrayBuffer(this); };\n    /**\n     * Like `toArrayBuffer()`, but also applies the packing algorithm to the output. This is typically what you want to\n     * use if you're sending the message over a network link or other slow I/O interface where size matters.\n     *\n     * @returns {ArrayBuffer} A packed message.\n     */\n    Message.prototype.toPackedArrayBuffer = function () { return toPackedArrayBuffer(this); };\n    Message.prototype.toString = function () { return \"Message_arena:\" + this._capnp.arena; };\n    Message.allocateSegment = allocateSegment;\n    Message.dump = dump;\n    Message.getRoot = getRoot;\n    Message.getSegment = getSegment;\n    Message.initRoot = initRoot;\n    Message.toArrayBuffer = toArrayBuffer;\n    Message.toPackedArrayBuffer = toPackedArrayBuffer;\n    return Message;\n}());\nexports.Message = Message;\nfunction initMessage(src, packed, singleSegment) {\n    if (packed === void 0) { packed = true; }\n    if (singleSegment === void 0) { singleSegment = false; }\n    if (src === undefined) {\n        return { arena: new arena_1.SingleSegmentArena(), segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };\n    }\n    if (isAnyArena(src))\n        return { arena: src, segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };\n    var buf = src;\n    if (isArrayBufferView(buf))\n        buf = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    if (packed)\n        buf = packing_1.unpack(buf);\n    if (singleSegment) {\n        return {\n            arena: new arena_1.SingleSegmentArena(buf),\n            segments: [],\n            traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,\n        };\n    }\n    return {\n        arena: new arena_1.MultiSegmentArena(getFramedSegments(buf)),\n        segments: [],\n        traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,\n    };\n}\nexports.initMessage = initMessage;\n/**\n * Given an _unpacked_ message with a segment framing header, this will generate an ArrayBuffer for each segment in\n * the message.\n *\n * This method is not typically called directly, but can be useful in certain cases.\n *\n * @static\n * @param {ArrayBuffer} message An unpacked message with a framing header.\n * @returns {ArrayBuffer[]} An array of buffers containing the segment data.\n */\nfunction getFramedSegments(message) {\n    var dv = new DataView(message);\n    var segmentCount = dv.getUint32(0, true) + 1;\n    var segments = new Array(segmentCount);\n    trace('reading %d framed segments from stream', segmentCount);\n    var byteOffset = 4 + segmentCount * 4;\n    byteOffset += byteOffset % 8;\n    if (byteOffset + segmentCount * 4 > message.byteLength)\n        throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n    for (var i = 0; i < segmentCount; i++) {\n        var byteLength = dv.getUint32(4 + i * 4, true) * 8;\n        if (byteOffset + byteLength > message.byteLength)\n            throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n        segments[i] = message.slice(byteOffset, byteOffset + byteLength);\n        byteOffset += byteLength;\n    }\n    return segments;\n}\nexports.getFramedSegments = getFramedSegments;\n/**\n * This method is called on messages that were constructed with existing data to prepopulate the segments array with\n * everything we can find in the arena. Each segment will have it's `byteLength` set to the size of its buffer.\n *\n * Technically speaking, the message's segments will be \"full\" after calling this function. Calling this on your own\n * may void your warranty.\n *\n * @param {Message} m The message to allocate.\n * @returns {void}\n */\nfunction preallocateSegments(m) {\n    var numSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n    if (numSegments < 1)\n        throw new Error(errors_1.MSG_NO_SEGMENTS_IN_ARENA);\n    m._capnp.segments = new Array(numSegments);\n    for (var i = 0; i < numSegments; i++) {\n        // Set up each segment so that they're fully allocated to the extents of the existing buffers.\n        var buffer = arena_1.Arena.getBuffer(i, m._capnp.arena);\n        var segment = new segment_1.Segment(i, m, buffer, buffer.byteLength);\n        m._capnp.segments[i] = segment;\n    }\n}\nexports.preallocateSegments = preallocateSegments;\nfunction isArrayBufferView(src) {\n    return src.byteOffset !== undefined;\n}\nfunction isAnyArena(o) {\n    return o.kind !== undefined;\n}\nfunction allocateSegment(byteLength, m) {\n    trace('allocating %x bytes for %s', byteLength, m);\n    var res = arena_1.Arena.allocate(byteLength, m._capnp.segments, m._capnp.arena);\n    var s;\n    if (res.id === m._capnp.segments.length) {\n        // Note how we're only allowing new segments in if they're exactly the next one in the array. There is no logical\n        // reason for segments to be created out of order.\n        s = new segment_1.Segment(res.id, m, res.buffer);\n        trace('adding new segment %s', s);\n        m._capnp.segments.push(s);\n    }\n    else if (res.id < 0 || res.id > m._capnp.segments.length) {\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, res.id, m));\n    }\n    else {\n        s = m._capnp.segments[res.id];\n        trace('replacing segment %s with buffer (len:%d)', s, res.buffer.byteLength);\n        s.replaceBuffer(res.buffer);\n    }\n    return s;\n}\nexports.allocateSegment = allocateSegment;\nfunction dump(m) {\n    var r = '';\n    if (m._capnp.segments.length === 0)\n        return '================\\nNo Segments\\n================\\n';\n    for (var i = 0; i < m._capnp.segments.length; i++) {\n        r += \"================\\nSegment #\" + i + \"\\n================\\n\";\n        var _a = m._capnp.segments[i], buffer = _a.buffer, byteLength = _a.byteLength;\n        var b = new Uint8Array(buffer, 0, byteLength);\n        r += util_1.dumpBuffer(b);\n    }\n    return r;\n}\nexports.dump = dump;\nfunction getRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    pointer_1.validate(pointers_1.PointerType.STRUCT, root);\n    var ts = pointer_1.getTargetStructSize(root);\n    // Make sure the underlying pointer is actually big enough to hold the data and pointers as specified in the schema.\n    // If not a shallow copy of the struct contents needs to be made before returning.\n    if (ts.dataByteLength < RootStruct._capnp.size.dataByteLength\n        || ts.pointerLength < RootStruct._capnp.size.pointerLength) {\n        trace('need to resize root struct %s', root);\n        struct_1.resize(RootStruct._capnp.size, root);\n    }\n    return root;\n}\nexports.getRoot = getRoot;\nfunction getSegment(id, m) {\n    var segmentLength = m._capnp.segments.length;\n    if (id === 0 && segmentLength === 0) {\n        // Segment zero is special. If we have no segments in the arena we'll want to allocate a new one and leave room\n        // for the root pointer.\n        var arenaSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n        if (arenaSegments === 0) {\n            allocateSegment(constants_1.DEFAULT_BUFFER_SIZE, m);\n        }\n        else {\n            // Okay, the arena already has a buffer we can use. This is totally fine.\n            m._capnp.segments[0] = new segment_1.Segment(0, m, arena_1.Arena.getBuffer(0, m._capnp.arena));\n        }\n        if (!m._capnp.segments[0].hasCapacity(8))\n            throw new Error(errors_1.MSG_SEGMENT_TOO_SMALL);\n        // This will leave room for the root pointer.\n        m._capnp.segments[0].allocate(8);\n        return m._capnp.segments[0];\n    }\n    if (id < 0 || id >= segmentLength)\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, id, m));\n    return m._capnp.segments[id];\n}\nexports.getSegment = getSegment;\nfunction initRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    struct_1.initStruct(RootStruct._capnp.size, root);\n    trace('Initialized root pointer %s for %s.', root, m);\n    return root;\n}\nexports.initRoot = initRoot;\nfunction toArrayBuffer(m) {\n    var streamFrame = getStreamFrame(m);\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        getSegment(0, m);\n    var segments = m._capnp.segments;\n    // Add space for the stream framing.\n    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + util_1.padToWord(s.byteLength); }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        var segmentLength = util_1.padToWord(s.byteLength);\n        out.set(new Uint8Array(s.buffer, 0, segmentLength), o);\n        o += segmentLength;\n    });\n    return out.buffer;\n}\nexports.toArrayBuffer = toArrayBuffer;\nfunction toPackedArrayBuffer(m) {\n    var streamFrame = packing_1.pack(getStreamFrame(m));\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        m.getSegment(0);\n    // NOTE: A copy operation can be avoided here if we capture the intermediate array and use that directly in the copy\n    // loop below, rather than have `pack()` copy it to an ArrayBuffer just to have to copy it again later. If the\n    // intermediate array can be avoided altogether that's even better!\n    var segments = m._capnp.segments.map(function (s) { return packing_1.pack(s.buffer, 0, util_1.padToWord(s.byteLength)); });\n    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + s.byteLength; }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        out.set(new Uint8Array(s), o);\n        o += s.byteLength;\n    });\n    return out.buffer;\n}\nexports.toPackedArrayBuffer = toPackedArrayBuffer;\nfunction getStreamFrame(m) {\n    var length = m._capnp.segments.length;\n    if (length === 0) {\n        // Don't bother allocating the first segment, just return a single zero word for the frame header.\n        return new Float64Array(1).buffer;\n    }\n    var frameLength = 4 + length * 4 + (1 - length % 2) * 4;\n    var out = new DataView(new ArrayBuffer(frameLength));\n    trace('Writing message stream frame with segment count: %d.', length);\n    out.setUint32(0, length - 1, true);\n    m._capnp.segments.forEach(function (s, i) {\n        trace('Message segment %d word count: %d.', s.id, s.byteLength / 8);\n        out.setUint32(i * 4 + 4, s.byteLength / 8, true);\n    });\n    return out.buffer;\n}\nexports.getStreamFrame = getStreamFrame;\n\n//# sourceMappingURL=message.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/message.js\n// module id = 29\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 30\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/debug.js\n// module id = 31\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms/index.js\n// module id = 32\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arena_1 = require(\"./arena\");\nexports.Arena = arena_1.Arena;\nvar arena_kind_1 = require(\"./arena-kind\");\nexports.ArenaKind = arena_kind_1.ArenaKind;\nvar multi_segment_arena_1 = require(\"./multi-segment-arena\");\nexports.MultiSegmentArena = multi_segment_arena_1.MultiSegmentArena;\nvar single_segment_arena_1 = require(\"./single-segment-arena\");\nexports.SingleSegmentArena = single_segment_arena_1.SingleSegmentArena;\n\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/arena/index.js\n// module id = 33\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar multi_segment_arena_1 = require(\"./multi-segment-arena\");\nvar single_segment_arena_1 = require(\"./single-segment-arena\");\nvar trace = debug_1.default('capnp:arena');\ntrace('load');\nvar Arena = /** @class */ (function () {\n    function Arena() {\n    }\n    Arena.allocate = allocate;\n    Arena.getBuffer = getBuffer;\n    Arena.getNumSegments = getNumSegments;\n    return Arena;\n}());\nexports.Arena = Arena;\nfunction allocate(minSize, segments, a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.allocate(minSize, a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.allocate(minSize, segments, a);\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.allocate = allocate;\nfunction getBuffer(id, a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.getBuffer(id, a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.getBuffer(id, a);\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments(a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.getNumSegments(a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.getNumSegments();\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=arena.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/arena/arena.js\n// module id = 34\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\n/**\n * Compute the Hamming weight (number of bits set to 1) of a number. Used to figure out how many bytes follow a tag byte\n * while computing the size of a packed message.\n *\n * WARNING: Using this with floating point numbers will void your warranty.\n *\n * @param {number} x A real integer.\n * @returns {number} The hamming weight (integer).\n */\nfunction getHammingWeight(x) {\n    // Thanks, HACKMEM!\n    var w = x - ((x >> 1) & 0x55555555);\n    w = (w & 0x33333333) + ((w >> 2) & 0x33333333);\n    return ((w + (w >> 4) & 0x0f0f0f0f) * 0x01010101) >> 24;\n}\nexports.getHammingWeight = getHammingWeight;\n/**\n * Compute the tag byte from the 8 bytes of a 64-bit word.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The tag byte.\n */\nfunction getTagByte(a, b, c, d, e, f, g, h) {\n    // Yes, it's pretty. Don't touch it.\n    return (a === 0 ? 0 : 1) |\n        (b === 0 ? 0 : 2) |\n        (c === 0 ? 0 : 4) |\n        (d === 0 ? 0 : 8) |\n        (e === 0 ? 0 : 16) |\n        (f === 0 ? 0 : 32) |\n        (g === 0 ? 0 : 64) |\n        (h === 0 ? 0 : 128);\n}\nexports.getTagByte = getTagByte;\n/**\n * Efficiently calculate the length of a packed Cap'n Proto message.\n *\n * @export\n * @param {ArrayBuffer} packed The packed message.\n * @returns {number} The length of the unpacked message in bytes.\n */\nfunction getUnpackedByteLength(packed) {\n    var p = new Uint8Array(packed);\n    var wordLength = 0;\n    var lastTag = 0x77;\n    for (var i = 0; i < p.byteLength;) {\n        var tag = p[i];\n        if (lastTag === 0 /* ZERO */) {\n            wordLength += tag;\n            i++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            wordLength += tag;\n            i += tag * 8 + 1;\n            lastTag = 0x77;\n        }\n        else {\n            wordLength++;\n            i += getHammingWeight(tag) + 1;\n            lastTag = tag;\n        }\n    }\n    return wordLength * 8;\n}\nexports.getUnpackedByteLength = getUnpackedByteLength;\n/**\n * Compute the number of zero bytes that occur in a given 64-bit word, provided as eight separate bytes.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The number of these bytes that are zero.\n */\nfunction getZeroByteCount(a, b, c, d, e, f, g, h) {\n    return (a === 0 ? 1 : 0) +\n        (b === 0 ? 1 : 0) +\n        (c === 0 ? 1 : 0) +\n        (d === 0 ? 1 : 0) +\n        (e === 0 ? 1 : 0) +\n        (f === 0 ? 1 : 0) +\n        (g === 0 ? 1 : 0) +\n        (h === 0 ? 1 : 0);\n}\nexports.getZeroByteCount = getZeroByteCount;\n/**\n * Pack a section of a Cap'n Proto message into a compressed format. This will efficiently compress zero bytes (which\n * are common in idiomatic Cap'n Proto messages) into a compact form.\n *\n * For stream-framed messages this is called once for the frame header and once again for each segment in the message.\n *\n * The returned array buffer is trimmed to the exact size of the packed message with a single copy operation at the end.\n * This should be decent on CPU time but does require quite a lot of memory (a normal array is filled up with each\n * packed byte until the packing is complete).\n *\n * @export\n * @param {ArrayBuffer} unpacked The message to pack.\n * @param {number} [byteOffset] Starting byte offset to read bytes from, defaults to 0.\n * @param {number} [byteLength] Total number of bytes to read, defaults to the remainder of the buffer contents.\n * @returns {ArrayBuffer} A packed version of the message.\n */\nfunction pack(unpacked, byteOffset, byteLength) {\n    if (byteOffset === void 0) { byteOffset = 0; }\n    if (unpacked.byteLength % 8 !== 0)\n        throw new Error(errors_1.MSG_PACK_NOT_WORD_ALIGNED);\n    var src = new Uint8Array(unpacked, byteOffset, byteLength);\n    // TODO: Maybe we should do this with buffers? This costs more than 8x the final compressed size in temporary RAM.\n    var dst = [];\n    /* Just have to be sure it's neither ZERO nor SPAN. */\n    var lastTag = 0x77;\n    /** This is where we need to remember to write the SPAN tag (0xff). */\n    var spanTagOffset = NaN;\n    /** How many words have been copied during the current span. */\n    var spanWordLength = 0;\n    /**\n     * When this hits zero, we've had PACK_SPAN_THRESHOLD zero bytes pass by and it's time to bail from the span.\n     */\n    var spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n    for (var srcByteOffset = 0; srcByteOffset < src.byteLength; srcByteOffset += 8) {\n        /** Read in the entire word. Yes, this feels silly but it's fast! */\n        var a = src[srcByteOffset];\n        var b = src[srcByteOffset + 1];\n        var c = src[srcByteOffset + 2];\n        var d = src[srcByteOffset + 3];\n        var e = src[srcByteOffset + 4];\n        var f = src[srcByteOffset + 5];\n        var g = src[srcByteOffset + 6];\n        var h = src[srcByteOffset + 7];\n        var tag = getTagByte(a, b, c, d, e, f, g, h);\n        /** If this is true we'll skip the normal word write logic after the switch statement. */\n        var skipWriteWord = true;\n        switch (lastTag) {\n            case 0 /* ZERO */:\n                // We're writing a span of words with all zeroes in them. See if we need to bail out of the fast path.\n                if (tag !== 0 /* ZERO */ || spanWordLength >= 0xff) {\n                    // There's a bit in there or we got too many zeroes. Damn, we need to bail.\n                    dst.push(spanWordLength);\n                    spanWordLength = 0;\n                    skipWriteWord = false;\n                }\n                else {\n                    // Kay, let's quickly inc this and go.\n                    spanWordLength++;\n                }\n                break;\n            case 255 /* SPAN */:\n                // We're writing a span of nonzero words.\n                var zeroCount = getZeroByteCount(a, b, c, d, e, f, g, h);\n                // See if we need to bail now.\n                spanThreshold -= zeroCount;\n                if (spanThreshold <= 0 || spanWordLength >= 0xff) {\n                    // Alright, time to get packing again. Write the number of words we skipped to the beginning of the span.\n                    dst[spanTagOffset] = spanWordLength;\n                    spanWordLength = 0;\n                    spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n                    // We have to write this word normally.\n                    skipWriteWord = false;\n                }\n                else {\n                    // Just write this word verbatim.\n                    dst.push(a, b, c, d, e, f, g, h);\n                    spanWordLength++;\n                }\n                break;\n            default:\n                // Didn't get a special tag last time, let's write this as normal.\n                skipWriteWord = false;\n                break;\n        }\n        // A goto is fast, idk why people keep hatin'.\n        if (skipWriteWord)\n            continue;\n        dst.push(tag);\n        lastTag = tag;\n        if (a !== 0)\n            dst.push(a);\n        if (b !== 0)\n            dst.push(b);\n        if (c !== 0)\n            dst.push(c);\n        if (d !== 0)\n            dst.push(d);\n        if (e !== 0)\n            dst.push(e);\n        if (f !== 0)\n            dst.push(f);\n        if (g !== 0)\n            dst.push(g);\n        if (h !== 0)\n            dst.push(h);\n        // Record the span tag offset if needed, making sure to actually leave room for it.\n        if (tag === 255 /* SPAN */) {\n            spanTagOffset = dst.length;\n            dst.push(0);\n        }\n    }\n    // We're done. If we were writing a span let's finish it.\n    if (lastTag === 0 /* ZERO */) {\n        dst.push(spanWordLength);\n    }\n    else if (lastTag === 255 /* SPAN */) {\n        dst[spanTagOffset] = spanWordLength;\n    }\n    return new Uint8Array(dst).buffer;\n}\nexports.pack = pack;\n/**\n * Unpack a compressed Cap'n Proto message into a new ArrayBuffer.\n *\n * Unlike the `pack` function, this is able to efficiently determine the exact size needed for the output buffer and\n * runs considerably more efficiently.\n *\n * @export\n * @param {ArrayBuffer} packed An array buffer containing the packed message.\n * @returns {ArrayBuffer} The unpacked message.\n */\nfunction unpack(packed) {\n    // We have no choice but to read the packed buffer one byte at a time.\n    var src = new Uint8Array(packed);\n    var dst = new Uint8Array(new ArrayBuffer(getUnpackedByteLength(packed)));\n    /** The last tag byte that we've seen - it starts at a \"neutral\" value. */\n    var lastTag = 0x77;\n    for (var srcByteOffset = 0, dstByteOffset = 0; srcByteOffset < src.byteLength;) {\n        var tag = src[srcByteOffset];\n        if (lastTag === 0 /* ZERO */) {\n            // We have a span of zeroes. New array buffers are guaranteed to be initialized to zero so we just seek ahead.\n            dstByteOffset += tag * 8;\n            srcByteOffset++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            // We have a span of unpacked bytes. Copy them verbatim from the source buffer.\n            var spanByteLength = tag * 8;\n            dst.set(src.subarray(srcByteOffset + 1, srcByteOffset + 1 + spanByteLength), dstByteOffset);\n            dstByteOffset += spanByteLength;\n            srcByteOffset += 1 + spanByteLength;\n            lastTag = 0x77;\n        }\n        else {\n            // Okay, a normal tag. Let's read past the tag and copy bytes that have a bit set in the tag.\n            srcByteOffset++;\n            for (var i = 1; i <= 128; i <<= 1) {\n                // We only need to actually touch `dst` if there's a nonzero byte (it's already initialized to zeroes).\n                if ((tag & i) !== 0)\n                    dst[dstByteOffset] = src[srcByteOffset++];\n                dstByteOffset++;\n            }\n            lastTag = tag;\n        }\n    }\n    return dst.buffer;\n}\nexports.unpack = unpack;\n\n//# sourceMappingURL=packing.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/packing.js\n// module id = 35\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pointer_1 = require(\"./pointer\");\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.AnyPointerList = pointer_list_1.PointerList(pointer_1.Pointer);\n\n//# sourceMappingURL=any-pointer-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/any-pointer-list.js\n// module id = 36\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar trace = debug_1.default('capnp:pointer-allocation-result');\ntrace('load');\n/**\n * This is used as the return value for `Pointer.prototype.initPointer`. Turns out using a class in V8 for multiple\n * return values is faster than using an array or anonymous object.\n *\n * http://jsben.ch/#/zTdbD\n *\n * @export\n * @class PointerAllocationResult\n */\nvar PointerAllocationResult = /** @class */ (function () {\n    function PointerAllocationResult(pointer, offsetWords) {\n        this.pointer = pointer;\n        this.offsetWords = offsetWords;\n    }\n    return PointerAllocationResult;\n}());\nexports.PointerAllocationResult = PointerAllocationResult;\n\n//# sourceMappingURL=pointer-allocation-result.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/pointer-allocation-result.js\n// module id = 37\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar BoolList = /** @class */ (function (_super) {\n    tslib_1.__extends(BoolList, _super);\n    function BoolList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BoolList.prototype.get = function (index) {\n        var bitMask = 1 << index % 8;\n        var byteOffset = index >>> 3;\n        var c = pointer_1.getContent(this);\n        var v = c.segment.getUint8(c.byteOffset + byteOffset);\n        return (v & bitMask) !== 0;\n    };\n    BoolList.prototype.set = function (index, value) {\n        var bitMask = 1 << index % 8;\n        var c = pointer_1.getContent(this);\n        var byteOffset = c.byteOffset + (index >>> 3);\n        var v = c.segment.getUint8(byteOffset);\n        c.segment.setUint8(byteOffset, value ? v | bitMask : v & ~bitMask);\n    };\n    BoolList.prototype.toString = function () {\n        return \"Bool_\" + _super.prototype.toString.call(this);\n    };\n    BoolList._capnp = {\n        displayName: 'List<boolean>',\n        size: list_element_size_1.ListElementSize.BIT,\n    };\n    return BoolList;\n}(list_1.List));\nexports.BoolList = BoolList;\n\n//# sourceMappingURL=bool-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/bool-list.js\n// module id = 38\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nfunction CompositeList(CompositeClass) {\n    return _a = /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.get = function (index) {\n                return new CompositeClass(this.segment, this.byteOffset, this._capnp.depthLimit - 1, index);\n            };\n            class_1.prototype.set = function (index, value) {\n                pointer_1.copyFrom(value, this.get(index));\n            };\n            class_1.prototype.toString = function () {\n                return \"Composite_\" + _super.prototype.toString.call(this) + \",cls:\" + CompositeClass.toString();\n            };\n            return class_1;\n        }(list_1.List)),\n        _a._capnp = {\n            compositeSize: CompositeClass._capnp.size,\n            displayName: \"List<\" + CompositeClass._capnp.displayName + \">\",\n            size: list_element_size_1.ListElementSize.COMPOSITE,\n        },\n        _a;\n    var _a;\n}\nexports.CompositeList = CompositeList;\n\n//# sourceMappingURL=composite-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/composite-list.js\n// module id = 39\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_1 = require(\"./data\");\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.DataList = pointer_list_1.PointerList(data_1.Data);\n\n//# sourceMappingURL=data-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/data-list.js\n// module id = 40\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Float32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Float32List, _super);\n    function Float32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Float32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getFloat32(c.byteOffset + index * 4);\n    };\n    Float32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setFloat32(c.byteOffset + index * 4, value);\n    };\n    Float32List.prototype.toString = function () {\n        return \"Float32_\" + _super.prototype.toString.call(this);\n    };\n    Float32List._capnp = {\n        displayName: 'List<Float32>',\n        size: list_element_size_1.ListElementSize.BYTE_4,\n    };\n    return Float32List;\n}(list_1.List));\nexports.Float32List = Float32List;\n\n//# sourceMappingURL=float32-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/float32-list.js\n// module id = 41\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Float64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Float64List, _super);\n    function Float64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Float64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getFloat64(c.byteOffset + index * 8);\n    };\n    Float64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setFloat64(c.byteOffset + index * 8, value);\n    };\n    Float64List.prototype.toString = function () {\n        return \"Float64_\" + _super.prototype.toString.call(this);\n    };\n    Float64List._capnp = {\n        displayName: 'List<Float64>',\n        size: list_element_size_1.ListElementSize.BYTE_8,\n    };\n    return Float64List;\n}(list_1.List));\nexports.Float64List = Float64List;\n\n//# sourceMappingURL=float64-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/float64-list.js\n// module id = 42\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int8List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int8List, _super);\n    function Int8List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int8List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt8(c.byteOffset + index);\n    };\n    Int8List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt8(c.byteOffset + index, value);\n    };\n    Int8List.prototype.toString = function () {\n        return \"Int8_\" + _super.prototype.toString.call(this);\n    };\n    Int8List._capnp = {\n        displayName: 'List<Int8>',\n        size: list_element_size_1.ListElementSize.BYTE,\n    };\n    return Int8List;\n}(list_1.List));\nexports.Int8List = Int8List;\n\n//# sourceMappingURL=int8-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/int8-list.js\n// module id = 43\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int16List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int16List, _super);\n    function Int16List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int16List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt16(c.byteOffset + index * 2);\n    };\n    Int16List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt16(c.byteOffset + index * 2, value);\n    };\n    Int16List.prototype.toString = function () {\n        return \"Int16_\" + _super.prototype.toString.call(this);\n    };\n    Int16List._capnp = {\n        displayName: 'List<Int16>',\n        size: list_element_size_1.ListElementSize.BYTE_2,\n    };\n    return Int16List;\n}(list_1.List));\nexports.Int16List = Int16List;\n\n//# sourceMappingURL=int16-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/int16-list.js\n// module id = 44\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int32List, _super);\n    function Int32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt32(c.byteOffset + index * 4);\n    };\n    Int32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt32(c.byteOffset + index * 4, value);\n    };\n    Int32List.prototype.toString = function () {\n        return \"Int32_\" + _super.prototype.toString.call(this);\n    };\n    Int32List._capnp = {\n        displayName: 'List<Int32>',\n        size: list_element_size_1.ListElementSize.BYTE_4,\n    };\n    return Int32List;\n}(list_1.List));\nexports.Int32List = Int32List;\n\n//# sourceMappingURL=int32-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/int32-list.js\n// module id = 45\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int64List, _super);\n    function Int64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt64(c.byteOffset + index * 8);\n    };\n    Int64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt64(c.byteOffset + index * 8, value);\n    };\n    Int64List.prototype.toString = function () {\n        return \"Int64_\" + _super.prototype.toString.call(this);\n    };\n    Int64List._capnp = {\n        displayName: 'List<Int64>',\n        size: list_element_size_1.ListElementSize.BYTE_8,\n    };\n    return Int64List;\n}(list_1.List));\nexports.Int64List = Int64List;\n\n//# sourceMappingURL=int64-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/int64-list.js\n// module id = 46\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interface_1 = require(\"./interface\");\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.InterfaceList = pointer_list_1.PointerList(interface_1.Interface);\n\n//# sourceMappingURL=interface-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/interface-list.js\n// module id = 47\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar util_1 = require(\"../util\");\nvar uint64_1 = require(\"./uint64\");\nvar trace = debug_1.default('capnp:int64');\ntrace('load');\n/**\n * Represents a signed 64-bit integer stored using a Uint8Array in little-endian format.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Int64 = /** @class */ (function (_super) {\n    tslib_1.__extends(Int64, _super);\n    function Int64() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Int64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    Int64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as an Int64 value.\n     *\n     * The value will be negative if the string is either preceded with a `-` sign, or already in the negative 2's\n     * complement form.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Int64} The string parsed as a 64-bit signed integer.\n     */\n    Int64.fromHexString = function (source) {\n        if (source.substr(0, 2) === '0x')\n            source = source.substr(2);\n        if (source.length < 1)\n            return Int64.fromNumber(0);\n        var neg = source[0] === '-';\n        if (neg)\n            source = source.substr(1);\n        source = util_1.pad(source, 16);\n        if (source.length !== 16)\n            throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++)\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        var val = new Int64(buf);\n        if (neg)\n            val.negate();\n        return val;\n    };\n    Int64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Int64.prototype.equals = function (other) {\n        return _super.prototype.equals.call(this, other);\n    };\n    Int64.prototype.inspect = function () {\n        return \"[Int64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    Int64.prototype.negate = function () {\n        for (var b = this.buffer, carry = 1, i = 0; i < 8; i++) {\n            var v = (b[i] ^ 0xff) + carry;\n            b[i] = v & 0xff;\n            carry = v >> 8;\n        }\n    };\n    Int64.prototype.setValue = function (loWord, hiWord) {\n        var negate = false;\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            negate = hi < 0;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Int64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n        if (negate)\n            this.negate();\n    };\n    Int64.prototype.toHexString = function () {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        if (negate)\n            this.negate();\n        var hex = '';\n        for (var i = 7; i >= 0; i--) {\n            var v = b[i].toString(16);\n            if (v.length === 1)\n                v = '0' + v;\n            hex += v;\n        }\n        if (negate) {\n            this.negate();\n            hex = '-' + hex;\n        }\n        return hex;\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +/-Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Int64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        var x = 0;\n        var carry = 1;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            if (negate) {\n                v = (v ^ 0xff) + carry;\n                carry = v >> 8;\n                v = v & 0xff;\n            }\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace('Coercing out of range value %d to Infinity.', x);\n            return negate ? -Infinity : Infinity;\n        }\n        return negate ? -x : x;\n    };\n    return Int64;\n}(uint64_1.Uint64));\nexports.Int64 = Int64;\n\n//# sourceMappingURL=int64.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/types/int64.js\n// module id = 48\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar text_1 = require(\"./text\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar TextList = /** @class */ (function (_super) {\n    tslib_1.__extends(TextList, _super);\n    function TextList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TextList.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        c.byteOffset += index * 8;\n        return text_1.Text.fromPointer(c).get(0);\n    };\n    TextList.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.byteOffset += index * 8;\n        text_1.Text.fromPointer(c).set(0, value);\n    };\n    TextList.prototype.toString = function () {\n        return \"Text_\" + _super.prototype.toString.call(this);\n    };\n    TextList._capnp = {\n        displayName: 'List<Text>',\n        size: list_element_size_1.ListElementSize.POINTER,\n    };\n    return TextList;\n}(list_1.List));\nexports.TextList = TextList;\n\n//# sourceMappingURL=text-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/text-list.js\n// module id = 49\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint8List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint8List, _super);\n    function Uint8List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint8List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint8(c.byteOffset + index);\n    };\n    Uint8List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint8(c.byteOffset + index, value);\n    };\n    Uint8List.prototype.toString = function () {\n        return \"Uint8_\" + _super.prototype.toString.call(this);\n    };\n    Uint8List._capnp = {\n        displayName: 'List<Uint8>',\n        size: list_element_size_1.ListElementSize.BYTE,\n    };\n    return Uint8List;\n}(list_1.List));\nexports.Uint8List = Uint8List;\n\n//# sourceMappingURL=uint8-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/uint8-list.js\n// module id = 50\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint16List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint16List, _super);\n    function Uint16List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint16List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint16(c.byteOffset + index * 2);\n    };\n    Uint16List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint16(c.byteOffset + index * 2, value);\n    };\n    Uint16List.prototype.toString = function () {\n        return \"Uint16_\" + _super.prototype.toString.call(this);\n    };\n    Uint16List._capnp = {\n        displayName: 'List<Uint16>',\n        size: list_element_size_1.ListElementSize.BYTE_2,\n    };\n    return Uint16List;\n}(list_1.List));\nexports.Uint16List = Uint16List;\n\n//# sourceMappingURL=uint16-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/uint16-list.js\n// module id = 51\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint32List, _super);\n    function Uint32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint32(c.byteOffset + index * 4);\n    };\n    Uint32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint32(c.byteOffset + index * 4, value);\n    };\n    Uint32List.prototype.toString = function () {\n        return \"Uint32_\" + _super.prototype.toString.call(this);\n    };\n    Uint32List._capnp = {\n        displayName: 'List<Uint32>',\n        size: list_element_size_1.ListElementSize.BYTE_4,\n    };\n    return Uint32List;\n}(list_1.List));\nexports.Uint32List = Uint32List;\n\n//# sourceMappingURL=uint32-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/uint32-list.js\n// module id = 52\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint64List, _super);\n    function Uint64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint64(c.byteOffset + index * 8);\n    };\n    Uint64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint64(c.byteOffset + index * 8, value);\n    };\n    Uint64List.prototype.toString = function () {\n        return \"Uint64_\" + _super.prototype.toString.call(this);\n    };\n    Uint64List._capnp = {\n        displayName: 'List<Uint64>',\n        size: list_element_size_1.ListElementSize.BYTE_8,\n    };\n    return Uint64List;\n}(list_1.List));\nexports.Uint64List = Uint64List;\n\n//# sourceMappingURL=uint64-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/uint64-list.js\n// module id = 53\n// module chunks = 0","\"use strict\";\n/**\n * Why would anyone **SANE** ever use this!?\n *\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pointer_list_1 = require(\"./pointer-list\");\nvar void_1 = require(\"./void\");\nexports.VoidList = pointer_list_1.PointerList(void_1.Void);\n\n//# sourceMappingURL=void-list.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/pointers/void-list.js\n// module id = 54\n// module chunks = 0","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar types_1 = require(\"../types\");\nvar util_1 = require(\"../util\");\nvar pointers_1 = require(\"./pointers\");\nvar trace = debug_1.default('capnp:segment');\ntrace('load');\nvar Segment = /** @class */ (function () {\n    function Segment(id, message, buffer, byteLength) {\n        if (byteLength === void 0) { byteLength = 0; }\n        this[Symbol.toStringTag] = 'Segment';\n        this.id = id;\n        this.message = message;\n        this.buffer = buffer;\n        this._dv = new DataView(buffer);\n        this.byteOffset = 0;\n        this.byteLength = byteLength;\n    }\n    /**\n     * Attempt to allocate the requested number of bytes in this segment. If this segment is full this method will return\n     * a pointer to freshly allocated space in another segment from the same message.\n     *\n     * @param {number} byteLength The number of bytes to allocate, will be rounded up to the nearest word.\n     * @returns {Pointer} A pointer to the newly allocated space.\n     */\n    Segment.prototype.allocate = function (byteLength) {\n        trace('allocate(%d)', byteLength);\n        var segment = this;\n        byteLength = util_1.padToWord(byteLength);\n        if (byteLength > constants_1.MAX_SEGMENT_LENGTH - 8)\n            throw new Error(util_1.format(errors_1.SEG_SIZE_OVERFLOW, byteLength));\n        if (!segment.hasCapacity(byteLength))\n            segment = segment.message.allocateSegment(byteLength);\n        var byteOffset = segment.byteLength;\n        segment.byteLength = segment.byteLength + byteLength;\n        trace('Allocated %x bytes in %s (requested segment: %s).', byteLength, this, segment);\n        return new pointers_1.Pointer(segment, byteOffset);\n    };\n    /**\n     * Quickly copy a word (8 bytes) from `srcSegment` into this one at the given offset.\n     *\n     * @param {number} byteOffset The offset to write the word to.\n     * @param {Segment} srcSegment The segment to copy the word from.\n     * @param {number} srcByteOffset The offset from the start of `srcSegment` to copy from.\n     * @returns {void}\n     */\n    Segment.prototype.copyWord = function (byteOffset, srcSegment, srcByteOffset) {\n        var value = srcSegment._dv.getFloat64(srcByteOffset, constants_1.NATIVE_LITTLE_ENDIAN);\n        this._dv.setFloat64(byteOffset, value, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    /**\n     * Quickly copy words from `srcSegment` into this one.\n     *\n     * @param {number} byteOffset The offset to start copying into.\n     * @param {Segment} srcSegment The segment to copy from.\n     * @param {number} srcByteOffset The start offset to copy from.\n     * @param {number} wordLength The number of words to copy.\n     * @returns {void}\n     */\n    Segment.prototype.copyWords = function (byteOffset, srcSegment, srcByteOffset, wordLength) {\n        var dst = new Float64Array(this.buffer, byteOffset, wordLength);\n        var src = new Float64Array(srcSegment.buffer, srcByteOffset, wordLength);\n        dst.set(src);\n    };\n    /**\n     * Quickly fill a number of words in the buffer with zeroes.\n     *\n     * @param {number} byteOffset The first byte to set to zero.\n     * @param {number} wordLength The number of words (not bytes!) to zero out.\n     * @returns {void}\n     */\n    Segment.prototype.fillZeroWords = function (byteOffset, wordLength) {\n        new Float64Array(this.buffer, byteOffset, wordLength).fill(0);\n    };\n    /**\n     * Get the total number of bytes available in this segment (the size of its underlying buffer).\n     *\n     * @returns {number} The total number of bytes this segment can hold.\n     */\n    Segment.prototype.getCapacity = function () {\n        return this.buffer.byteLength;\n    };\n    /**\n     * Read a float32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat32 = function (byteOffset) {\n        return this._dv.getFloat32(byteOffset, true);\n    };\n    /**\n     * Read a float64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat64 = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, true);\n    };\n    /**\n     * Read an int16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt16 = function (byteOffset) {\n        return this._dv.getInt16(byteOffset, true);\n    };\n    /**\n     * Read an int32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt32 = function (byteOffset) {\n        return this._dv.getInt32(byteOffset, true);\n    };\n    /**\n     * Read an int64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt64 = function (byteOffset) {\n        return new types_1.Int64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read an int8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt8 = function (byteOffset) {\n        return this._dv.getInt8(byteOffset);\n    };\n    /**\n     * Read a uint16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint16 = function (byteOffset) {\n        return this._dv.getUint16(byteOffset, true);\n    };\n    /**\n     * Read a uint32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint32 = function (byteOffset) {\n        return this._dv.getUint32(byteOffset, true);\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     * NOTE: this does not copy the memory region, so updates to the underlying buffer will affect the Uint64 value!\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint64 = function (byteOffset) {\n        return new types_1.Uint64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint8 = function (byteOffset) {\n        return this._dv.getUint8(byteOffset);\n    };\n    Segment.prototype.hasCapacity = function (byteLength) {\n        trace('hasCapacity(%d)', byteLength);\n        // capacity - allocated >= requested\n        return this.buffer.byteLength - this.byteLength >= byteLength;\n    };\n    /**\n     * Quickly check the word at the given offset to see if it is equal to zero.\n     *\n     * PERF_V8: Fastest way to do this is by reading the whole word as a `number` (float64) in the _native_ endian format\n     * and see if it's zero.\n     *\n     * Benchmark: http://jsben.ch/#/Pjooc\n     *\n     * @param {number} byteOffset The offset to the word.\n     * @returns {boolean} `true` if the word is zero.\n     */\n    Segment.prototype.isWordZero = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, constants_1.NATIVE_LITTLE_ENDIAN) === 0;\n    };\n    /**\n     * Swap out this segment's underlying buffer with a new one. It's assumed that the new buffer has the same content but\n     * more free space, otherwise all existing pointers to this segment will be hilariously broken.\n     *\n     * @param {ArrayBuffer} buffer The new buffer to use.\n     * @returns {void}\n     */\n    Segment.prototype.replaceBuffer = function (buffer) {\n        trace('replaceBuffer(%p)', buffer);\n        if (this.buffer === buffer)\n            return;\n        if (buffer.byteLength < this.byteLength)\n            throw new Error(errors_1.SEG_REPLACEMENT_BUFFER_TOO_SMALL);\n        this._dv = new DataView(buffer);\n        this.buffer = buffer;\n    };\n    /**\n     * Write a float32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat32 = function (byteOffset, val) {\n        this._dv.setFloat32(byteOffset, val, true);\n    };\n    /**\n     * Write an float64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat64 = function (byteOffset, val) {\n        this._dv.setFloat64(byteOffset, val, true);\n    };\n    /**\n     * Write an int16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt16 = function (byteOffset, val) {\n        this._dv.setInt16(byteOffset, val, true);\n    };\n    /**\n     * Write an int32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt32 = function (byteOffset, val) {\n        this._dv.setInt32(byteOffset, val, true);\n    };\n    /**\n     * Write an int8 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt8 = function (byteOffset, val) {\n        this._dv.setInt8(byteOffset, val);\n    };\n    /**\n     * Write an int64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Int64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint16 = function (byteOffset, val) {\n        this._dv.setUint16(byteOffset, val, true);\n    };\n    /**\n     * Write a uint32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint32 = function (byteOffset, val) {\n        this._dv.setUint32(byteOffset, val, true);\n    };\n    /**\n     * Write a uint64 value to the specified offset.\n     * TODO: benchmark other ways to perform this write operation.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Uint64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset + 0, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint8 (byte) value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint8 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val);\n    };\n    /**\n     * Write a zero word (8 bytes) to the specified offset. This is slightly faster than calling `setUint64` or\n     * `setFloat64` with a zero value.\n     *\n     * Benchmark: http://jsben.ch/#/dUdPI\n     *\n     * @param {number} byteOffset The offset of the word to set to zero.\n     * @returns {void}\n     */\n    Segment.prototype.setWordZero = function (byteOffset) {\n        this._dv.setFloat64(byteOffset, 0, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    Segment.prototype.toString = function () {\n        return util_1.format('Segment_id:%d,off:%a,len:%a,cap:%a', this.id, this.byteLength, this.byteOffset, this.buffer.byteLength);\n    };\n    return Segment;\n}());\nexports.Segment = Segment;\n\n//# sourceMappingURL=segment.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/capnp-ts/lib/serialization/segment.js\n// module id = 55\n// module chunks = 0"],"sourceRoot":""}